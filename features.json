{
    "0": {
        "problem_text": "양의 정수 $N$이 주어질 때, $\\displaystyle\\frac{1}{2^N}$을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정수 $N$이 주어진다.\n",
        "output_text": "첫째 줄에 $\\displaystyle\\frac{1}{2^N}$의 정확한 값을 소수 형태로 출력한다. 단, 뒤에 불필요한 $0$을 덧붙여서는 안 된다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 271.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "1": {
        "problem_text": "One of the farming chores Farmer John dislikes the most is hauling around lots of cow manure. In order to streamline this process, he comes up with a brilliant invention: the manure teleporter! Instead of hauling manure between two points in a cart behind his tractor, he can use the manure teleporter to instantly transport manure from one location to another.\nFarmer John's farm is built along a single long straight road, so any location on his farm can be described simply using its position along this road (effectively a point on the number line). A teleporter is described by two numbers $x$ and $y$, where manure brought to location $x$ can be instantly transported to location $y$, or vice versa.\nFarmer John wants to transport manure from location $a$ to location $b$, and he has built a teleporter that might be helpful during this process (of course, he doesn't need to use the teleporter if it doesn't help). Please help him determine the minimum amount of total distance he needs to haul the manure using his tractor.\n",
        "input_text": "The first and only line of input contains four space-separated integers: $a$ and $b$, describing the start and end locations, followed by $x$ and $y$, describing the teleporter. All positions are integers in the range $0 \\ldots 100$, and they are not necessarily distinct from each-other.\n",
        "output_text": "Print a single integer giving the minimum distance Farmer John needs to haul manure in his tractor.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 322.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "2": {
        "problem_text": "실수 $t$에 대하여, 함수 $f(x)$가 $x=t$에서 정의되어 있고, $\\lim_{x \\rightarrow t} f(x) = f(t)$인 경우 \"$f(x)$는 $x=t$에서 연속이다\"라고 한다. \n함수 $f(x) = \\begin{cases}ax+b & (x \\leq k)\\\\ cx+d & (x > k)\\end{cases}$가 주어질 때, 이 함수가 $x=k$에서 연속인지 판별하자.\n",
        "input_text": "첫 번째 줄에 정수 $k$가 주어진다. $(-10^7 \\leq k \\leq 10^7)$\n두 번째 줄에 정수 $a$, $b$, $c$, $d$가 공백으로 구분되어 주어진다. $(-10^7 \\leq a, b, c, d \\leq 10^7;$ $a, c \\neq 0)$\n",
        "output_text": "$f(x)$가 $x=k$에서 연속이라면, Yes와 $f(k)$를 공백으로 구분하여 출력하고, 아니라면 No를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 286.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "3": {
        "problem_text": "음 아닌 정수 N이 주어졌을 때, 이 수를 서로 다른 정수 M(M ≥ 1)개의 팩토리얼의 합으로 나타낼 수 있는지 알아내는 프로그램을 작성하시오. 예를 들어 2=0!+1!로 나타낼 수 있지만, 5는 이와 같은 방식으로 나타낼 수 없다.\n",
        "input_text": "첫째 줄에 정수 N이 주어진다.\n",
        "output_text": "입력으로 주어진 수를 서로 다른 정수 M개의 팩토리얼의 합으로 나타낼 수 있으면 YES, 없으면 NO를 출력한다. \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 528.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "4": {
        "problem_text": "카를 프리드리히 가우스는 독일의 수학자이다.\n가우스가 초등학교에 다닐 때, 선생님 J.G. Büttner는 1부터 100까지 수의 합을 계산하게 시켰다. 가우스는 몇 초만에 정확한 답 5050을 계산했다.\nn과 m 이 주어졌을 때, n보다 크거나 같고, m보다 작거나 같은 모든 정수의 합을 구하는 프로그램을 작성하시오. 즉, 다음을 계산하라.\n\\[\\sum_{i=n}^{m} {i} = n+(n+1)+(n+2)+ \\dots + (m-1) + m\\]\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, n과 m이 주어진다. (-109 ≤ n ≤ m ≤ 109)\n",
        "output_text": "각 테스트 케이스마다 \"Scenario #i:\"를 출력한 다음, n부터 m까지 모든 정수의 합을 출력한다. 각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 374.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "5": {
        "problem_text": "Tanya has an account in \"Redgotts\" bank. The bank has the commission to transfer money to \"Bluegotts\" bank that her friend Vanya has the account in.\nTanya has read her bank rules and learned the following:\nThe commission for the bank transfer is $25$ tugriks plus $1\\%$ of the sum transferred. However, the commission is never smaller than $100$ tugriks, and cannot exceed $2000$ tugriks.\nTanya is planning to transfer $k$ tugriks to Vanya. Help her find out what the commission would be.\n",
        "input_text": "Input is a single integer $k$ ($200 \\le k \\le 10^9$).\n",
        "output_text": "Output one floating point value: the commission for the transfer. The value must be printed with at least two exact digits after the decimal point.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 273.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "6": {
        "problem_text": "In 2012 a new world record was set in the famous Nathan’s Hot Dog Eating Competition: the champion, Joey Chestnut, ate 68 hot dogs in ten minutes, an amazing increase from the 62 hot dogs eaten by the same Chestnut in 2011.\nNathan’s Famous Corporation, in Brooklyn, NY, is responsible for the contest. They make delicious hot dogs, famous worldwide, but when it comes to math they are not so good. They want to apply for being listed in the Guinness World of Records, but for that they need to fill up a form describing basic facts about the competition. In particular, they are required to inform the average number of hot dogs eaten by participants during the contest.\nCan you help them? They promised to pay you with one of their tasty hot dogs. Given the total number of hot dogs consumed and the total number of participants in the contest, you must write a program to determine the average number of hot dogs eaten by participants.\n",
        "input_text": "Each test case is described using one line. The line contains two integers H and P representing respectively the total number of hot dogs consumed and the total number of participants in the contest (1 ≤ H, P ≤ 1000).\n",
        "output_text": "For each test case output a line with a rational number representing the average number of hot dogs eaten by participants. The result must be output as a rational number with exactly two digits after the decimal point, rounded if necessary.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 201.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "7": {
        "problem_text": "Nadja klistrar ihop små träkuber med sidlängd 1 till större kompakta kuber. Hon har nu bestämt sig för att hon vill ha en kub av varje sidlängd från 1 till N. Hur många småkuber behöver Nadja?\n",
        "input_text": "På den första och enda raden i indatan står heltalet $N$, $1 \\leq N \\leq 100$.\n",
        "output_text": "Programmet ska skriva ut en rad med ett heltal: antelet småkuber Nadja behöver.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 204.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "8": {
        "problem_text": "정연이는 트럼프 카드 (Playing Card)로 할 수 있는 새로운 게임을 만들기로 결심했다.\n우선 이 게임은 딜러와 플레이어가 1:1로 플레이한다. 그리고 플레이어는 놓여진 52장의 트럼프 카드에서 N장의 카드를 뽑는다. 뽑은 카드들로 \"포카드 (four of a kind)\" 족보를 만들 수 있다면 플레이어의 승리, 만들 수 없다면 딜러의 승리로 게임이 끝난다. 그러나 정연이는 아직 공정한 게임을 위한, 뽑는 카드의 수 N을 결정하지 못하였다.\n정연이가 쉽게 결정을 내릴 수 있도록, N개의 카드를 뽑았을 때 플레이어가 이기는 경우의 수를 출력하는 프로그램을 작성해주자.\n트럼프 카드는 다음과 같은 52장의 카드로 구성된다.\n\nFigure: 트럼프 카드 (Playing Card)의 구성\n문양 4개: ♥, ♠, ◆, ♣, 숫자 13개: A, 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K\n총 4 x 13 = 52장\n포카드 (four of a kind)는 뽑은 N장의 카드 중에 \"같은 숫자를 가진, 다른 문양의 4장의 카드\"가 존재하는 경우를 의미한다. 또한 플레이어가 이기는 경우의 수는 N장의 카드에 이러한 카드 조합을 1쌍 이상 포함하고 있는 경우의 수를 의미한다.\n",
        "input_text": "첫째 줄에 뽑는 카드의 수 N이 주어진다. (1 ≤ N ≤ 52)\n",
        "output_text": "첫째 줄에 N장의 카드를 뽑았을 때, 플레이어가 이기는 경우의 수를 10,007로 나눈 나머지를 출력하라.\n",
        "memory_median": 2032.0,
        "time_median": 0.0,
        "length_median": 746.0,
        "label": [
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "9": {
        "problem_text": "선영이는 남자친구를 위해 연애 편지를 썼다. 선영이는 편지가 남들에게 읽히는 것을 막기 위해서 편지를 암호화하려고 한다.\n먼저, 편지의 내용을 정사각형에 작성한다. 그 다음, 시계방향으로 90도 회전시킨다. 그 다음, 첫 행부터 마지막 행까지 순서대로 다시 편지를 작성한다. 선영이는 싸이월드 세대이기 때문에, 편지에 띄어쓰기를 쓰지 않는다.\n예를 들어, 편지의 내용이 \"RosesAreRedVioletsAreBlue\"인 경우에, 암호화한 편지는 \"eedARBtVrolsiesuAoReerles\" 이 된다.\n\n선영이가 암호화한 편지가 주어졌을 때, 원래 내용을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 수는 최대 100개이다.\n각 테스트 케이스는 한 줄로 이루어져 있으며, 암호화된 편지가 주어진다. 편지는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 1보다 크거나 같고, 10,000보다 작거나 같으며, 항상 제곱수이다.\n",
        "output_text": "각 테스트 케이스마다 원래 메시지를 출력한다.\n",
        "memory_median": 2036.0,
        "time_median": 12.0,
        "length_median": 510.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "10": {
        "problem_text": "세준이는 정문이를 데리러 공항으로 가기로 했다. 하지만, 방금 세준이는 정문이의 비행기가 연착된다는 전화를 받았다. 세준이는 정문이가 정확하게 몇 분 늦는지 알고 있고, 그 시간 동안 밖에서 드라이브를 하려고 한다. 정문이가 늦는 시간을 T라고 하자.\n세준이는 자기가 지금 있는 위치에서부터, 공항까지 정확하게 T분만에 도착하는 경로의 개수를 구하고 싶다.\n길의 정보는 인접행렬로 주어진다. A[i][j]가 0이라면 i에서 j로 가는 길이 없는 것이고, A[i][j] ≤ 5라면, 정확히 그 만큼의 시간이 걸리는 i에서 j로 가는 길이 있는 것이다.\n",
        "input_text": "첫째 줄에 교차점의 개수 N이 주어진다. N은 10보다 작거나 같고, 시작점의 위치 S와 끝점의 위치 E, 그리고 정문이가 늦는 시간 T도 주어진다. S와 E는 N보다 작거나 같은 자연수이다. T는 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄부터 길의 정보가 주어진다.\n",
        "output_text": "첫째 줄에 경로의 개수를 1,000,003로 나눈 나머지를 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 28.0,
        "length_median": 1479.0,
        "label": [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "11": {
        "problem_text": "การสอบวัดความรู้ระดับพื \u0011นฐานด้าน IT หรือ IP (IT Passport Examination) มีข้อสอบ 100 ข้อ ข้อละ 1 คะแนน คิดเป็น 100% ขอบเขตเนื \u0011อหามี 3 หมวดได้แก่\n\nStrategy (กลยุทธ์) 35%\nManagement (การจัดการ IT) 25%\nTechnology (เทคโนโลยี) 40%\n\nเกณฑ์การสอบผ่าน ผู้เข้าสอบต้องได้คะแนนรวมไม่ตํ\bากว่า 55% และ ต้องได้คะแนนในแต่ละหมวดไม่ตํLากว่า 30% ของคะแนนในหมวดนั \u0011น\nจงเขียนโปรแกรมประเมินผลการสอบนี \u0011 \n",
        "input_text": "บรรทัดแรก เป็นจํานวนเต็ม N ระบุจํานวนผู้สอบ และ N บรรทัด ต่อมาเป็นข้อมูลของผู้เข้าสอบแต่ละคน ข้อมูลผู้เข้าสอบแต่ละบรรทัดประกอบด้วย หมายเลขผู้สอบ(ตัวเลข 8 หลัก) แล้วตามด้วยจํานวนเต็ม 3 ค่า ซึLงเป็น คะแนนสอบในหมวดทีL 1, 2 และ 3 ตามลําดับ\n",
        "output_text": "แต่ละบรรทัดให้พิมพ์หมายเลขผู้เข้าสอบและ ตามด้วยคะแนนรวม และผลการสอบ (PASS หรือ FAIL) ดัง รูปแบบในตัวอย่าง (ตามลําดับจากอินพุต) \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 398.5,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "12": {
        "problem_text": "JOI アイスクリーム店は，非常に高さのあるアイスクリームタワーが名物のアイスクリーム店である．アイスクリームタワーとは，ベースとなるアイスクリームの上に，追加のアイスクリームを 0 個以上積み重ねたものである．\nベースとなるアイスクリームの金額は 250 円で，高さは A cm である．追加のアイスクリームは 1 個につき 100 円で，1 個追加するごとにアイスクリームタワーの高さが B cm 増える．\nあなたは，この店で高さが S cm 以上のアイスクリームタワーを買いたい．高さが S cm 以上のアイスクリームタワーを買うために必要な金額の最小値を求めよ．\n",
        "input_text": "入力は以下の形式で標準入力から与えられる．\n\r\nS\r\nA\r\nB\n",
        "output_text": "高さ S cm 以上のアイスクリームタワーを買うために必要な金額の最小値を，単位 (円) を省いて出力せよ．\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 250.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "13": {
        "problem_text": "\n혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n\nhttp://wdown.ebsi.co.kr/W61001/01exam/20061116/mathga1_mun.pdf\nhttp://www.suneung.re.kr/boardCnts/fileDown.do?fileSeq=e7700624691c4dcb8a2cfc3f959204fe\n\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다. 그림에서 흐릿하게 보이는 모든 부분은 원래 문제와 다르지 않다.\n빈 칸에 들어갈 두 자연수가 주어졌을 때 문제를 해결하는 프로그램을 작성하자.\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 수 T (1 ≤ T ≤ 50 000)가 주어진다. 이후 T개의 테스트 케이스가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있으며, 각 줄에는 두 개의 정수 A와 B (1 ≤ A, B ≤ 1 023, A ≠ B)가 공백을 사이로 두고 주어진다. 이는 첫 번째 빈 칸에는 A를, 두 번째 빈 칸에는 B를 넣었을 때 답을 구하라는 의미이다\n",
        "output_text": "각 테스트 케이스에 대해 답을 한 줄에 하나씩 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 20.0,
        "length_median": 460.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "14": {
        "problem_text": "A, B, C가 주어졌을 때, Ax+Bsin(x)=C를 만족하는 x를 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정수 A, B, C가 주어진다. (0 < B ≤ A ≤ 100,000, 0 < C ≤ 100,000)\n",
        "output_text": "첫째 줄에 x를 출력한다. 정답과의 절대/상대 오차는 10-9까지 허용한다.\n",
        "memory_median": 2038.0,
        "time_median": 0.0,
        "length_median": 501.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "15": {
        "problem_text": "정수 m, n을 입력 받아, 10진수 m을 n진수로 바꾸어 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫 줄에서 정수 m, n을 입력 받는다. (0 ≤ m ≤ 1,000,000, 2 ≤ n ≤ 16)\n",
        "output_text": "변환한 n진수의 수를 출력한다. 11~16 진수의 경우 10 이상의 수는 A~F 문자를 사용한다. 예를 들어, 10은 A, 11은 B, 12는 C, 13은 D, 14는 E, 15는 F를 사용한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 412.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "16": {
        "problem_text": "가로, 세로 길이가 모두 N인 커다란 종이가 주어져 있다. 좌표 (X, Y)는 종이의 가장 왼쪽 위 점을 (0, 0) 으로 하고, (0, 0)에서 세로로 거리 X, 가로로 거리 Y 를 이동한 점을 의미한다. 따라서, 종이의 가장 오른쪽 아래 점의 좌표는 (N, N)이 된다.\nC개의 점이 주어진다. 점들의 좌표는 모두 양의 정수이고, 순서대로 1부터 C까지 번호가 매겨진다. 두 개 이상의 점이 같은 좌표를 가질 수도 있다.\n번호 순서대로 점들에 대해서 다음과 같은 일을 한다. 현재 종이의 세로 길이가 A, 가로 길이가 B이고, 이번 순서의 점이 (X, Y )라고 하자. 처음 시작할 때는 A와 B 모두 N과 같다.\n\n만약 점이 종이의 경계나 밖에 있다면, 즉 X ≥ A이거나, Y ≥ B라면 이 점은 무시된다.\n만약 점이 종이 안에 있다면, 이 점을 지나는 가로 방향 직선으로 종이를 자르는 것과, 세로 방향 직 선으로 종이를 자르는 것 중 하나를 수행해야 한다. 종이를 가로로 자를 때는 위쪽을 남기고 아래쪽을 버리고, 세로로 자를 때는 왼쪽을 남기고 오른쪽을 버린다. 두 경우 중에서 남은 직사각형의 면적이 넓은 쪽을 선택해야 한다. 만약 두 경우의 남은 직사각형의 면적이 같다면, 가로로 잘라야 한다.\n\n다음 예제를 생각해보자.\n\n세로 길이 4, 가로 길이 8인 종이가 주어져 있는 상태에서, 점 (3, 6)을 생각해보자. 그림에서 한 칸은 면적이 1이다. 이 경우 이 점을 지나는 세로 직선으로 종이를 자르면 세로 길이 4, 가로 길이 6인 종이가 남고, 이 점을 지나는 가로 직선으로 종이를 자르면 세로 길이 3, 가로 길이 8인 종이가 남게 된다. 두 사각형은 모두 면적이 24로 같으므로 조건에 따라 가로로 잘라야 한다. 그래서, 이 예에서는 세로 길이 3, 가로 길이 8인 종이가 남는다.\n위 일을 C개의 모든 점에 대해서 1번부터 C번까지 차례대로 수행했을 때, 마지막으로 남는 종이의 면적을 구하시오.\n",
        "input_text": "첫째 줄에, 두 정수 N과 C가 공백 하나씩을 사이에 두고 주어진다. 다음 C 줄에는 각 줄마다 차례대로 점 (X, Y)를 나타내는 두 정수 X와 Y가 공백 하나씩을 사이에 두고 주어진다.\n",
        "output_text": "첫째 줄에 마지막으로 남는 종이의 면적을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 396.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "17": {
        "problem_text": "한 변의 길이가 1cm인 정사각형 모양의 타일이 있다. 이 타일들을 가로가 xcm, 세로가 ycm인 직사각형 모양의 벽에 빈틈없이 붙였다. x와 y는 정수이다.\n이 직사각형에 하나의 대각선을 그렸다. 직사각형에 붙어 있는 x*y개의 타일 중에는 대각선이 그려진 타일도 있고, 그렇지 않은 타일도 있다. x*y개의 타일 중에서 대각선이 그려져 있는 타일의 개수를 구하는 프로그램을 작성하시오.\n \n",
        "input_text": "첫째 줄에 가로의 길이 xcm와 세로의 길이 ycm가 주어진다. x와 y는 1,000,000,000 이하의 자연수이다. x와 y사이에는 빈칸이 하나 이상 있다.\n",
        "output_text": "첫째 줄에 대각선이 그려져 있는 타일의 개수를 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 268.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "18": {
        "problem_text": "백준 온라인 저지의 송년대회 Good Bye, BOJ 2023!의 개최일은 2023년 12월 31일이다. 키파는 대회가 개최된다는 사실이 기뻐 2023과 2024를 뚫어져라 보다가 무언가 특별하다는 사실을 깨달았다.\n그렇다. 내년의 연도인 2024가 올해 연도의 끝 두 자리인 23으로 나누어 떨어진다! 다음에도 이런 연도가 오려면 6년 뒤인 2029/2030년이 되어야 한다.\n양의 정수 $N$이 주어진다. $N$년과 $N+1$년이 이러한 조건을 만족하는 관계인지 판별하는 프로그램을 작성하라.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 $T$가 주어진다.\n이후 $T$개의 줄에 걸쳐 테스트 케이스가 한 줄에 하나씩 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있으며, 각각 한 개의 양의 정수 $N$이 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해, $N+1$이 $N$의 끝 두 자리로 나누어 떨어진다면 Good을, 그렇지 않다면 Bye를 한 줄에 하나씩 차례로 출력하여라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 320.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "19": {
        "problem_text": "두 학생 A와 B가 일직선상의 트랙에서 같은 방향으로 멀리뛰기를 하고 있다. A는 한 번에 X 미터를, B는 한 번에 Y 미터를 뛴다. 두 학생의 시작 지점과 X, Y에 대한 정보가 주어졌을 때, 두 학생이 공통적으로 지나게 되는 지점 중에서 시작 지점으로부터 가장 가까운 지점을 찾는 프로그램을 작성하시오.\n예를 들어 한 번에 10미터를 뛰는 A는 30의 지점에서 멀리뛰기를 시작하고, 한 번에 12미터를 뛰는 B는 8의 지점에서 시작한다고 가정하자. A가 5번의 멀리뛰기를 하고, B가 6번의 멀리뛰기를 하면 두 사람은 80의 지점을 공통으로 지나게 되며, 이는 두 학생의 시작 지점에서 가장 가까운 지점이다.\n",
        "input_text": "첫째 줄에 두 사람이 한 번에 멀리뛰기를 하는 거리 X, Y와 시작 지점의 위치 값 P1, P2가 각각 공백을 기준으로 구분되어 자연수로 주어진다. (1 ≤ X, Y, P1, P2 ≤ 100)\n",
        "output_text": "첫째 줄에 두 학생이 공통적으로 지나는 지점 중에서 가장 가까운 지점을 출력한다.\n단, 두 학생이 공통적으로 지나는 지점이 없다면 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 424.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "20": {
        "problem_text": "Dima is bored of playing checkers with himself. Since there is nothing but checker pieces to play with, he came up with the following game.\nEach piece he has is either white or black. Dima builds a tower by stacking his pieces on top of each other in some order. A black stripe is a sequence of adjacent black pieces, with either a white piece, or the end of the tower at the bottom and top of it. In other words, two adjacent black pieces always belong to the same black stripe. The goal of the game is to get the maximum number of black stripes in the tower.\nThe game has just started. Dima has $a$ white and $b$ black pieces. What is the maximum number of black stripes he can get in his tower?\n",
        "input_text": "The only line of input contains two integers $a$ and $b$ --- the number of white and black pieces, respectively ($0 \\le a, b \\le 10^{18}$).\n",
        "output_text": "Output a single integer --- the maximum possible number of black stripes.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 196.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "21": {
        "problem_text": "대한민국 지폐는 천 원권, 오천 원권, 만 원권, 오만 원권으로 총 네 종류가 있다. 각 지폐의 세로 길이는 $68\\text{mm}$로 모두 같지만, 가로 길이는 모두 다르다. 천 원권의 가로 길이는 $136\\text{mm}$, 오천 원권의 가로 길이는 $142\\text{mm}$, 만 원권의 가로 길이는 $148\\text{mm}$, 오만 원권의 가로 길이는 $154\\text{mm}$이다. 따라서 가로의 길이를 통해서 지폐의 종류를 구분할 수 있다.\n수민이는 대한민국 지폐 $N$장을 가지고 있다. 수민이는 종이의 크기를 재는 기계를 이용하여 각 지폐의 가로, 세로 길이를 알아냈다. 수민이가 가진 지폐의 총액을 구해보자.\n",
        "input_text": "첫째 줄에 정수 $N(1\\leq N\\leq 100)$이 주어진다.\n둘째 줄부터 $N$개의 줄에 각 지폐의 가로, 세로 길이가 공백으로 구분되어 $\\text{mm}$단위로 주어진다. 주어지는 지폐의 가로, 세로 길이의 길이는 정수이고 천 원권, 오천 원권, 만 원권, 오만 원권의 가로, 세로 길이 중 하나이다.\n",
        "output_text": "수민이가 가진 지폐의 총액을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 423.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "22": {
        "problem_text": "정수 오버플로우(Integer Overflow)란 정수형 변수가 연산 중 표현 범위를 넘어 의도와는 다른 값이 저장되는 현상을 말한다. C/C++, Java와 같이 변수의 타입과 함께 그 크기가 미리 정해지는 언어에서 종종 발생한다.\n변수의 타입에 대해 공부했다면 231-1, 2,147,483,647과 같은 수가 익숙할 텐데 이는 일반적인 4byte Integer 변수로 표현할 수 있는 양의 정수의 최댓값이다. 만약 4byte Integer 변수 1,000,000과 1,000,000을 곱하면 어떻게 될까? 결과는 컴파일러마다 다를 수 있지만, 우리가 원하는 값인 1,000,000,000,000이 나오지는 않을 것이다. 이미 연산과정에서 표현할 수 있는 범위를 벗어난 이 값은 4byte Integer가 표현 가능한 다른 값으로 변형되어 있을 것이다.\n그렇다면 어떻게 할 수 있을까? 첫 번째는 보다 큰 범위의 정수 변수를 사용하는 것이다. 예를 들어 int가 아닌 C/C++에서의 long long, Java에서의 long과 같은 타입을 사용하면 우리는 -263 ~ 263-1 까지의 정수를 표현할 수 있다. 또한 놀랍게도 Python과 같이 타입에 따른 메모리 제한이 없어 사용자가 오버플로우에 대한 처리를 고려하지 않아도 되는 언어들도 있다.\n이 문제에서 우리는 N개의 정수를 곱할 것이다. 하지만 정수의 곱이란 너무나도 빠르게 증가하기 때문에 그 결과가 정수변수로 표현할 수 있는 범위를 넘어갈 수도 있다. 그러니 우리는 (A × B) % M = ((A % M) × (B % M)) % M 과 같은 공식에 착안하여 N개의 정수를 곱한 결과값을 M으로 나눈 나머지를 비교하도록 하자.\nN개의 정수와 M이 주어질 때, 모든 정수의 곱을 M으로 나눈 나머지를 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫 줄에 연산될 정수의 개수 N(1 ≤ N ≤ 100)과 M(1 ≤ M ≤ 2,147,483,647)이 주어진다. 두 번째 줄에는 N개의 정수 ai (1 ≤ ai ≤ 2,147,483,647)가 한 줄로 주어진다. \n",
        "output_text": "한 줄에 N개의 정수의 곱을 M으로 나눈 나머지를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 282.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "23": {
        "problem_text": "민혁이는 한국에서 열리는 7종 경기 대회에 참가한다. 7종 경기는 육상의 필드 경기와 트랙 경기 7 종목으로 이루어져 있다. (100미터 허들, 높이뛰기, 포환던지기, 200미터 달리기, 멀리뛰기, 창던지기, 800미터 달리기) 민혁이의 각 종목의 기록이 주어졌을 때, 기록을 점수로 환산해서 총점을 구하는 프로그램을 작성하시오.\n7종 경기의 총점은 각 종목의 점수의 합이다. 각 종목의 점수는 다음과 같은 식을 이용해서 구할 수 있다.\n\n트랙 경기: \\(Score=\\left\\lfloor A \\times (B-P)^{C} \\right\\rfloor\\)\n필드 경기: \\(Score=\\left\\lfloor A \\times (P-B)^{C} \\right\\rfloor\\)\n\nA, B, C는 아래 표에 적혀져 있는 상수이다. P는 선수의 성적으로 단위는 아래에 나와있다.\n모든 종목의 점수는 정수이다.\n\n\n\n종목\nA\nB\nC\nP\n종류\n\n\n\n\n100미터 허들\n9.23076\n26.7\n1.835\nsec\n트랙\n\n\n높이뛰기\n1.84523\n75\n1.348\ncm\n필드\n\n\n포환던지기\n56.0211\n1.5\n1.05\nm\n필드\n\n\n200미터 달리기\n4.99087\n42.5\n1.81\nsec\n트랙\n\n\n멀리뛰기\n0.188807\n210\n1.41\ncm\n필드\n\n\n창던지기\n15.9803\n3.8\n1.04\nm\n필드\n\n\n800미터 달리기\n0.11193\n254\n1.88\nsec\n트랙\n\n\n\n모든 필드 경기는 B ≤ P, 트랙 경기는 P ≤ B를 만족한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 1000) 각 테스트 케이스는 일곱 개의 정수로 이루어져 있다. 이 정수는 민혁이의 종목별 기록이다. 순서는 100미터 허들, 높이뛰기, 포환던지기, 200미터 달리기, 멀리뛰기, 창던지기, 800미터 달리기이다.\n",
        "output_text": "각 테스트 케이스에 대해서, 민혁이의 총점을 출력한다.\n",
        "memory_median": 2172.0,
        "time_median": 20.0,
        "length_median": 681.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "24": {
        "problem_text": "유신이는 여러개의 문을 통과해야 밖으로 나갈 수 있는 방에 갇혔다. 유신이를 가둔 재현이는 유신이가 탈출할 수 없도록 하기 위해 특이한 규칙을 만들어 문을 순서대로 규칙에 맞는 방법으로 열어야하도록 시스템을 구성하였다.\n\n규칙 1 : 문을 여는 방법은 두가지가 있다. 밀어서 여는 법과 당겨서 여는 법이 있다.\n규칙 2 :연속 2번 같은 방법으로 문을 열 수 없다.\n규칙 3 : 2의 배수(2,4,6,...)번째 문들은 반드시 같은 방법으로 문을 열어야 한다. 예를 들어 2번째 통과하는 문을 밀어서 열었다면, 4번째 통과하는 문 또한 밀어서 열어야 한다.\n규칙 4 : 3의 배수(3,6,9,...)번째 문들은 반드시 같은 방법으로 문을 열어야 한다. 예를 들어 3번째 통과하는 문을 밀어서 열었다면, 6번째 통과하는 문 또한 밀어서 열어야한다.\n\n유신이는 위의 규칙 4가지를 모두 알고 있음에도 불구하고 탈출하지 못하고 있다. 유신이가 방을 탈출할 수 있도록 도와주는 프로그램을 만들어보자.\n",
        "input_text": "첫째 줄에 총 문의 개수 N(2 ≤ N ≤ 2,500,000,000)이 주어진다.\n둘째 줄에는 유신이가 첫 번째 문을 통과할 때 문을 연 방법이 주어진다. 밀어서 여는 법은 숫자 0, 당겨서 여는 법은 숫자 1로 표기된다.\n",
        "output_text": "두 번째 문부터 문을 여는 방법을 한줄에 하나씩 출력한다. 만약 탈출이 불가능하다면 \"Love is open door\"를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 361.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "25": {
        "problem_text": "피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.\n이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.\nn=17일때 까지 피보나치 수를 써보면 다음과 같다.\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\nn이 주어졌을 때, 0번째 피보나치 수의 제곱부터 n번째 피보나치 수의 제곱을 합한 값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 0번째 피보나치 수의 제곱부터 n번째 피보나치 수의 제곱의 합을 1,000,000,007으로 나눈 나머지를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 977.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "26": {
        "problem_text": "소프트웨어융합대학 학생회에서 주최한 소융체전에서 청기 백기 뒤집기 게임이 한창이다. 소프트웨어학부, ICT융합학부가 번갈아가면서 게임을 진행하는 중이다. 게임의 규칙은 간단하다. 게임을 진행할 차례인 학부에서 출전한 선수들 N명이 존재한다. 학생들의 앞 탁자에는 N개의 깃발이 청색이 위로 백색이 아래로 보이도록 놓여있다. 이때 출전한 선수 중 첫 번째 선수는 N개의 깃발 중 1의 배수에 해당하는 번호의 깃발을 뒤집어 놓는다. 다음 두 번째 선수는 N개의 깃발 중 2의 배수에 해당하는 번호의 깃발을 뒤집어 놓는다. i 번째 선수는 i의 배수에 해당하는 번호의 깃발을 뒤집고, N 번째 선수까지 진행하면 끝이 난다. 그렇다면 이 게임에서 N 명의 선수가 참가하고 N개의 깃발이 존재할 때, N 번째 선수까지 진행하여 완료된 상태에서 백색이 위로 놓여있는 깃발의 수가 몇 개인지 알아보자.\n",
        "input_text": "첫 번째 줄에 출전한 학생의 수이자, 깃발의 개수인 N(1 ≤ N ≤ 2,100,000,000)이 주어진다.\n",
        "output_text": "첫 번째 줄에 N 번째 선수까지 진행한 후의 상태의 깃발 중 백색이 위로 놓여있는 깃발의 수를 출력한다.\n",
        "memory_median": 2000.0,
        "time_median": 0.0,
        "length_median": 206.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "27": {
        "problem_text": "철수는 화학 시험을 망치고, 애꿎은 화학 선생님에게 복수를하기로 한다.\n철수는 집에서 만든 자동 로봇팔을 선생님의 책상에 숨겨, 선생님이 수업을 시작하려 들어온 순간 숨겨놓은 로봇팔을 이용해 선생님을 혼내주려고한다. 철수는 선생님이 늘 애용하는 물컵에 시간이 되면 로봇팔이 소금을 잔뜩 집어넣도록 프로그램을 짜려고한다.\n철수는 현재시각과 선생님이 언제 컵을 사용할지 시간을 알고있지만, 수 계산에 정말 약해서 로봇팔에 입력해야할 시간 계산을 못한다. 철수가 로봇팔에 알맞은 시간을 입력할수 있도록 도와주자.\n",
        "input_text": "첫째 줄에는 현재 시각이 hh:mm:ss로 주어진다. 시간의 경우 0≤h≤23 이며, 분과 초는 각각 0≤m≤59, 0≤s≤59 이다.\n두 번째 줄에는 소금 투하의 시간이 hh:mm:ss로 주어진다.\n",
        "output_text": "로봇팔이 소금을 투하할때까지 필요한 시간을 hh:mm:ss로 출력한다. 이 시간은 1초보다 크거나 같고, 24시간보다 작거나 같다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 587.0,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "28": {
        "problem_text": "어느 날, 민주는 꿈에서 악마를 만나게 되었다. 악마는 자신에게 K원을 지불하면, 지불하고 남은 금액을 N배로 만들어준다고 한다.\n민주는 자신이 최소 몇 원을 가지고 있어야 악마에게 K원을 지불했을 때 손해를 보지 않는지 알고 싶다.\n악마가 제안한 K와 N이 주어졌을 때, 민주가 손해 보지 않기 위해 가지고 있어야 하는 최소 금액 X를 구해주자. 단, 금액은 정수여야 한다.\n",
        "input_text": "첫째 줄에 악마가 제안한 정수 K와 N이 공백을 사이에 두고 주어진다. (1 ≤ K, N ≤ 200,000,000)\n",
        "output_text": "민주가 손해 보지 않기 위해 가지고 있어야 하는 최소 금액 X를 출력한다.\n항상 민주가 손해를 보게 된다면 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 290.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "29": {
        "problem_text": "이 문제는 $x_0$와 $N$의 제한을 제외하고 특별한 큰 분수와 같은 문제이다.\nNLCS에는 분수가 많다.\n분수에서 나오는 물의 높이는 특정한 규칙에 따라 변화하는데, 어떤 정수 시각 $t$에서의 분수의 높이가 정수 $x_t$일 때, $x_{t+1}$는 $x_t$가 짝수라면 $\\lfloor \\frac{x_t}{2} \\rfloor \\oplus 6$, $x_t$가 홀수라면 $(2 \\cdot x_t) \\oplus 6$과 같다.\n$0$초에서의 분수의 높이가 주어졌을 때, $N$초에서의 분수의 높이를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 $0$초에서의 분수의 높이 $x_0$와 $N$이 주어진다. $x_0$와 $N$은 모두 정수이다.\n",
        "output_text": "첫 번째 줄에 $N$초에서의 분수의 높이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 296.5,
        "label": [
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "30": {
        "problem_text": "N 명의 학생들이 앞뒤로 일렬로 서 있다. 각 학생은 1부터 N까지 서로 다른 번호가 적힌 카드들 중 하나를 가지고 있다. 학생들에게서 자신보다 뒤에 서있으면서 더 작은 번호의 카드를 가진 학생들의 명단을 하나도 빠짐없이 모두 받았다. 이 명단을 통해 학생들이 가지고 있는 카드의 번호를 알아내려고 한다.\n예를 들어, 일렬로 서 있는 5명의 학생들을 앞에서부터 순서대로 “학생1, 학생2, 학생3, 학생4, 학생5”라고 하고, 학생들에게 받은 명단을 통해 다음과 같이 5개의 순서쌍이 만들어졌다고 하자. 순서쌍 (X,Y)는 학생Y 가 학생X 보다 뒤에 있으면서 더 작은 번호를 가지고 있다는 것을 의미한다.\n(1,2), (1,5), (3,4), (3,5), (4,5)\n이 자료를 분석하면 학생1, 학생2, 학생3, 학생4, 학생5는 각각 3, 1, 5, 4, 2가 적힌 카드를 가지고 있음을 알 수 있다.\n다른 예로 5명 학생들에게 받은 명단으로 다음과 같은 6개의 순서쌍이 만들어 졌다고 하자.\n(1,2), (1,3), (1,5), (2,5), (3,4), (3,5)\n이 경우, 학생들이 잘못된 명단을 제시한 것이다. 순서쌍 (2,5)에 의하면 학생2는 학생5보다 큰 번호의 카드를 가지고 있다. 그런데 만일 학생4의 카드가 학생5의 카드보다 작은 번호라면 순서쌍 (2,4)가 존재해야 하고, 반대로 학생4의 카드가 학생5의 카드보다 큰 번호라면 순서쌍 (4,5)가 존재해야 한다. 그런데 둘 다 존재하지 않기 때문에 학생들이 잘못된 명단을 제시한 것이다.\n학생들로부터 받은 명단으로 만들어진 순서쌍을 입력으로 받아, 학생들이 가지고 있는 카드 번호를 알아내는 프로그램을 작성하라.\n",
        "input_text": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 학생 수 N (1 ≤ N ≤ 100,000)과 순서쌍의 수 M (0 ≤ M ≤ 1,000,000)이 공백으로 분리되어 주어진다. 일렬로 서 있는 학생들을 순서대로 학생1, 학생2, ... , 학생N 이라고 하자. 다음 M개의 각 줄에는 두 개의 자연수 X와 Y가 공백으로 분리되어 주어진다. 이것은 학생Y가 학생X 보다 더 작은 번호가 적힌 카드를 가지고 있다는 것을 의미하는 순서쌍이다 (1 ≤ X < Y ≤ N). 입력에 중복된 순서쌍은 없다.\n",
        "output_text": "표준 출력으로, 주어진 순서쌍을 통해 학생들이 가지고 있는 카드 번호를 알 수 있으면 학생들이 서 있는 순서대로 카드번호를 공백으로 분리하여 출력한다. 그렇지 않으면 -1을 출력한다.\n",
        "memory_median": 2804.0,
        "time_median": 292.0,
        "length_median": 628.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "31": {
        "problem_text": "무엇이든 덮어버리는 것을 좋아하는 지은이는 한변의 길이가 A인 정삼각형을 한변의 길이가 B인 정삼각형으로 완전히 덮어 버리고자 한다. \n두개의 정수 A, B 가 주어지고, B ≤ A 이고, A를 B로 나눌수 있을때, 한 변의 길이가 A인 정삼각형을 완전하게 덮기 위한, 한변의 길이가 B인 정삼각형의 개수를 구하라.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. (T ≤ 1000)\n각각의 테스트 케이스는 한줄로 이루어져 있으며 두개의 정수 A, B 가 (1 ≤ B ≤ A ≤ 1,000,000, B|A) 주어진다.\n",
        "output_text": "각 테스트 케이스마다 한변의 길이가 A인 정삼각형을 완벽하게 덮을 수 있는 한변의 길이가 B인 정삼각형의 최소 개수를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 243.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "32": {
        "problem_text": "행복이는 길이가 $N$인 수열 $A$에서 소수들을 골라 최소공배수를 구해보려고 한다.\n행복이를 도와 이를 계산해주자.\n",
        "input_text": "첫째 줄에 수열 $A$의 길이 $N$이 주어진다. $(1 \\le N \\le 10,000)$\n그 다음줄에는 수열 $A$의 원소 $A_{i}$가 공백으로 구분되어 주어진다. $(2 \\le A_{i} \\le 1,000,000)$\n답이 263 미만인 입력만 주어진다.\n",
        "output_text": "첫째 줄에 소수들의 최소공배수를 출력한다.\n만약 소수가 없는 경우는 -1을 출력한다.\n",
        "memory_median": 3000.0,
        "time_median": 8.0,
        "length_median": 732.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "33": {
        "problem_text": "남서네 집 앞 편의점에는 각각 S, N, U의 이름이 붙은 총 3가지의 과자를 판다. 진열대에는 한 봉지당 가격과 무게가 안내되어 있다. 같은 종류의 과자끼리는 봉지의 무게가 똑같다.\n남서는 오늘 과자를 10봉지 사려고 한다. 편의점의 단골인 남서는 할인 쿠폰 하나를 가지고 있는데, 총 구매 금액이 5,000원 이상일 때 500원을 깎아 주는 쿠폰이다. 구매 금액이 5,000원 미만인 경우에는 할인 쿠폰을 쓸 수 없다. 또한 할인을 여러 번 적용할 수는 없다.\n남서는 과자를 고를 때 가성비를 중요하게 생각한다. 남서가 생각하는 가성비란, 총 무게를 총 금액으로 나눈 값이다. 남서는 빨리 과자가 먹고 싶기 때문에, 한 종류의 과자만을 10봉지 골라 사 가려고 한다. 또, 다른 물건은 구매하지 않을 생각이다.\n가성비를 다시 한 번 수학적으로 표현하면 다음과 같다.\n가성비 = 과자 10봉지의 무게의 합 / 쿠폰 사용을 고려했을 때 과자 10봉지를 사는 데 필요한 돈\n진열대를 들여다 보던 남서는 신기하게도 세 과자의 가성비가 모두 서로 다르다는 사실을 깨달았다.\n남서는 어떤 과자를 사게 될까?\n",
        "input_text": "입력은 총 3개의 줄로 이루어지며, 각 줄에는 S, N, U의 순서대로 한 봉지의 가격과 무게가 띄어쓰기를 사이에 두고 주어진다.\n모든 입력값은 1 이상 1,000 이하의 정수이다.\n세 종류의 과자의 가성비가 서로 다름이 보장된다.\n",
        "output_text": "첫 번째 줄에 가장 가성비가 높은 과자의 이름(S 또는 N 또는 U)을 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 534.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "34": {
        "problem_text": "유명한 피타고라스의 정리와 유사한 형태의 피타고라스 기댓값 (Pythagorean Expectation)이 야구와 같은 스포츠 경기에 자주 사용된다. 피타고라스 기댓값은 빌 제임스(Bill James)에 의해 정의되었으며, 이 값은 특정 야구팀이 한 시즌 동안 얼마나 잘 했는지를 평가하는 지표 중 하나로 사용된다. 한 야구팀의 피타고라스 기댓값 \\(W\\)는 아래 식과 같이 정의된다.\n\\(W = \\dfrac{S^2}{S^2 + A^2}\\),\n여기서 \\(S\\)는 해당 팀의 총 득점 수를, \\(A\\)는 해당 팀의 총 실점 수를 나타낸다.\n이 기댓값을 실제 승률과 비교하여, 해당 팀이 한 시즌을 얼마나 잘 보냈는지 평가할 수 있다. 예를 들어, 한화 이글스는 2014 시즌에 619 득점과 889 실점을 했다. 즉, \\(S\\) = 619, \\(A\\) = 889이 되어, 한화 팀의 피타고라스 기댓값은 \\(W\\) = 6192/(6192 + 8892) = 0.326이 된다. KBO 규정에 따르면, 한 시즌당 한 팀은 128번의 경기를 해야 하므로, 한화는 0.326 ×128 = 41.728 경기에서는 승리했어야 한다. 실제 한화는 49경기에서 승리했기 때문에, 2014 시즌을 그리 나쁘지 않게 보냈음을 알 수 있다. 반면에 롯데 자이언츠는 \\(S\\) = 715이고, \\(A\\) = 719이 되어, \\(W\\) = 0.497이 된다. 따라서 0.497 ×128 = 63.616경기 이상을 이길 것으로 기대되었지만, 실제론 58경기만 승리했다. 결국, 롯데에게 2014년은 기대에 많이 못 미친 시즌이었음을 알 수 있다.\n\\(n\\)개의 팀에 대한 기록이 주어지면, 이 기록으로부터 팀 별 피타고라스 기댓값을 계산한 후, 그 중 최대 기댓값과 최소 기댓값을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫 줄에는 두 양의 정수 \\(n\\) (2 ≤ \\(n\\) ≤ 1,000)과 \\(m\\) (2 ≤ \\(m\\) ≤ 1,000)이 주어진다. 여기서, \\(n\\)은 팀 개수이며, \\(m\\)은 전체 경기 수이다. 다음의 \\(m\\)개의 줄에는 각 경기에 대한 정보가 주어진다. 하나의 경기는 네 개의 정수 \\(a\\), \\(b\\), \\(p\\), \\(q\\)로 주어지는데, 팀 a와 팀 b가 경기를 했고, 팀 a는 p득점을 팀 b는 q득점을 했다는 의미이다. 여기서, 1 ≤ \\(a\\) ≠ \\(b\\) ≤ \\(n\\)이며, \\(p\\)와 \\(q\\)는 모두 음이 아닌 20 이하의 정수이다. 하나의 테스트 데이터에서 팀 당 경기수가 반드시 같을 필요는 없다. 만약, 어떤 팀의 총 득점과 총 실점이 모두 0이라면, 그 팀의 기댓값은 0으로 정의한다.\n",
        "output_text": "출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 두 정수 값을 한 줄에 하나씩 출력해야 한다. 첫 번째 줄에는 최대 피타고라스 기댓값에 1,000을 곱한 값의 정수부분을 출력하고, 두 번째 줄에는 최소 피타고라스 기댓값에 1,000을 곱한 값의 정수부분을 출력한다.\n",
        "memory_median": 1660.0,
        "time_median": 12.0,
        "length_median": 895.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "35": {
        "problem_text": "사칙연산에서 곱셈과 나눗셈은 덧셈과 뺄셈보다 먼저 계산한다. 덧셈과 뺄셈을 먼저 계산하고 싶을 때는 보통 가장 큰 연산 우선순위를 가지는 괄호를 사용하여 연산 순서를 지정한다. 예를 들어, 아래의 식은 연산 순서에 따라 두 가지 다른 결과가 나올 수 있다.\n\n(2 + 3) × 4 = 20\n2 + (3 × 4) = 14\n\n연산 우선순위가 같은 곱셈과 나눗셈 또는 덧셈과 뺄셈만 있는 식에서는 보통 왼쪽에서 오른쪽 순서로 연산을 한다. 하지만 이런 상황에도 연산 순서에 따라 아래와 같이 두 가지 다른 결과가 나올 수 있다.\n\n(6 ÷ 2) × 3 = 9\n6 ÷ (2 × 3) = 1\n\n만약 곱셈, 나눗셈, 덧셈, 뺄셈의 4가지 연산자의 연산 우선순위가 동등하다고 할 때, 괄호 없는 식에서 서로 다른 연산 순서의 계산 결과를 구하여라.\n",
        "input_text": "첫 번째 줄에는 \"K1 O1 K2 O2 K3\" 형태로 식이 주어진다. 정수 Ki (1 ≤ Ki ≤ 1,000)는 피연산자를, 문자열 Oi는 곱셈(*), 나눗셈(/), 덧셈(+), 뺄셈(-) 중 한 가지 연산자를 의미한다.\n나눗셈 연산은 정수 나눗셈으로 몫만 취하며, 피연산자 중 하나가 음수이면 양수로 바꿔 계산한 결괏값에 음수를 취한다. 또한, 계산 과정에서 0으로 나누어야 하는 식은 주어지지 않는다.\n",
        "output_text": "주어진 식에서 서로 다른 연산 순서의 계산 결과가 작은 것을 첫 번째 줄에, 큰 것을 두 번째 줄에 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 644.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "36": {
        "problem_text": "구사과는 지폐를 오직 두 종류만 가지고 있다. 바로 P원 지폐와 Q원 지폐이다. 이 두 종류의 지폐를 구사과는 무한대만큼 가지고 있다.\n오늘 구사과가 구매하려고 하는 물건의 가격은 D원이다. 구사과가 이 물건을 구매하기 위해서 지불해야 하는 금액의 최솟값은 얼마일까?\n물건을 구매하기 위해서는 물건의 가격보다 크거나 같은 금액을 지불해야 한다.\n",
        "input_text": "첫째 줄에 D, P, Q가 주어진다. 모두 109보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 물건을 구매하기 위해 구사과가 지불해야 하는 금액의 최솟값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 614.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "37": {
        "problem_text": "농부 존은 소들에게 소수로 차례차례 번호를 매기는 중이다. 베시는 이 번호에서 숫자 D가 몇 번이나 등장하는지 궁금해졌다.\n베시를 도와 범위 A..B(A와 B 포함)내에서 숫자 D를 포함하는 소수의 개수를 구해보자.\n소수는 두개의 자연수(1과 자기자신)로만 나누어 떨어지는 자연수를 말한다. 소수의 예로는 2,3,5,7,11,13,17,19,23,29.. 가 있다.\n",
        "input_text": "세 정수 A, B, D가 주어진다.\n",
        "output_text": "주어진 범위 내에서 숫자 D를 포함하는 소수의 개수를 출력한다.\n",
        "memory_median": 5904.0,
        "time_median": 44.0,
        "length_median": 644.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "38": {
        "problem_text": "상근이와 지수는 마트에서 오렌지 주스, 사과 주스, 파인애플 주스를 구매했다. 그들은 인터넷에서 찾은 방법으로 무알콜 칵테일을 만들어 학교에서 팔려고 한다. 하지만, 칵테일을 만드는 방법을 찾기 전에 주스를 구매했기 때문에, 주스가 남을 수도 있다.\n무알콜 칵테일을 만드는데 필요한 오렌지, 사과, 파인애플 주스의 비율과 구매한 주스의 양이 주어진다. 칵테일을 최대한 많이 만들었을 때, 각 주스가 얼만큼 남는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 구매한 오렌지, 사과, 파인애플 주스의 양 A, B, C가 주어진다. (1 ≤ A, B, C ≤ 500)\n둘째 줄에 칵테일을 만드는데 필요한 각 주스의 비율 I, J, K가 주어진다. (1 ≤ I, J, K ≤ 50)\n",
        "output_text": "첫째 줄에 칵테일을 최대한 많이 만들었을 때, 각 주스가 얼만큼 남는지를 공백으로 구분하여 출력한다. 정답과의 오차는 10-4까지 허용한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 408.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "39": {
        "problem_text": "Given the coordinates (x,y) of some points in 2-dimensional plane, find out which quadrant(Q1-Q4) the points are located. If a point is located on X-axis or Y-axis, print out AXIS instead.\n\n",
        "input_text": "Each line contains a pair of real numbers which is the coordinate of a point. Input is terminated by 0 0.\n",
        "output_text": "Print out in each line Q1, Q2, Q3, Q4 or AXIS for each point.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 487.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "40": {
        "problem_text": "건축학개론을 수강한 욱제는 선린의 매점 앞에 지어질 새로운 건물의 설계를 맡았다. 욱제는 건축학개론 수업에서 수지를 만나 행복하지만, C-를 받을 정도로 건축에 소질이 없다.\n컴퓨터학부에 재학중인 욱제는 이 건물의 설계도를 그림이 아니라 선분과 선분이 만나는 꼭짓점들의 좌표로 관리하고 있다고 한다. 이 설계도는 건물의 바닥 부분만을 나타낸 밑면도(저면도)이다. 하지만 프로그래밍 역시 C-인 욱제는 자신이 설계한 건물의 둘레를 구할 방도를 찾지 못해 발을 동동 구르고 있다.\n욱제가 설계한 건물은 어느 방향에서 보아도 가운데가 파인 부분이 없는 직각으로 볼록한 닫힌 곡선 모양이다. 단순한 타원을 디지털화 한 모양이라고 이야기 할 수 있겠다. 욱제의 설계도는 2차원 좌표평면 위의 격자에 꼭 맞게 표현된다. (이런 모양을 영어로는 orthogonally convex rectilinear polygon이라고 한다)\n욱제는 당신에게 밑면도의 모든 꼭짓점의 좌표들을 넘겨주며 도움을 요청하였다. 설계도는 욱제가 넘겨주는 좌표 순서대로 i번째 좌표와 i+1번째 좌표를 잇는 선분을 그려 복원할 수 있다고 한다. N번째 좌표는 1번째 좌표와 이어지며 선분은 항상 격자에 맞게 주어진다.\n욱제를 대신해 이 건물의 둘레를 구하고 건축학개론의 주인공 자리를 빼앗자!\n",
        "input_text": "첫째 줄에 꼭짓점의 개수 N이 주어진다. (4 ≤ N ≤ 20)\n이후 둘째 줄 부터 N개의 줄에 걸쳐 꼭짓점의 좌표 (x, y)가 주어진다. 좌표는 40 이하의 음이 아닌 정수이며, 중복되는 좌표는 주어지지 않는다.\n",
        "output_text": "욱제가 설계한 건물의 둘레의 길이를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 456.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "41": {
        "problem_text": "In CS City, a mathematical place to live, the mayor is elected every 4 years, the treasurer is appointed every 2 years, the chief programmer is elected every 3 years and the dog-catcher is replaced every 5 years.\nThis year, Year $X$, the newly elected mayor announced the appointment of the new treasurer, a new dog-catcher and congratulated the chief programmer for winning the recent election. That is, all positions were changed over. This is highly unusual. You will quantify how unusual this really is.\nWrite a program that inputs the year $X$ and the future year $Y$ and lists all years between $X$ and $Y$ inclusive when all positions change.\n",
        "input_text": "",
        "output_text": "",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 243.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "42": {
        "problem_text": "성우는 숲에서 레몬을 따와야 한다. 숲은 하나의 수직선으로 표현할 수 있고, 여기에는 레몬 나무 \\(N\\)그루가 \\(x=1\\)부터 \\(x=N\\)까지 일정한 간격으로 자라 있다. 성우는 현재 \\(x=0\\)에 있으며, 집은 \\(x=N+1\\)에 있다. \\(x=i\\)에 위치한 나무에는 \\(a_i\\)개의 레몬이 자라 있다. 성우는 집에 돌아갈 때까지 매번 다음 중 하나를 선택하여 행동한다.\n\n채집: 나무에 자라있는 레몬을 모두 딴다. 이 행동은 최대 한 번 할 수 있다.\n이동: 현재 위치가 \\(x=i\\)라면, \\(x=i+1\\)로 이동한다.\n\n하지만 레몬을 담을 보따리에는 구멍이 뚫려 있었다. 성우가 이동(행동 2)할 때마다, 보따리에 레몬이 담겨 있다면 보따리에 담긴 레몬이 \\(1\\)개 빠져나오고, 이는 다시 주울 수 없다. 성우가 집에 들고 갈 수 있는 레몬의 최대 개수를 구해주자!\n",
        "input_text": "첫째 줄에 나무의 수 \\(N\\)이 주어진다. \\((1 \\leq N \\leq 2 \\times 10^5)\\)\n둘째 줄에는 \\(x=i\\)에 위치한 나무에 자라 있는 레몬의 개수 \\(a_i\\)가 차례대로 주어진다. \\((1 \\leq a_i \\leq 10^9)\\)\n",
        "output_text": "성우가 집에 들고 갈 수 있는 레몬의 최대 개수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 28.0,
        "length_median": 310.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "43": {
        "problem_text": "어느 날, 트리를 물끄러미 보고 있던 동현이는 엄청난 사실을 하나 발견했다. 바로 정점이 네 개인 트리는 ‘ㄷ’과 ‘ㅈ’의 두 종류밖에 없다는 사실이다!\n\n정점이 네 개 이상 있는 임의의 트리에 대해, 그 트리에서 정점 네 개로 이루어진 집합을 고르자. 전체 트리의 간선들 중 집합에 속한 두 정점을 잇는 간선만을 남겼을 때, 네 개의 정점이 하나의 트리 형태로 이어지게 된다면 ‘ㄷ’ 모양이거나 ‘ㅈ’ 모양일 것이다. 트리에서 ‘ㄷ’의 개수와 ‘ㅈ’의 개수를 각각 트리에서 ‘ㄷ’ 모양, ‘ㅈ’ 모양을 이루는 정점 네 개짜리 집합의 개수라고 하자.\n이제, 동현이는 세상의 모든 트리를 다음과 같은 세 종류로 나누었다.\n\nD-트리 : ‘ㄷ’이 ‘ㅈ’의 $3$배보다 많은 트리\nG-트리 : ‘ㄷ’이 ‘ㅈ’의 $3$배보다 적은 트리\nDUDUDUNGA-트리 : ‘ㄷ’이 ‘ㅈ’의 정확히 $3$배만큼 있는 트리\n\n신이 난 동현이는 트리만 보이면 그 트리에 있는 ‘ㄷ’과 ‘ㅈ’이 몇 개인지 세고 다니기 시작했다. 하지만 곧 정점이 $30$만 개나 있는 트리가 동현이 앞에 나타났고, 동현이는 그만 정신을 잃고 말았다. 동현이를 대신해 주어진 트리가 D-트리인지 G-트리인지 아니면 DUDUDUNGA-트리인지 알려주자!\n",
        "input_text": "첫 번째 줄에 트리의 정점 수 $N$이 주어진다. ($4 \\leq N \\leq 300\\ 000$)\n두 번째 줄부터 $N-1$개의 줄에 트리의 각 간선이 잇는 두 정점의 번호 $u$, $v$가 주어진다. ($1 \\leq u, v \\leq N$)\n",
        "output_text": "첫 번째 줄에 주어진 트리가 D-트리라면 D, G-트리라면 G, DUDUDUNGA-트리라면 DUDUDUNGA를 출력한다.\n",
        "memory_median": 24556.0,
        "time_median": 220.0,
        "length_median": 958.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "44": {
        "problem_text": "피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.\n이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.\nn=17일때 까지 피보나치 수를 써보면 다음과 같다.\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597\nn이 주어졌을 때, 0번째 피보나치 수부터 n번째 피보나치 수 중에서 짝수번째 피보나치 수의 합을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 0번째 피보나치 수부터 n번째 피보나치 수 중에서 짝수번째 피보나치 수의 합을 1,000,000,007으로 나눈 나머지를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 985.5,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "45": {
        "problem_text": "The teacher has sent an e-mail to her students with the following task:\n\"Write a programme that will determine and output the value of \\(X\\) if given the statement:\n\\[X = number_1^{pot_1} + number_2^{pot_2} + \\dots + number_N^{pot_N}\\]\nand it holds that \\(number_1\\), \\(number_2\\) to \\(number_N\\) are integers, and \\(pot_1\\), \\(pot_2\\) to \\(pot_N\\) one-digit integers.\" Unfortunately, when the teacher downloaded the task to her computer, the text formatting was lost so the task transformed into a sum of \\(N\\) integers:\n\\[X = P_1 + P_2 + ... + P_N\\]\nFor example, without text formatting, the original task in the form of \\(X = 21^2 + 125^3\\) became a task in the form of \\(X = 212 + 1253\\). Help the teacher by writing a programme that will, for given \\(N\\) integers from \\(P_1\\) to \\(P_N\\) determine and output the value of \\(X\\) from the original task.\nPlease note: We know that it holds a \\(N = a \\cdot a \\cdot \\dots \\cdot a\\) (\\(N\\) times).\n",
        "input_text": "The first line of input contains the integer \\(N\\) (1 ≤ \\(N\\) ≤ 10), the number of the addends from the task. Each of the following \\(N\\) lines contains the integer \\(P_i\\) (10 ≤ \\(P_i\\) ≤ 9999, \\(i\\) = 1 ... \\(N\\)) from the task.\n",
        "output_text": "The first and only line of output must contain the value of \\(X\\) (\\(X\\) ≤ 1 000 000 000) from the original task.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 318.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "46": {
        "problem_text": "환상의 나라 디디랜드에서는 인연의 증표로 끈을 하나씩 가지고 있다. 그들은 지극히 평범한 방법으로 이 끈을 이용하여 어떤 두 사람이 환상의 짝꿍인지 판단하는데, 두 사람의 끈을 서로 이어붙이고 그 끈을 다시 길이가 소수인 끈 두개로 정확히 나눌 수 있다면 두 사람은 환상의 짝꿍이라고 한다. 하지만 그들은 길이가 소수인 두개의 끈으로 나눌 수 있는지 판단하는 것이 어려워서 대부분 서로가 인연임을 모르고 그냥 지나간다고 한다. 애석하게도...\n그런 그들을 위해서 어떤 두 사람이 환상의 짝꿍인지 판단하는 프로그램을 작성하라.\n편의상 두 사람의 끈을 이어붙일 때와 나눌 때 손실되는 끈의 길이는 0이라고 가정한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 500)가 주어진다.\n둘째 줄부터 T개 줄에 두 사람이 가지고 있는 끈의 길이를 나타내는 정수 A, B가 공백으로 구분되어 주어진다. (1 ≤ A, B ≤ 2 × 1012)\n",
        "output_text": "각 테스트 케이스마다 한 줄씩 두 사람의 끈을 이어붙이고 그 끈을 다시 길이가 소수인 두개의 끈으로 정확히 나눌 수 있다면 YES, 불가능하면 NO를 출력하라.\n",
        "memory_median": 5636.0,
        "time_median": 732.0,
        "length_median": 1021.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "47": {
        "problem_text": "경북대학교의 마스코트이자 따봉 요정인 호반우는 오늘도 수업을 듣기 위해 경북대학교 정문을 지나치던 도중 정체불명의 차원문에 휘말려 이세계로 오게 되었다.\n이세계의 신인 당신이 호반우가 마왕을 물리치고 지구로 돌아가 학교에 지각하지 않도록 도와주자!\n호반우의 현재 스탯인 힘($STR$), 민첩($DEX$), 지능($INT$), 운($LUK$)에 해당하는 $4$가지 수가 주어진다.\n$4$가지 스탯 중 하나의 수치를 $1$씩 올릴 수 있는 축복을 여러 번 사용해 호반우의 평균 스탯 수치를 $N$ 이상으로 만들려고 할 때 최소 몇 번의 축복을 사용해야 하는지 구해보자.\n",
        "input_text": "첫 번째 줄에 $STR,\\,DEX,\\,INT,\\,LUK$과 $N$이 공백을 두고 주어진다. $(1 \\le STR,\\,DEX,\\,INT,\\,LUK,\\,N \\le 100)$\n입력되는 모든 수는 양의 정수이다.\n",
        "output_text": "호반우의 평균 스탯 수치를 $N$ 이상으로 만들기 위해 사용해야 할 축복의 최소 횟수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 279.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "48": {
        "problem_text": "창용이는 여름을 맞이하여 ‘정창용’ 이름이 쓰인 한정판 섬머 에디션 시계를 구입했다. 왠지 오늘은 001도 가고 싶지 않고 시계를 가지고 놀고만 싶다. 우린 방에 있는 창용이가 시계를 가지고 뭘 하는지 궁금하기만 하다. 창용이는 시계의 건전지를 분리했기 때문에 시계는 시간이 흐르지 않는다.\n창용이는 앞으로 시계를 돌리기도 하고 뒤로 시계를 돌리기도 한다. 입력으로는 초기 현재 시간이 주어지고 q개의 쿼리가 주어진다.\n한 쿼리는 T로 시작한다. (1 ≤ T ≤ 3, 0 ≤ c ≤ 10,000,000)\n\nT가 1일 때는 c를 입력으로 받아와서, 시계를 앞으로 c초 돌린다.\nT가 2일 때는 c를 입력으로 받아와서, 시계를 뒤로 c초 돌린다.\nT가 3일 때는 창용이가 조작한 시계의 상황을 출력한다.\n\n",
        "input_text": "현재 시간이 h m s 로 주어진다. (0 ≤ h ≤ 23, 0 ≤ m ≤ 59, 0 ≤ s ≤ 59)\n그 다음 쿼리의 개수 q가 주어진다. (1 ≤ q ≤ 100,000)\n다음 q개의 줄에는 쿼리가 주어진다. 쿼리의 형태는 위와 같다.\n",
        "output_text": "쿼리의 T가 3 일때, 창용이가 이리 저리 바꿔 놓은 시계가 가리키는 시간을\nh’ m’ s’ 의 형태로 출력한다. T가 3인 쿼리는 하나는 꼭 주어진다.\n",
        "memory_median": 1988.0,
        "time_median": 28.0,
        "length_median": 652.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "49": {
        "problem_text": "VE OCH FASA! PostNord har för det $1337$:e året i rad höjt portot, vilket riskerar att bräcka Programmeringsolympiadens budget.\nVarje år skickar PO ut affischer till ca $450$ gymnasieskolor. Ett utskick består av tre saker: \n\nett kuvert av C4-storlek ($229\\text{ mm} \\times 324\\text{ mm}$)\ntvå affischer av A3-storlek ($297\\text{ mm} \\times 420\\text{ mm}$)\nett informationsblad av A4-storlek ($210\\text{ mm} \\times 297\\text{ mm}$)\n\nDet är mycket viktigt att brevet väger högst $50$ gram, eftersom portot annars blir dubbelt så högt. För att klara denna magiska viktgräns kan PO styra över vilken sorts papper som används för de tre sakerna. Varje sort har en ytvikt (vikt per area) som typiskt anges i $\\frac{\\text{gram}}{\\text{m}^2}$. Notera att kuvertet består av två sammanklistrade ark av C4-storlek, medan ytvikter och ovanstående mått gäller för ett ark.\nSkriv ett program som räknar ut den totala vikten för ett brev.\n",
        "input_text": "Indatan består av tre heltal mellan $50$ och $200$, ytvikterna i $\\frac{\\text{gram}}{\\text{m}^2}$ för sorterna som används till kuvertet, affischerna respektive informationsbladet.\n",
        "output_text": "Skriv ut ett enda decimaltal: vikten på ett fullständigt brevutskick i gram. Svaret ska anges med minst $3$ decimalers noggrannhet (d.v.s. vara inom $5 \\cdot 10^{-4}$ från rätt svar).\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 276.0,
        "label": [
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "50": {
        "problem_text": "서준이는 아빠로부터 골뱅이가 들어 있는 상자를 생일 선물로 받았다. 상자 안에는 반시계 방향으로 90도 돌아간 ㅍ자 모양의 골뱅이가 들어있다. 돌아간 ㅍ자 모양은 가로 및 세로로 각각 5개의 셀로 구성되어 있다. 상자에는 정사각형 모양의 셀의 크기를 나타내는 숫자 하나가 적혀있다. 셀의 크기 N이 주어지면 예제 출력과 같은 방식으로 골뱅이 모양을 출력하시오.\n",
        "input_text": "첫째 줄에 정수 N(1 ≤ N ≤ 100)이 주어진다.\n",
        "output_text": "셀의 크기가 N인 골뱅이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 790.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "51": {
        "problem_text": "크로스 컨트리 달리기는 주자들이 자연적인 야외의 지형에 만들어진 코스를 달리는 운동 경기이다. 경주 코스는 일반적으로 4에서 12 킬로미터이며, 숲이나 넓은 땅을 통과하는 풀과 흙으로 된 지면과 언덕과 평평한 지형을 포함한다. 이 경기는 주자들의 개인성적을 매기고, 이를 가지고 팀의 점수를 계산한다. \n한 팀은 여섯 명의 선수로 구성되며, 팀 점수는 상위 네 명의 주자의 점수를 합하여 계산한다. 점수는 자격을 갖춘 팀의 주자들에게만 주어지며, 결승점을 통과한 순서대로 점수를 받는다. 이 점수를 더하여 가장 낮은 점수를 얻는 팀이 우승을 하게 된다. 여섯 명의 주자가 참가하지 못한 팀은 점수 계산에서 제외된다. 동점의 경우에는 다섯 번째 주자가 가장 빨리 들어온 팀이 우승하게 된다.\n예를 들어, 다음의 표를 살펴보자.\n\n\n\n등수\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n팀\nA\nB\nC\nC\nA\nC\nB\nD\nA\nA\nC\nA\nC\nC\nA\n\n\n점수\n1\nn/a\n2\n3\n4\n5\nn/a\nn/a\n6\n7\n8\n9\n10\n11\n12\n\n\n\n팀 B 와 D 는 선수의 수가 여섯이 아니므로, 점수를 받을 수 없다. 팀 A 의 점수는 18 (1+4+6+7)이고, 팀 C 의 점수는 18 (2+3+5+8)이다. 이 경우 두 팀의 점수가 같으므로 다섯 번째로 결승점을 통과한 선수를 고려한다, A 팀의 다섯 번째 선수의 점수가 C 팀의 다섯 번째 선수의 점수보다 적으므로 A 팀이 우승팀이 된다.\n모든 선수들의 등수가 주어질 때, 우승팀을 구하는 프로그램을 작성하라. 각 팀의 참가 선수가 여섯보다 작으면 그 팀은 점수 계산에서 제외됨을 주의하라. 여섯 명 보다 많은 선수가 참가하는 팀은 없고, 적어도 한 팀은 참가 선수가 여섯이며, 모든 선수는 끝까지 완주를 한다고 가정한다.\n",
        "input_text": "입력 데이터는 표준입력을 사용한다. 입력은 T 개의 테스트 케이스로 주어진다. 입력 파일의 첫 번째 줄에 테스트 케이스의 수를 나타내는 정수 T 가 주어진다. 두 번째 줄부터는 두 줄에 하나의 테스트 케이스에 해당하는 데이터가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 하나의 정수 N (6 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 팀 번호를 나타내는 N 개의 정수 t1, t2, …, tN 이 공백을 사이에 두고 주어진다. 각 팀은 1 과 M(1 ≤ M ≤ 200)사이의 정수로 표현된다.\n",
        "output_text": "출력은 표준출력을 사용한다. 하나의 테스트 케이스에 대한 우승팀의 번호를 한 줄에 출력한다. \n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1451.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "52": {
        "problem_text": "민성이와 태경이는 고려대학교에서 알아주는 가위바위보의 최고수들이다. 이들은 기존의 가위바위보에 질린 나머지, 2개의 손을 모두 이용하여 가위바위보를 즐기는 경지에 이르렀다.\n먼저, 둘이 동시에 “가위, 바위, 보”를 외치며 두 개의 손을 각각 가위, 바위, 보 중 하나로 설정하여 공개한다. 그 자리에서 서로 3초간 호흡을 가다듬은 후, 동시에 왼손을 낼지 오른손을 낼지를 결정한다. 민성이와 태경이는 최고수들끼리의 대결이라는 압박감에 의해 가끔 판단력이 흐려질 때가 있어서, 실수로 왼손과 오른손에 같은 동작을 취할 수도 있다.\n당신은 민성이와 태경이의 왼손과 오른손의 상태가 주어졌을 때, 민성이 또는 태경이가 적절히 왼손 또는 오른손을 선택하여 가위바위보에서 무조건 이기는 방법이 있는지 없는지를 알려고 한다.\n",
        "input_text": "첫 번째 줄에 차례로 ML, MR, TL, TR이 공백으로 구분되어 주어진다. 차례대로 민성이의 왼손과 오른손, 태경이의 왼손과 오른손의 상태를 나타낸다.\n위 4개의 값들은 “S”, “R”, “P” 중 하나이며, 각각 가위, 바위, 보를 의미한다.\n",
        "output_text": "첫 번째 줄에 민성이가 무조건 이길 수 있다면 “MS”, 태경이가 무조건 이길 수 있다면 “TK”, 누가 이길 지 확답할 수 없다면 “?”를 쌍따옴표를 제외하고 출력한다.\n가위바위보에서 가위는 보를 이기고, 바위는 가위를 이기며, 보는 바위를 이긴다. 같은 손동작끼리는 승부가 나지 않는다 (비긴다).\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 904.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "53": {
        "problem_text": "메이플스토리라는 RPG 게임에는 레벨이 존재한다.\n각각 만렙 = $300$, 구만렙 = $275$, 뀨만렙 = $250$이라는 용어가 존재한다.\n모든 레벨은 만렙(구간 1), 구만렙이상 만렙 미만(구간 2), 뀨만렙이상 구만렙 미만(구간 3), 뀨만렙 미만(구간 4) 에 속하게 된다.\n$N$개의 레벨 $M$이 주어질 때, 각 레벨이 속한 구간의 번호를 출력해 보자.\n",
        "input_text": "첫 번째 줄에는 레벨의 개수 $N(1 \\leq N \\leq 100)$이 주어진다.\n두 번째 줄에는 $N$개의 레벨 $M(1 \\leq M \\leq 300)$이 공백으로 구분되어 주어진다.\n",
        "output_text": "각 레벨이 속한 구간의 번호를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 389.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "54": {
        "problem_text": "지민이는 카지노의 딜러이고, 지금 3명의 플레이어(0, 1, 2)가 있다. 이 게임은 N개의 카드를 이용한다. (0 ~ N-1번)\n일단 지민이는 카드를 몇 번 섞은 다음에, 그것을 플레이어들에게 나누어 준다. 0번째 위치에 있던 카드가 플레이어 0에게 가고, 1번째 위치에 있던 카드는 플레이어 1에게 가고, 2번째 위치에 있던 카드는 플레이어 2에게 가고, 3번째 위치에 있던 카드는 플레이어 0에게 가고, 이런식으로 카드를 나누어 준다. 하지만, 지민이는 약간 사기를 치려고 한다.\n지민이는 처음에 카드를 섞기 전에 카드의 순서를 알고 있고, 이 정보를 이용해 각 카드가 특정한 플레이어에게 보내지게 할 것이다.\n카드를 한 번 섞을 때는 주어진 방법을 이용해서만 섞을 수 있고, 이 방법은 길이가 N인 수열 S로 주어진다. 카드를 한 번 섞고 나면 i번째 위치에 있던 카드는 S[i]번째 위치로 이동하게 된다.\n각 카드가 어떤 플레이어에게 가야 하는지에 대한 정보는 길이가 N인 수열 P로 주어진다. 맨 처음 i번째 위치에 있던 카드를 최종적으로 플레이어 P[i] 에게 보내야한다.\n지민이가 목적을 달성하기 위해 필요한 카드 섞는 횟수의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N이 주어진다. N은 3보다 크거나 같고, 48보다 작거나 같은 3의 배수이다.\n둘째 줄에 길이가 N인 수열 P가 주어진다. 수열 P에 있는 수는 0, 1, 2 중 하나이다.\n셋째 줄에 길이가 N인 수열 S가 주어진다. 수열 S에 있는 수는 모두 N-1보다 작거나 같은 자연수 또는 0이고 중복되지 않는다.\n",
        "output_text": "첫째 줄에 몇 번 섞어야 하는지 출력한다. 만약, 섞어도 섞어도 카드를 해당하는 플레이어에게 줄 수 없다면, -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 16.0,
        "length_median": 955.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "55": {
        "problem_text": "민겸이는 로마 숫자를 보고 굉장히 흥미롭다고 생각했다. 그래서 민겸이는 새로운 수 체계인 민겸 수를 창조했다.\n민겸 숫자는 0 이상의 정수 N에 대해 10N 또는 5 × 10N 꼴의 십진수를 대문자 M과 K로 이루어진 문자열로 표기한다. 10N 꼴의 십진수는 N + 1개의 M으로, 5 × 10N 꼴의 십진수는 N개의 M 뒤에 1개의 K를 이어붙인 문자열로 나타낸다. 즉, 아래 표처럼 나타낼 수 있다.\n\n\n\n변환 전\n변환 후\n\n\n1\nM\n\n\n5\nK\n\n\n10\nMM\n\n\n50\nMK\n\n\n100\nMMM\n\n\n500\nMMK\n\n\n1000\nMMMM\n\n\n5000\nMMMK\n\n\n...\n...\n\n\n\n민겸 수는 한 개 이상의 민겸 숫자를 이어붙여 만든다. 예를 들어, 민겸 수 MKKMMK는 MK, K, MMK의 세 민겸 숫자를 이어붙여 만들 수 있다.\n민겸 수를 십진수로 변환할 때는, 1개 이상의 민겸 숫자로 문자열을 분리한 뒤, 각각의 민겸 숫자를 십진수로 변환해서 순서대로 이어붙이면 된다. 민겸 숫자를 십진수로 변환하는 것은 십진수를 민겸 숫자로 변환하는 과정을 거꾸로 하면 된다. 예를 들어, 민겸 수 MKKMMK는 아래 그림과 같이 여러 가지 십진수로 변환할 수 있다.\n\n민겸이는 위와 같이 하나의 민겸 수가 다양한 십진수로 변환될 수 있다는 사실을 알았다. 문득 민겸이는 변환될 수 있는 십진수 중 가장 큰 값과 가장 작은 값이 궁금해졌다. 민겸이를 위해 하나의 민겸 수가 십진수로 변환되었을 때 가질 수 있는 최댓값과 최솟값을 구해주자.\n",
        "input_text": "민겸 수 하나가 주어진다. 민겸 수는 대문자 M과 K로만 이루어진 문자열이며, 길이는 3,000을 넘지 않는다.\n",
        "output_text": "주어진 민겸 수가 십진수로 변환되었을 때 가질 수 있는 값 중 가장 큰 값과 가장 작은 값을 두 줄로 나누어 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1061.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "56": {
        "problem_text": "매직 스타는 1부터 12까지 숫자가 헥사그램(hexagram)에 채워져 있는 모양으로 이루어져 있다.\n\n매직 스타의 이름에 매직이 들어가는 이유는 숫자 네 개로 이루어진 줄의 숫자를 모두 합하면 26이 되기 때문이다. 위의 그림의 여섯 줄에 쓰여 있는 숫자는 다음과 같다.\n\n1 + 4 + 10 + 11\n11 + 5 + 3 + 7\n7 + 6 + 12 + 1\n2 + 10 + 5 + 9\n9 + 3 + 6 + 8\n8 + 12 + 4 + 2\n\n매직 스타를 채우는 방법은 여러 가지가 있다. 일부만 채워진 매직 스타가 주어졌을 때, 수를 전부 다 채워서 매직 스타를 만드는 프로그램을 작성하시오.\n",
        "input_text": "매직 스타의 모양이 주어진다. 수가 채워져 있지 않은 곳은 x로, 채워져 있는 곳은 'A'부터 'L'까지 알파벳으로 채워져 있다. i번째 알파벳은 숫자 i를 의미한다. '.'는 매직 스타의 형태를 만들기 위해서 사용하는 문자이다. 모든 입력은 예제 입력과 같은 형태로 주어진다.\n",
        "output_text": "매직 스타를 만들 수 있는 방법 중에 사전 순으로 가장 앞서는 방법을 출력한다. (모든 줄을 순서대로 붙여서 하나의 문자열로 만든 뒤, 사전 순으로 비교한다.) 항상 정답이 존재하는 경우만 입력으로 주어진다.\n",
        "memory_median": 1988.0,
        "time_median": 152.0,
        "length_median": 1844.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "57": {
        "problem_text": "꿍은 만사가 귀찮아서 말을 하기도 귀찮아 한다. 그래서 하려는 말을 대신해줄 줄임말을 만들려고 하는데 나름 규칙을 만들었다.\n하려는 말은 최소 하나 이상의 단어를 포함하는데 각 단어들은 정확히 한칸의 공백으로 구분이 된다. 줄임말을 만들때는 각 단어의 앞글자를 따서 만들어지는데 다음의 단어들은 쓸모없는 단어들이므로 무시한다.\n'i', 'pa', 'te', 'ni', 'niti', 'a', 'ali', 'nego', 'no', 'ili'.\n하지만 이 단어들이 하려는 말의 맨 앞에 올경우 매우 중요하다고 판단되어 무시하면 안되고 줄임말에 포함하여야 한다.\n줄임말을 만들기도 귀찮아진 꿍을 위해 줄임말을 만들어주는 프로그램을 작성하라.\n단, 줄임말은 모두 대문자로만 이루어져있다.\n",
        "input_text": "입력은 유일하게 한 줄만 주어지며 하려는 말이 포함되어 있다.\n문장은 알파벳 소문자와 공백으로만 이루어져 있다.\n문장의 최대길이는 100이다.\n",
        "output_text": "만들어진 줄임말을 출력하라.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 637.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "58": {
        "problem_text": "드디어 전쟁은 전면전이 시작되었고, 서로 땅을 따먹기 시작했다.\n현재 여러 지역은 한창 전쟁이 벌어지고 있는 상황인데, 어느 지역은 거의 전쟁이 마무리 단계로 가고 있다.\n하지만 당신은 군대를 보낼 때 적군을 혼란시키기 위해서 우리 나라의 군대라는걸 표시하지 않고, 군대의 번호로 표시했다.\n어느 땅에서 한 번호의 군대의 병사가 절반을 초과한다면 그 땅은 그 번호의 군대의 지배하에 놓이게 된다.\n이때, 각 땅들을 지배한 군대의 번호를 출력하여라. 만약, 아직 전쟁이 한창중인 땅이라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.\n",
        "input_text": "첫째 줄에는 땅의 개수 n(n<=200)이 주어진다. 그리고 두 번째 줄에서 n+1번째 줄에는 제일 처음에 숫자 Ti(i번째 땅의 병사수, Ti<=100,000)와, Ti개의 숫자 (각각 병사의 군대 번호)가 주어진다. i번째 땅의 j번째 병사 번호 Nij가 주어진다. ( | Nij | <= 2^31 )\n",
        "output_text": "첫째 줄에는 각각의 땅의 상태를 순서대로 출력한다. 만약 땅이 지배가 되어있다면 그 지배한 병사의 번호를 출력하고, 아니라면 “SYJKGW”을 쌍 따옴표 없이 출력한다.\n",
        "memory_median": 4700.0,
        "time_median": 6088.0,
        "length_median": 702.0,
        "label": [
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "59": {
        "problem_text": "10년 동안 도박판에서 야바위를 한 영훈은 이제 보지 않고도 구슬이 있는 컵을 맞추는 지경에 이르렀다.\n이런 영훈을 골탕 먹이기 위해 문자열로 야바위를 하려고 한다.\nT번 동안 문자열 S의 A번째 위치에 있는 문자와 B번째 위치에 있는 문자를 바꾼 결과를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 문자열 S가 주어지고 두 번째 줄에 T가 주어진다. 문자열 S의 길이는 100보다 작거나 같은 자연수이며, 알파벳 대소문자와 하이픈(-)으로만 이루어져 있다. T는 50보다 작거나 같은 자연수이다.\n그 다음 T개의 줄에 걸쳐 A와 B가 주어진다.\nA와 B는 문자열의 길이보다 작은 음이 아닌 정수이며, 문자열의 맨 처음 글자는 0번째 글자이다.\n",
        "output_text": "바뀐 문자열의 결과를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 281.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "60": {
        "problem_text": "ビーバーのビ太郎は帰省することにした．今日から A 日後の午前に実家に着き，今日から B 日後の午前に実家を去る．それを聞きつけたビーバーのビバ子は，今日から C 日後の午後にビ太郎の実家を訪れることにした．ビバ子がビ太郎に会えるか判定せよ．\n",
        "input_text": "入力は以下の形式で標準入力から与えられる．\n\r\nA B C\n",
        "output_text": "ビバ子がビ太郎に会える場合は 1 を，そうでない場合は 0 を出力せよ．\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 184.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "61": {
        "problem_text": "십자가는 가운데에 '*'가 있고, 상하좌우 방향으로 모두 같은 길이의 '*'가 있는 모양이다. 십자가의 크기는 가운데를 중심으로 상하좌우 방향으로 있는 '*'의 개수이다. 십자가의 크기는 1보다 크거나 같아야 한다.\n아래 그림은 크기가 1, 2, 3인 십자가이고, 빈 칸은 '.'이다.\n\r\n              ...*...\r\n      ..*..   ...*...\r\n.*.   ..*..   ...*...\r\n***   *****   *******\r\n.*.   ..*..   ...*...\r\n      ..*..   ...*...\r\n              ...*...\n크기가 N×M이고, '.'과 '*'로 이루어진 격자판이 주어진다. 이때, 십자가만을 이용해서 격자판과 같은 모양을 만들 수 있는지 구해보자. 십자가는 서로 겹쳐도 된다. 사용할 수 있는 십자가의 개수는 N×M이하이어야 한다. 격자판의 행은 위에서부터 1번, 열은 왼쪽에서부터 1번으로 번호가 매겨져 있다.\n",
        "input_text": "첫째 줄에 격자판의 크기 N, M (3 ≤ N, M ≤ 100)이 주어진다. 둘째 줄부터 N개의 줄에 격자판의 상태가 주어진다.\n",
        "output_text": "십자가만 이용해서 입력으로 주어진 격자판을 만들 수 없으면 -1을 출력한다.\n만들 수 있는 경우에는 필요한 십자가의 수 k(0 ≤ k ≤ N×M)를 출력한다. 다음 k개의 줄에는 그려야 하는 십자가의 정보 x, y, s를 한 줄에 하나씩 출력한다. x는 십자가 중심의 행의 번호, y는 열의 번호, s는 십자가의 크기이다.\n가능한 답이 여러가지인 경우에는 아무거나 출력한다.\n",
        "memory_median": 2540.0,
        "time_median": 8.0,
        "length_median": 1702.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "62": {
        "problem_text": "1949 년 인도 수학자 Kaprekar 는 Kaprekar 연산을 고안해냈다. Kaprekar 연산은 네 자리 수 중 모든 자리수가 같지 않은 수(1111, 2222 등을 제외한)의 각 자리의 숫자를 재배열해서 만들 수 있는 가장 큰 수와 가장 작은 수를 만들어서 그 차이를 계산하는데, 그 결과로 나온 새로운 숫자를 갖고 같은 과정을 반복하는 것이다. \n간단한 연산이지만 Kaprekar 는 이 연산이 놀라운 결과를 보여준다는 것을 발견했다. 올해 연도인 2008 로 그 결과를 알아보자. 2008 로 만들 수 있는 가장 큰 수는 8200 이고 가장 작은 수는 0028 이다. \n\n8200 – 0028 = 8172 \n8721 – 1278 = 7443 \n7443 – 3447 = 3996 \n9963 – 3699 = 6264 \n6642 – 2466 = 4176 \n7641 – 1467 = 6174 \n7641 – 1467 = 6174 \n\n6174 에 도달한 다음에는 매번 6174 를 만들어 낸다. 2008 만이 유독 6174 에 도달하는 것이 아니라 한 숫자로 이루어지지 않은 모든 네 자리 수는 Kaprekar 연산을 통해 6174 로 가게 된다. 2008 의 경우 6 단계를 거쳐 6174 로 가게 되었는데, 다른 숫자가 입력으로 주어졌을 때 몇 단계만에 6174 로 가는지 알아내는 프로그램을 작성하시오. \n",
        "input_text": "입력은 표준입력(standard input)을 통해 받아들인다. 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스마다 한 줄에 네 자리 수(1000~9999)가 하나씩 주어진다. 단, 이 숫자는 1111, 2222 처럼 하나의 숫자로 이루어진 수는 제외한다. \n",
        "output_text": "출력은 표준출력(standard output)을 통하여 출력한다. 각 테스트 케이스에 대하여 Kaprekar 연산을 통해 몇 단계 만에 6174가 되는지 한 줄에 하나씩 출력하시오. \n",
        "memory_median": 1536.0,
        "time_median": 0.0,
        "length_median": 724.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "63": {
        "problem_text": "자가용 비행기를 타고 세계 일주를 하던 pps789와 cseteram은 어느 날 엔진 고장으로 인해 이름 모를 섬에 불시착하게 된다. 그들은 이 섬을 탐험하는 도중 아주 신기한 사실을 알게 되었는데, 바로 이 섬에 사는 앵무새들은 놀라울 정도로 인간의 말을 흉내 내는 데 뛰어나다는 것이다. 그들은 서로 떨어져 섬을 탐험하기로 하였으며, 필요하다면 앵무새를 이용해 서로에게 연락하기로 약속하였다.\n1개월 후, pps789는 섬의 비밀을 밝힐 결정적인 증거를 찾게 된다. 그는 이 세기의 대발견을 cseteram에게 공유하고자 하였으나, 그의 발견은 방대하여 앵무새 한 마리가 기억하기에는 너무 많은 양이었다. 그렇기 에 pps789는 앵무새 한 마리 대신 앵무새 N마리를 이용하여 자신의 발견을 기록하였으며, 이 앵무새들을 cseteram을 향해 날렸다.\n한편 섬의 반대편에서 탐험을 계속하던 cseteram은 앵무새 N마리가 자신에게 날아와 각자 할 말을 하는 것을 보고 당황하였다. pps789가 긴 글을 전달하고 싶었던 것은 알아차렸지만, 각각의 앵무새들이 말하는 것을 차례대로 기록하다 보니 원문이 무엇인지 알 수 없을 정도로 단어의 순서가 엉켜버린 것이다. 대신 그는 관찰을 통해 몇 가지 규칙을 발견할 수 있었다.\n\n한 앵무새는 한 문장을 기억하고 있다. 문장은 여러 단어로 이루어져 있는데, 앵무새는 이 단어들을 순서대로 말한다.\n한 앵무새가 단어를 말하고 그다음 단어를 말하기 전에는 약간의 간격이 있는데, 이때 다른 앵무새가 말을 가로채고 자신의 문장을 말할 수 있다.\n한 앵무새가 단어를 말하는 도중에는, 다른 앵무새가 말을 가로채지 않는다.\n어떤 단어도 앵무새가 말하는 모든 문장을 통틀어 2번 이상 등장하지 않는다.\n\n앵무새는 자신이 기억하고 있는 문장을 끝까지 말한 다음 pps789에게 돌아가며, cseteram은 모든 앵무새가 돌아갈 때 까지 단어를 받아적는다. pps789가 각각의 앵무새들에게 전달한 문장 Si와, cseteram이 받아 적은 문장 L이 주어진다. 이때 문장 L이 위 규칙들을 이용하여 나올 수 있는 문장인지 판별하시오.\n",
        "input_text": "첫 번째 줄에 앵무새의 수 N (1 ≤ N ≤ 100) 이 주어진다.\n두 번째 줄부터 N개의 줄에 걸쳐 각 앵무새가 말한 문장 Si (1 ≤ i ≤ N) 가 주어지는데, 각 문장을 이루는 단어는 스페이스 한 칸을 구분으로 하여 주어진다. 문장 Si를 이루는 단어의 수는 1개 이상 100개 이하이며, 각 단어는 1개 이상 32개 이하의 영문 소문자로 구성되어있다.\nN + 2 번째 줄에는 cseteram이 받아 적은 문장 L이 주어진다. 문장 L을 이루는 단어의 수는 1개 이상 10000개 이하이며, 각 단어는 1개 이상 32개 이하의 영문 소문자로 구성된다.\n",
        "output_text": "문장 L이 가능한 문장이라면 Possible을, 불가능한 문장이라면 Impossible을 출력한다.\n",
        "memory_median": 4552.0,
        "time_median": 16.0,
        "length_median": 1177.0,
        "label": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "64": {
        "problem_text": "k명의 참가자들이 사다리 타기를 통하여 어떤 순서를 결정한다. 참가자들은 알파벳 대문자 첫 k개로 표현되며, 사다리 타기를 시작할 때의 순서는 아래 그림과 같이 항상 알파벳 순서대로이다. \nk=10 인 예를 들어 보자. 10명의 A, B, C, D, E, F, G, H, I, J 참가자들이 사다리 타기를 준비한다. 아래 그림은 10개의 세로 줄과 5개의 가로 줄을 가지고 있는 사다리의 한 예를 보여주고 있다.  \n\n이 사다리에서 점선은 가로 막대가 없음을, 굵은 가로 실선은 옆으로 건너갈 수 있는 가로 막대가 있음을 나타내고 있다.  \n따라서 위에 제시된 사다리를 타면 그 최종 도달된 순서는 왼쪽으로부터 A, C, G, B, E, D, J, F, I, H 가 된다. \n사다리 타기는 세로 막대를 타고 내려오는 중에 가로막대를 만나면 그 쪽으로 옮겨 가면서 끝까지 내려가는 과정이다.  따라서 사다리 타기의 규칙 특성상 아래 그림과 같이 두 가로 막대가 직접 연결될 수는 없으므로 이 상황은 이 문제에서 고려할 필요가 없다.\n\n우리는 하나의 가로 줄이 감추어진 사다리를 받아서 그 줄의 각 칸에 가로 막대를 적절히 넣어서 참가자들의 최종 순서가 원하는 순서대로 나오도록 만들려고 한다.  \n입력에서 사다리의 전체 모양은 각 줄에 있는 가로 막대의 유무로 표현된다. 각 줄에서 가로 막대가 없는 경우에는 ‘*’(별)문자, 있을 경우에는 ‘-’(빼기) 문자로 표시된다. 그리고 감추어진 특정 가로 줄은 길이 k-1인 ‘?’ (물음표) 문자열로 표시되어 있다.   \n",
        "input_text": "첫 줄에는 참가한 사람의 수 k가 나온다(3 ≤ k ≤ 26). 그 다음 줄에는 가로 막대가 놓일 전체 가로 줄의 수를 나타내는 n이 나온다(3 ≤ n ≤ 1,000). 그리고 세 번째 줄에는 사다리를 타고 난 후 결정된 참가자들의 최종 순서가 길이 k인 대문자 문자열로 들어온다.  \nk와 n, 그리고 도착순서 문자열이 나타난 다음, 이어지는 n개의 줄에는 앞서 설명한 바와 같이 ‘*’와 ‘-’ 문자로 이루어진 길이 k-1인 문자열이 주어진다. 그 중 감추어진 가로 줄은 길이가 k-1인 ‘?’ 문자열로 표시되어 있다.\n",
        "output_text": "입력 파일 세 번째 줄에서 지정한 도착순서가 해당 사다리에서 만들어질 수 있도록 감추어진 가로 줄을 구성해야 한다. \n여러분은 감추어진 가로 줄의 상태를 재구성하여 이를 ‘*’(별) 문자와 ‘-’(빼기) 문자로 구성된 길이 k-1인 문자열로 만들어 출력하면 된다.\n그런데 어떤 경우에는 그 감추어진 가로 줄을 어떻게 구성해도 원하는 순서를 얻을 수 없는 경우도 있다.  이 경우에는  ‘x’(소문자 엑스)로 구성된 길이 k-1인 문자열을 출력해야 한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1389.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "65": {
        "problem_text": "투표가 끝난 뒤에는 개표를 해야 한다. 일반적으로 개표는 칠판을 사용하며, 한 표가 나올 때마다 한 획을 추가로 긋는 방식을 사용한다.\n이 문제에서는 다음과 같은 방식으로 개표를 진행한다.\n\n모든 후보자는 $0$표, 즉 아무것도 그려져 있지 않는 상태로 시작한다.\n어떤 후보자가 한 표를 받을 때마다, |를 맨 뒤에 그린다.\n단, 그 후보자가 $5$표를 받을 때마다, |를 그리는 대신 이미 있던 $4$개의 |에 가로줄을 그어 ++++를 만든다. 이후 $1$칸의 공백을 뒤에 추가한다.\n\n예를 들면, $12$표를 받은 후보의 경우 칠판에는 ++++ ++++ ||가 적히게 된다.\n",
        "input_text": "첫 번째 줄에 후보의 수 $T$가 주어진다. $(1\\le T\\le 100)$\n두 번째 줄부터 $T$개의 줄에 걸쳐, 각 후보가 받은 표의 수 $n$이 주어진다. $(1\\le n\\le 100)$\n",
        "output_text": "각 후보에 대해, 칠판에 그려지게 되는 결과를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 371.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "66": {
        "problem_text": "이 문제에서 당신은 Quicksum이라고 하는 checksum 알고리즘을 구현해야 한다.  Quicksum 패킷은 오직 대문자와 공백으로 이루어져있다. 그리고 시작과 끝은 항상 대문자이다.  공백은 문자와 섞여있을수 있으며 연속되어서 있을수도 있다.\nQuicksum은 각각의 문자의 위치와 문자 값의 합이다. 공백은 0이다. 문자는 고유의 위치값을 가지고 있는데 예를들어 A=1, B=2 ... Z=26이다.\n예제 문장은 \"ACM\" 과 \"MID CENTRAL\"인데 살펴보면 다음과 같다.\nACM: 1*1  + 2*3 + 3*13 = 46\nMID CENTRAL: 1*13 + 2*9 + 3*4 + 4*0 + 5*3 + 6*5 + 7*14 + 8*20 + 9*18 + 10*1 + 11*12 = 650\n",
        "input_text": "# 이 들어오기 전까지 계속 입력을 받는다. 각각의 패킷은 한줄에 하나씩 입력이 되며 공백으로 시작되거나 끝나지 않으며, 대문자만 입력이 된다. 패킷의 길이는 1~255자이다.\n",
        "output_text": "각각의 패킷에 따라 한줄에 하나씩 Quicksum 을 출력하라.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 381.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "67": {
        "problem_text": "Cryptoquote는 어떤 메시지가 있을 때, 각 알파벳을 다른 알파벳으로 변환해 암호화 하는 방법이다.\n예를 들어, HPC PJVYMIY란 메시지가 있을 때, 이를 원래 메시지로 바꾼다면 ACM CONTEST가 된다.\n위의 예를 바꾸는 규칙은 H=A, P=C, C=M, J=O, V=N, Y=T, M=E, I=S이다. 이처럼 Cryptoquote를 하려면, 문자와 문자 사이의 규칙이 있어야 한다.\n암호화된 메시지와 문자와 문자 사이의 규칙이 주어졌을 때, 이를 원래 메시지로 바꾸는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1000)가 주어진다. 각 테스트 케이스는 다음과 같이 두 줄로 구성되어 있다.\n테스트 케이스의 첫째 줄에는 암호화된 메시지가 주어지고, 둘째 줄에는 변환 규칙이 주어진다. 변환 규칙은 알파벳 대문자 26글자로 이루어져있고, 암호회된 메시지의 길이는 100 이하이다.\n첫 번째 문자는 A에 해당하는 문자, 두 번째는 B, ..., 26번째는 Z에 해당하는 문자이다. 변환 규칙은 중복되지 않는다. 암호화된 메시지에는 공백이 있을 수 있고, 이것은 원래 메시지에도 포함되어야 한다.\n",
        "output_text": "각 테스트 케이스에 대해서 한 줄에 하나씩 원래 메시지를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 434.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "68": {
        "problem_text": "천하제일의 장수 관우도 결국 죽음을 맞이했다. 유비와 장비는 관우의 복수를 위해 $N$명의 용의자 중 관우를 죽인 범인을 찾으려 한다. 관우와 함께 있었던 장수의 말에 따르면 관우를 죽인 범인의 이름에는 S가 들어간다. 관우를 죽인 용의자 이름의 리스트에서 관우를 죽인 범인의 이름을 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 용의자의 수를 뜻하는 정수 $N$이 주어진다. $(1\\le N\\le 1\\, 000)$\n둘째 줄부터 $N$개의 줄에 걸쳐 용의자의 이름이 한 줄에 하나씩 주어진다. 이름은 영어 대문자로만 이루어져 있으며, 이름의 길이는 $100$글자를 넘지 않는다.\n항상 답이 유일하게 존재하는 경우만 입력으로 주어진다.\n",
        "output_text": "첫째 줄에 관우를 죽인 범인의 이름을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 344.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "69": {
        "problem_text": "\"피터팬 프레임\"은 단어를 다이아몬드 형태로 장식하는 것이다.\n알파벳 X를 피터팬 프레임으로 장식하면 다음과 같다.\n\r\n..#..\r\n.#.#.\r\n#.X.#\r\n.#.#.\r\n..#..\n\"웬디 프레임\"은 피터팬 프레임과 유사하지만, 다이아몬드를 '*'로 만드는 것이다. \n알파벳 X를 웬디 프레임으로 장식하면 다음과 같다.\n\r\n..*..\r\n.*.*.\r\n*.X.*\r\n.*.*.\r\n..*..\n단어가 주어졌을 때, 3의 배수 위치(세 번째, 여섯 번째, 아홉번째, ...)에 있는 알파벳은 웬디 프레임으로, 나머지 알파벳은 피터팬 프레임으로 장식하는 프로그램을 작성하시오.\n웬디 프레임과 피터팬 프레임이 겹칠 경우에는, 웬디 프레임이 위에 있다.\n",
        "input_text": "첫째 줄에 알파벳 대문자로 이루어진 최대 15글자 단어가 주어진다.\n",
        "output_text": "다섯 줄에 걸쳐, 입력으로 주어진 단어를 피터팬 프레임과 웬디 프레임으로 장식한 결과를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 970.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "70": {
        "problem_text": "가로, 세로의 크기가 각각 100인 정사각형 모양의 흰색 도화지가 있다. 이 도화지 위에 가로, 세로의 크기가 각각 10인 정사각형 모양의 검은색 색종이를 색종이의 변과 도화지의 변이 평행하도록 붙인다. 이러한 방식으로 색종이를 한 장 또는 여러 장 붙인 후 도화지에서 검은색 직사각형을 잘라내려고 한다. 직사각형 또한 그 변이 도화지의 변과 평행하도록 잘라내어야 한다.\n예를 들어 흰색 도화지 위에 세 장의 검은색 색종이를 <그림 1>과 같은 모양으로 붙였다. <그림 1>에 표시된 대로 검은색 직사각형을 잘라내면 그 넓이는 22×5=110이 된다.\n\n<그림 1>\n\n<그림 2>\n반면 <그림 2>에 표시된 대로 검은색 직사각형을 잘라내면 그 넓이는 8×15=120이 된다.\n검은색 색종이의 수와 각 색종이를 붙인 위치가 주어질 때 잘라낼 수 있는 검은색 직사각형의 최대 넓이를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 색종이의 수가 주어진다. 이어 둘째 줄부터 한 줄에 하나씩 색종이를 붙인 위치가 주어진다. 색종이를 붙인 위치는 두 개의 자연수로 주어지는데 첫 번째 자연수는 색종이의 왼쪽 변과 도화지의 왼쪽 변 사이의 거리이고, 두 번째 자연수는 색종이의 아래쪽 변과 도화지의 아래쪽 변 사이의 거리이다. 색종이의 수는 100이하이며, 색종이가 도화지 밖으로 나가는 경우는 없다.\n",
        "output_text": "첫째 줄에 잘라낼 수 있는 검은색 직사각형의 최대 넓이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1069.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "71": {
        "problem_text": "HCPC (Hanyang Completely Perfect Celebrity)는 한양대학교 최고의 가수에게 주어지는 칭호이다. 한양대학교는 매년 최고의 HCPC를 선발한다. HCPC가 되기란 여간 어려운 게 아니다. 매일 아침 날달걀을 까먹고, 여름에도 목도리를 하여 목을 보호하고 평소에 한 마디도 하지 않으며 HCPC가 되기 위해 목을 보호한다. 실제로 귀가 어둡고 잘 들리지 않던 사람도 HCPC의 노래 한 소절만 들으면 귀가 밝아지고 청명해지며 똑똑해지고 삶의 이치를 깨닫게 된다고 한다.\n이런 HCPC의 목소리를 한양대생들에게 들려줄 기회를 마련하기 위해 한양대에선 매년 HCPC의 콘서트를 연다. HCPC 콘서트의 티켓팅은 매우 치열하며 티켓팅은 2차까지 있다. 이 티켓의 번호가 작을수록 HCPC의 목소리를 가까이에서 들을 수 있다. \n양한이는 HCPC 콘서트의 1차 티켓팅을 놓치고, 2차 티켓팅에 도전한다. 양한이는 매우 특별한 정보를 얻었는데, 이는 바로 1차 티켓팅에서 이미 팔린 티켓의 번호들의 목록이다. 티켓의 번호는 1번부터 시작한다. \n양한이는 이 목록에 있는 번호들을 가진 티켓을 제외한 티켓 중 번호가 가장 작은 티켓의 번호를 알고 싶다. 양한이를 도와주자!\n",
        "input_text": "첫째 줄에 1차 티켓팅에서 팔린 티켓들의 수인 정수 N이 주어진다. (1 ≤ N ≤ 1,000,000)\n둘째 줄에는 1차 티켓팅에서 팔린 티켓들의 번호 정수 Ai가 주어진다. (1 ≤ Ai ≤ 231 − 1)\n",
        "output_text": "2차 티켓팅에서 양한이가 가질 수 있는 티켓 중 가장 작은 번호를 출력한다.\n",
        "memory_median": 5968.0,
        "time_median": 204.0,
        "length_median": 414.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "72": {
        "problem_text": "오늘도 서준이는 버블 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 버블 정렬로 배열 A를 오름차순 정렬할 경우 K 번째 교환되는 수를 구해서 우리 서준이를 도와주자.\n크기가 N인 배열에 대한 버블 정렬 의사 코드는 다음과 같다.\n\r\nbubble_sort(A[1..N]) { # A[1..N]을 오름차순 정렬한다.\r\n    for last <- N downto 2\r\n        for i <- 1 to last - 1\r\n            if (A[i] > A[i + 1]) then A[i] <-> A[i + 1]  # 원소 교환\r\n}\n",
        "input_text": "첫째 줄에 배열 A의 크기 N(5 ≤ N ≤ 10,000), 교환 횟수 K(1 ≤ K ≤ N2)가 주어진다.\n다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)\n",
        "output_text": "K 번째 교환되는 두 개의 수를 작은 수부터 한 줄에 출력한다. 교환 횟수가 K 보다 작으면 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 136.0,
        "length_median": 635.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "73": {
        "problem_text": "단색 비트맵 이미지는 이미지를 구성하는 각 픽셀은 0 또는 1의 색상 정보를 가지고 있다.\n비트맵 이미지는 생성 당시 이미지의 크기, 해당 이미지를 구성하는 모든 픽셀의 정보가 이미 정해져 있기 때문에, 그림 1과 같이 이미지의 크기를 늘리더라도\n기존의 픽셀이 늘린 방향으로 넓게 퍼질 뿐 해상도가 늘어나진 않는다.\n\n< 그림 1. 크기를 늘린 비트맵 이미지의 예시 >\n이렇게 기존에 있던 이미지에 픽셀을 추가하여 그림을 구성하는 총 픽셀 수를 늘리는 것을 업샘플링 (Up sampling) 이라고 한다.\n업샘플링을 하는 방법은 여러 가지가 있는데 그중 가장 간단한 방법은 기존 픽셀의 배열을 그대로 유지한 채, 각 픽셀의 개수를 동일하게 늘리는 방법이다.\n\n<그림 2. 그림을 가로, 세로로 K(=2) 배 늘렸을 때 추가된 픽셀의 모습 >\n가로 세로의 길이가 N 인 단색 비트맵 이미지를 구성하는 모든 픽셀의 정보가 주어질 때, 해당 그림의 가로와 세로 크기를 그림 2와 같이 K 배 늘렸을 때, 업샘플링을 통해 늘어난 그림의 픽셀 정보들을 구해보자.\n",
        "input_text": "첫 번째 줄에는 정사각형 단색 비트맵의 가로/세로 길이 N (1 ≤ N ≤ 10)과 이미지를 늘릴 배수 K (1 ≤ K ≤ 10) 가 주어진다.\n두 번째 줄부터 (N+1)번째 줄에는 각 줄마다 N개의 픽셀 정보가 주어진다.\n",
        "output_text": "N x K 줄에 걸쳐, 늘어난 단색 비트맵 이미지의 픽셀 정보를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 516.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "74": {
        "problem_text": "서준이는 아빠로부터 골뱅이가 들어 있는 상자를 생일 선물로 받았다. 상자 안에는 ㅌ자 모양의 골뱅이가 들어있다. ㅌ자 모양은 가로 및 세로로 각각 5개의 셀로 구성되어 있다. 상자에는 정사각형 모양의 셀의 크기를 나타내는 숫자 하나가 적혀있다. 셀의 크기 N이 주어지면 예제 출력과 같은 방식으로 골뱅이 모양을 출력하시오.\n",
        "input_text": "첫째 줄에 정수 N(1 ≤ N ≤ 100)이 주어진다.\n",
        "output_text": "셀의 크기가 N인 골뱅이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 585.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "75": {
        "problem_text": "유빈이는 코딩을 하다가 시간 초과가 났다. 그래서 시간 복잡도를 계산하기로 했다.\n채점 시스템은 1초에 100000000(108)가지 동작을 할 수 있다.\n여러분들은 유빈이를 도와 시간초과가 나는지 확인하는 프로그램을 작성하라.\n",
        "input_text": "입력의 첫 번째 줄에는 테스트 케이스들의 수 C가 주어진다.\n그 다음 C개의 줄에는 시간 복잡도를 나타내는 문자열 S, 각 테스트 케이스마다 입력의 최대 범위 N, 테스트 케이스의 수를 나타내는 T랑 제한시간(초 단위) 를 나타내는 L이 주어진다. (1 <= C <= 100, 1 <= N <= 1000000, 1 <= T, L <= 10, N, T, L은 정수)\n시간 복잡도는 다음과 같은 5개 중 하나로 주어진다.\n\nO (N)\nO (N^2)\nO (N^3)\nO (2^N)\nO (N!)\n\n",
        "output_text": "각 테스트 케이스들에 대하여 시간 초과가 나면 \"TLE!\", 시간 초과가 나지 않으면 \"May Pass.\" 를 출력한다.\n",
        "memory_median": 2000.0,
        "time_median": 0.0,
        "length_median": 1150.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "76": {
        "problem_text": "페그 솔리테어는 구멍이 뚫려있는 이차원 게임판에서 하는 게임이다. 각 구멍에는 핀을 하나 꽂을 수 있다.\n핀은 수평, 수직 방향으로 인접한 핀을 뛰어넘어서 그 핀의 다음 칸으로 이동하는 것만 허용된다. 인접한 핀의 다음 칸은 비어있어야 하고 그 인접한 핀은 제거된다.\n현재 게임판에 꽂혀있는 핀의 상태가 주어진다. 이때, 핀을 적절히 움직여서 게임판에 남아있는 핀의 개수를 최소로 하려고 한다. 또, 그렇게 남기기 위해 필요한 최소 이동횟수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 1 ≤ N ≤ 100이 주어진다. 각 테스트 케이스는 게임판의 초기 상태이다.\n게임판은 모두 같은 모양을 가진다. (예제 참고) '.'는 빈 칸, 'o'는 핀이 꽂혀있는 칸, '#'는 구멍이 없는 칸이다. 핀의 개수는 최대 8이며, 각 테스트 케이스는 빈 줄로 구분되어져 있다.\n",
        "output_text": "각 테스트 케이스에 대해서, 핀을 움직여서 남길 수 있는 핀의 최소 개수와 그 개수를 만들기 위해 필요한 최소 이동 횟수를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 1652.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "77": {
        "problem_text": "중앙대학교 소프트웨어학부에 새로 입학한 19학번 새내기 일구는 새내기 새로 배움터에 가서 술게임을 여러 가지 배웠다. 그 중 가장 재미있었던 게임은 바로 번데기 게임이었다.\n번데기 게임의 규칙은 다음과 같다. ‘뻔 – 데기 – 뻔 – 데기 – 뻔 – 뻔 – 데기 – 데기’ 를 1회차 문장이라고 하자. 2회차 문장은 ‘뻔 – 데기 – 뻔 - 데기 – 뻔 – 뻔 – 뻔 – 데기 – 데기 – 데기’가 된다. 즉 n-1회차 문장일 때는 ‘뻔 – 데기 – 뻔 – 데기 – 뻔(x n번) – 데기(x n번)’이 된다. 하이픈 사이를 지날 때마다 순서는 다음 사람으로 넘어간다. 원을 돌아 다시 일구 차례가 와도 게임은 계속 진행된다.\n일구와 동기들, 그리고 선배들을 포함한 사람 A명이 다음과 같이 원으로 앉아 있다고 가정하자. \n\n일구가 0번째이고, 반 시계 방향으로 번데기 게임을 진행한다. T번째 ‘뻔’ 또는 ‘데기’를 외치는 사람은 위 원에서 몇 번 사람인지를 구하여라. (새내기는 10000번째가 되는 순간 시체방에 가기 때문에 T는 10000이하의 임의의 자연수이다.)\n",
        "input_text": "첫째 줄에 게임을 진행하는 사람 A명이 주어진다. A는 2,000보다 작거나 같은 자연수이다.\n둘째 줄에는 구하고자 하는 번째 T가 주어진다. (T ≤ 10000)\n셋째 줄에는 구하고자 하는 구호가 “뻔”이면 0, “데기”면 1로 주어진다. \n",
        "output_text": "첫째 줄에 구하고자 하는 사람이 원탁에서 몇 번째에 있는지 정수로 출력한다. \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 807.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "78": {
        "problem_text": "치즈와 피자에 환장하는 비행씨는 매일같이 치즈피자를 사 먹다가 지갑이 거덜 나고 말았다. 만들어 먹는 것이 사 먹는 것보다 싸다는 것을 안 비행씨는 여러 가지 토핑을 가져와서 직접 피자를 만들어 먹기로 했다.  \n콰트로치즈피자는 이름 그대로, 서로 다른 네 종류의 치즈가 토핑으로 들어가야 한다. 수많은 치즈피자를 먹어 온 비행씨는 토핑의 이름이 Cheese로 끝나면 이 토핑이 치즈라는 사실을 알고 있다. 비행씨가 가져온 토핑의 목록을 보고, 이 토핑의 일부 혹은 전부를 이용하여 콰트로치즈피자를 만들 수 있는지 답해 보자.\n",
        "input_text": "첫 번째 줄에 토핑의 개수가 $1$ 이상 $100$ 이하의 정수로 주어진다.\n두 번째 줄에는 한 줄로 구성된 토핑의 목록이 주어진다. 각 토핑들은 공백으로 구분되어 있으며, $1$개 이상 $100$개 이하의 영문 대소문자로 구성되어 있다. 대소문자를 구분함에 유의하라.\n",
        "output_text": "입력으로 주어진 토핑의 목록으로 콰트로치즈피자를 만들 수 있으면 yummy, 만들 수 없으면 sad를 출력하라.\n",
        "memory_median": 2160.0,
        "time_median": 0.0,
        "length_median": 560.0,
        "label": [
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "79": {
        "problem_text": "매년 4~5월은 Google Code Jam이 열리는 기간이다. 슬프게도 Google은 2023년부터 Code Jam, Kick Start, Hash Code 등 다양한 형태로 운영해 왔던 Google Coding Competition을 종료하기로 했다. 더 이상 티셔츠를 받을 수 없다는 사실에 절망한 브실이는 Google Code Jam을 기억하는 문제를 만들기로 했다.\nGoogle Code Jam은 Qualification Round, Round 1, Round 2, Round 3, World Finals의 순서로 진행된다. 30점 이상을 획득하면 다음 라운드로 진출하는 Qualification Round와 더 이상 다음 라운드가 없는 World Finals을 제외한 라운드는 다음 라운드에 진출하기 위해선 정해진 순위 안에 들어야 한다. 각각 Round 1은 상위 $4\\,500$등, Round 2는 상위 $1\\,000$등, Round 3은 상위 $25$등 안에 들어야 다음 라운드에 진출할 수 있다.\n입력으로 Google Code Jam 참가자가 가장 마지막으로 참가한 라운드의 등수 $N$이 주어진다. 해당 참가자가 가장 마지막으로 참가한 라운드를 출력하라. 단 문제에서 주어지는 참가자는 Qualification Round는 모두 통과했다고 가정하므로 출력해야 할 라운드는 Round 1, Round 2, Round 3, World Finals 중 하나이다. 모든 참가자는 Google Code Jam에 참가하기만을 손꼽아 기다려 왔기 때문에 참가자가 등수 미달로 탈락하는 경우가 아닌 이상 중도 포기를 하는 경우는 없다.\n",
        "input_text": "첫 번째 줄에 테스트케이스의 수 $T$가 주어진다. $(1 \\le T \\le 100)$\n각 테스트케이스에 대해, 첫 번째 줄에 Google Code Jam 참가자가 가장 마지막으로 참가한 라운드의 등수 $N$이 주어진다. $(1 \\le N \\le 30\\,000)$\n",
        "output_text": "Google Code Jam은 다중 테스트케이스 문제에서 $x$번째 테스트케이스의 출력 앞에 Case #$x$: 를 삽입하게 하는 전통이 있다. 브실이는 문제를 푸는 사람들이 이 규칙을 따르길 원하므로 출력형식을 다음과 같이 지정했다.\n테스트케이스마다 Case #$x$: $y$ 형식의 한 줄을 출력한다. 여기서 $x$는 $1$부터 시작하는 테스트케이스 번호이고 $y$는 해당 Google Code Jam 참가자가 가장 마지막으로 참가한 라운드에 해당하는 문자열이다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 486.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "80": {
        "problem_text": "아주대학교 프로그래밍 경시대회(Ajou Programming Contest, APC)는 2009년 제1회를 시작으로 2014년 제6회까지 개최된 아주대학교 학생들을 위한 프로그래밍 경시대회이다. 2017년, 다른 학교에서 활발히 진행되는 교내대회를 보던 현정이는 3년 만에 APC를 부활시키기로 결심했다.\n2017 APC 운영 방식은 다음과 같다.\n\n문제는 Small 데이터와 Large 데이터로 이루어져 있다.\n문제를 풀기 위해서는 입력 파일을 다운로드 받고, 5분 이내로 이에 맞는 출력 파일과 소스 코드를 업로드해야 한다.\nSmall 데이터 문제를 해결해야 Large 데이터 입력 파일을 다운로드 받을 수 있다.\n각 문제의 Small, Large 데이터를 해결하면 점수를 얻을 수 있으며, 이 점수는 각각 다르다.\n제출 횟수는 점수를 획득한 문제를 맞기 까지 인풋을 다운로드 받은 횟수의 총합이다.\n즉, 점수를 획득하지 못한 문제의 다운로드 횟수는 포함되지 않는다.\n\n위 운영 방식에 따라 순위는 다음과 같이 결정된다.\n\n해결한 문제 점수의 총합이 높은 참가자가 더 높은 순위를 가진다.\n점수의 총합이 같은 경우, 제출 횟수가 적은 참가자가 더 높은 순위를 가진다.\n점수의 총합과 제출 횟수가 같은 경우, 마지막으로 점수를 획득한 문제의 업로드 시간이 빠른 참가자가 더 높은 순위를 가진다.\n\n매우 유감스럽게도 현정이는 며칠째 잠을 제대로 자지 못해 흉폭해져있다. 현정이의 일을 덜어 잠깐이라도 잘 수 있도록 참가자들의 순위를 계산하는 프로그램을 작성해주자.\n",
        "input_text": "첫 번째 줄에는 참가자의 수를 나타내는 자연수 N (1 ≤ N ≤ 3) 이 주어진다.\n두 번째 줄부터 N 개의 줄에 걸쳐 세 개의 정수 Si, Ci, Li (0 ≤ Si ≤ 620, 0 ≤ Ci ≤ 50, 0 ≤ Li ≤ 179)가 주어진다.\n(1+i) 번째 줄의 각 값은 차례로 i 번째 참가자의 점수, 제출 횟수, 마지막으로 점수를 획득한 문제의 업로드 시간을 나타낸다. 세 값이 모두 같은 참가자는 존재하지 않는다.\n",
        "output_text": "1등을 하는 참가자의 번호를 한 줄에 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 607.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "81": {
        "problem_text": "먹고또자니 <거기 누구세요> 코너에서는 \"돌림판\"을 돌려 상품을 얻을 수 있다. 이 돌림판은 큰 원형판이 N등분되어있는 형태이다.\nN등분 된 각 부분은 0부터 9사이의 숫자가 하나씩 적혀있다. 게임이 시작되면, 임의의 M자리의 수 X와 Y(X ≤ Y)가 주어진다. (단, 이 수는 0으로 시작될 수도 있다.)\r\n그리고 참가자는 돌림판을 힘차게 돌린다. 힘차게 돌던 돌림판이 완전히 멈추게 되는 순간, 12시 방향의 스피너가 특정 부분을 가리키게 될 것이다. 거기서부터 시계방향으로 M칸 연속되는 수를 읽으면 M자리의 수 Z를 얻을 수 있다.\n이때 얻은 Z가 X ≤ Z ≤ Y를 만족한다면 게임을 승리하고 Z만원을 얻을 수 있다!\n\n예를 들어, 돌림판이 N = 8 등분되어있고, 시계방향으로 읽었을 때 [3, 7, 8, 3, 1, 9, 2, 7] 과 같다고 하자. X = 200 이고 Y = 311일 경우 \"숫자 2\"가 적힌 부분부터 시작한다면 Z = 273 으로 X = 200 ≤ 273 ≤ 311 = Y 를 만족하여 게임을 승리한다.\n돌림판의 상태와 X, Y가 주어질 때 어느 부분부터 시작하면 게임을 승리할 수 있을 지 알 수 있다. 주어진 조건에 대해서 게임을 승리할 수 있는 가지수를 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 테스트케이스의 개수 T가 주어진다.\n각 테스트케이스의 첫 줄에는 돌림판을 N등분할 정수 N (1 ≤ N ≤ 100)과 X, Y의 길이 M (1 ≤ M ≤ 9, M ≤ N) 이 주어진다. 그리고 다음 3개의 줄에 X의 각 자리수, Y의 각 자리수, 돌림판의 상태가 주어진다.\nX와 Y의 각 자리수는 공백으로 구분되어 0~9사이의 숫자가 한자리씩 주어진다.\n돌림판의 상태는 어느 부분부터 시계방향으로 읽었을 때 나타나는 순서대로 주어진다. 돌림판의 숫자도 0~9사이의 숫자가 공백으로 구분되어 주어진다.\n",
        "output_text": "각 테스트케이스에 대하여 한 줄씩 정답을 출력한다.\n즉, 돌림판에서 X ≤ Z ≤ Y를 만족하는 M자리의 수 Z가 몇 개가 있는 지를 출력한다. 단, 같은 수라도 시작 부분이 다르다면 다른 가지수로 센다. 예를 들어, X와 Y 사이에 있는 수가 123 밖에 없는 데 돌림판에서 2번 나온다면, 1이 아닌 2를 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 829.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "82": {
        "problem_text": "정보섬에 벚꽃이 피어났다!\n정보섬에 만발한 꽃송이들을 본 욱제는 한 가지 좋은 생각을 떠올렸다. 아래와 같은 네 개의 푯말을 준비해서 정보섬의 꽃밭에 세우는 것이다.\n\n정보섬의 1층 꽃밭에는 총 N개의 벚나무가 일렬로 늘어서 있다. 각 벚나무에는 늘어선 순서대로 A1, A2, ..., AN개의 벚꽃이 피어나 있다. 욱제는 이 벚나무를 총 네 개의 그룹으로 나누어 각 그룹을 대표하도록 푯말을 세웠다.\n이 그룹을 나눈 데에는 특별한 기준이 있다. 그룹 [i, j]의 벚꽃 개수들의 곱 Pi,j = Ai × Ai+1 × ... × Aj-1 × Aj (i ≤ j)가 네 개 있을 때, 네 개의 P의 합이 최대가 되도록 나누었다. 다시 말해, 그룹 내의 벚꽃 개수를 모두 곱하고, 그렇게 곱해진 값 네 개를 모두 더한 값이 최대가 되도록 나누었다. 욱제는 연속된 순서의 나무들만 하나의 그룹으로 묶고, 모든 나무들을 빠짐없이 정확히 하나의 그룹에 포함시켰다. 또한 하나의 그룹에는 반드시 하나 이상의 나무가 포함되었다.\n\n힘든 하루를 마치고 집으로 돌아가던 당신은 정보섬 1층에 만발한 꽃송이와 푯말을 보았다. 그리고 갑자기 최대화 된 네 개의 P의 합이 얼마인지 궁금해졌다.\n얼마일까?\n",
        "input_text": "첫째 줄에 벚나무의 개수 N이 주어진다. (4 ≤ N ≤ 10)\n둘째 줄에 N개의 나무에 피어난 벚꽃의 개수 Ai가 순서대로 주어진다. (1 ≤ Ai ≤ 5)\n",
        "output_text": "얼마일까?\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 699.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "83": {
        "problem_text": "It’s time for the annual 3-SAT competition, where the contestants compete to answer as many instances of 3-SAT as possible within the time limit. 3-SAT is a classic NP-complete problem, where you are given a boolean formula in conjunctive normal form, in which we have a set of clauses each consisting of exactly three literals. Each literal refer either positively or negatively to a variable, which can be assigned a value of either True or False. The question is whether there exists an assignment to the variables such that every clause evaluates to True. No clause will contain duplicates of a literal (however it is possible that a clause contain both ¬xi and xi). An example of a 3-SAT instance is shown below (from sample input 1):\n(¬x1 ∨ x2 ∨ x3) ∧ (¬x1 ∨ ¬x2 ∨ x3) ∧ (x1 ∨ ¬x2 ∨ x3) ∧ (x1 ∨ ¬x2 ∨ ¬x3) ∧ (x1 ∨ x2 ∨ ¬x3)\nØyvind is a judge in the competition, responsible for verifying the quality of problem instances crafted by the other judges before the contest starts. Øyvind hates 3-SAT instances with less than eight clauses – as these are always satisfiable they provide no real challenge for the contestants. Therefore, he will deem such problem instances to be unsatisfactory. Whenever Øyvind encounters an instance with eight or more clauses he knows that it is a real challenge to figure out whether this instance is satisfiable or not – and therefore he will judge these problem instances to be satisfactory. Given an instance of 3-SAT, can you help find Øyvind’s judgement?\n",
        "input_text": "The input is a single instance of the 3-SAT problem. The first line is two space-separated integers: m (1 ≤ m ≤ 20), the number of clauses and n (3 ≤ n ≤ 20), the number of variables. Then m clauses follow, one clause per line. Each clause consists of 3 distinct space-separated integers in the range [−n, n] \\ {0}. For each clause, the three values correspond to the three literals in the clause. If the literal is negative, that means that the clause is satisfied if the corresponding variable is set to False, and if it is positive the clause is satisfied if the variable is set to True.\n",
        "output_text": "Print “satisfactory” on a single line if Øyvind finds the 3-SAT instance to be satisfactory, and “unsatisfactory” otherwise.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 271.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "84": {
        "problem_text": "세준이와 세비는 온라인 게임을 즐겨한다. 이 온라인 게임에서는 군대를 서로 키울 수 있다. 세준이는 N명의 병사를 키웠고, 세비는 M명의 병사를 키웠다.\n이제 서로 전쟁을 하려고 한다.\n전쟁은 여러 번의 전투로 이루어진다. 각 전투에서 살아있는 병사중 제일 약한 병사가 죽는다. 만약 제일 약한 병사가 여러 명이고, 제일 약한 병사가 모두 같은 편에 있다면, 그 중에 한 명이 임의로 선택되어 죽는다. 하지만, 제일 약한 병사가 여러 명이고, 양 편에 모두 있다면, 세비의 제일 약한 병사 중 한 명이 임의로 선택되어 죽는다.\n전쟁은 한 명의 병사를 제외하고 모두 죽었을 때 끝난다. 전쟁의 승자를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 100보다 작거나 같다. 각 테스트 케이스는 다음과 같이 이루어져 있다. 첫째 줄에 N과 M이 들어오고, 둘째 줄에는 세준이의 병사들의 힘이 들어오고, 셋째 줄에는 세비의 병사들의 힘이 들어온다. 힘은 정수이고, 이 값이 클수록 강하고, 작을수록 약하다.\n각 테스트 케이스는 줄 바꿈으로 구분되어 있다.\n",
        "output_text": "각 테스트 케이스에 대해서 한 줄에 하나씩 차례대로 승자를 출력한다. 세준이가 이기면 S를 세비가 이기면 B를 둘다 아닐 경우에는 C를 출력한다.\n",
        "memory_median": 2708.0,
        "time_median": 84.0,
        "length_median": 625.0,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "85": {
        "problem_text": "상근이는 카약 대회를 개최했다. 대회는 전세계에 생중계되고, 위성이 경기장 전체를 촬영하고 있다. 상근이는 위성 사진을 바탕으로 실시간 순위를 계산하는 프로그램을 만들려고 한다.\n위성 사진은 R행 C열이다. 모든 줄의 첫 번째 글자는 'S'이고 출발선을 의미한다. 또, 마지막 글자는 'F'이고 이것은 결승선을 의미한다. 대회에 참가한 팀은 총 9팀이고, 각 팀은 1부터 9까지 번호가 매겨져 있다. 카약은 항상 열에 대해 연속하는 세 칸을 차지하며, 카약 번호로 표시한다. 마지막으로 물은 '.'로 나타나 있다.\n팀의 순위는 결승선으로부터 떨어진 거리로 측정한다. 가까울수록 순위가 높다. 만약, 두 팀이 결승선과 떨어진 거리가 같다면, 같은 등수이다.\n",
        "input_text": "첫째 줄에 R과 C가 주어진다. 다음 R개 줄에는 '.', 'S', 'F', '1'~'9'로 이루어진 위성 지도가 주어진다. 한 줄에는 최대 한 개의 카약만 있고, 위성 사진에 있는 카약은 항상 9개이다. (10 ≤ R, C ≤ 50)\n",
        "output_text": "출력은 총 9줄을 해야 한다. i번째 줄에는 i번 팀의 등수를 출력한다. (i=1~9)\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 826.5,
        "label": [
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "86": {
        "problem_text": "어떤 나라에는 N개의 도시가 있고, 각 도시는 1번부터 N번까지 번호가 붙어 있다. 또, 서로 다른 두 도시를 양방향으로 직접 연결하는 M개의 도로가 있다. 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다.\n1번 도시에서 N번 도시로 자동차를 이용하여 이동하려고 한다. 처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다.\n예를 들어, 이 나라에 다음 그림처럼 4개의 도시와 4개의 도로가 있다고 하자. 원 안에 있는 숫자는 도시의 번호, 원 옆에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 옆에 있는 숫자는 도로의 길이를 표시한 것이다. \n\n1번 도시에서 출발할 때 7리터의 기름을 넣고 그 기름으로 4번 도시까지 (3번 도시를 거쳐) 이동하면 총 비용은 35원이다. 만약 1번 도시에서 출발할 때 3리터의 기름을 넣고(3×5 = 15원) 3번 도시로 이동한 다음, 다시 3번 도시에서 4리터의 기름을 넣고(4×4 = 16원) 4번 도시에 도착하면 총 비용은 31원이다. 또 다른 방법으로 1번 도시에서 2리터의 기름을 넣고(2×5 = 10원) 2번 도시로 이동하여, 2번 도시에서 9리터의 기름을 넣고(9×2 = 18원) 1번과 3번 도시를 거쳐 4번 도시에 도착하면 총 비용은 28원이다.\n각 도시에 있는 주유소의 기름 가격과, 각 도로들의 길이를 입력으로 받아 1번 도시에서 N번 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 도시의 수와 도로의 수를 나타내는 정수 N(2 ≤ N ≤ 2,500)과 정수 M(1 ≤ M ≤ 4,000)이 주어진다. 다음 줄에 각 도시 주유소의 리터당 가격이 도시 번호 순서대로 N개의 자연수로 주어진다. 리터당 가격은 1 이상 2,500 이하의 자연수이다. 그 다음 M개의 줄 각각에 하나의 도로에 대한 정보가 세 개의 자연수로 주어지는데, 처음 두 개의 자연수는 도로가 연결하는 두 도시의 번호이며, 세 번째 자연수는 도로의 길이이다. 도로의 길이는 1 이상 2,500 이하의 자연수이다. 한 쌍의 도시를 연결하는 도로는 최대 하나만 존재한다. 임의의 도시에서 다른 임의의 도시로 도로들을 이용하여 이동할 수 있는 방법이 항상 존재한다. \n",
        "output_text": "표준 출력으로 1번 도시에서 N번 도시로 가는 최소 비용을 출력한다.\n",
        "memory_median": 105480.0,
        "time_median": 628.0,
        "length_median": 1445.0,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "87": {
        "problem_text": "세 개의 단어가 주어졌을때, 꿍은 첫 번째 단어와 두 번째 단어를 섞어서 세 번째 단어를 만들 수 있는지 궁금해졌다. 첫 번째와 두 번째 단어는 마음대로 섞어도 되지만 원래의 순서는 섞여서는 안 된다. 다음과 같은 경우를 생각해보자.\n\n첫 번째 단어 : cat\n두 번째 단어 : tree\n세 번째 단어 : tcraete\n\n보면 알 수 있듯이, 첫 번째 단어와 두 번째 단어를 서로 섞어서 세 번째 단어를 만들 수 있다. 아래와 같이 두 번째 예를 들어보자.\n\n첫 번째 단어 : cat\n두 번째 단어 : tree\n세 번째 단어 : catrtee\n\n이 경우 역시 가능하다. 그렇다면 \"cat\"과 \"tree\"로 \"cttaree\"를 형성하는건 불가능하다는걸 눈치챘을 것이다.\n",
        "input_text": "입력의 첫 번째 줄에는 1부터 1000까지의 양의 정수 하나가 주어지며 데이터 집합의 개수를 뜻한다. 각 데이터집합의 처리과정은 동일하다고 하자. 각 데이터집합에 대해, 세 개의 단어로 이루어져 있으며 공백으로 구분된다. 모든 단어는 대문자 또는 소문자로만 구성되어 있다. 세 번째 단어의 길이는 항상 첫 번째 단어와 두 번째 단어의 길이의 합이며 첫 번째 단어와 두 번째 단어의 길이는 1~200이다.\n",
        "output_text": "각 데이터집합에 대해 다음과 같이 출력하라.\n만약 첫 번째 단어와 두 번째 단어로 세 번째 단어를 형성할 수 있다면\n\r\nData set n: yes\n과 같이 출력하고 만약 아니라면\n\r\nData set n: no\n과 같이 출력하라. 물론 n은 데이터집합의 순번으로 바뀌어야 한다. 아래의 예제 출력을 참고하라.\n",
        "memory_median": 2144.0,
        "time_median": 10.0,
        "length_median": 1038.5,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "88": {
        "problem_text": "각고의 노력 끝에 찬민이는 2014 Google Code Jam World Finals에 진출하게 되었다. 구글에서 온 초대장을 받고 기뻐했던 것도 잠시, 찬찬히 읽어보던 찬민이는 중요한 사실을 알아차렸다. 최근의 대세에 힘입어 구글 역시 대기업답게 비용 감축에 열을 내고 있었던 것이다.\n초대장 내용에 의하면 구글은 찬민에게 최대 M원까지의 비용만을 여행비로써 부담해주겠다고 한다. 인천에서 LA행 직항 한 번 끊어주는게 그렇게 힘드냐고 따지고도 싶었지만, 다가올 결승 대회를 생각하면 대회 외적인 곳에 마음을 쓰고 싶지 않은 것 또한 사실이었다. 그래서 찬민은 인천에서 LA까지 M원 이하로 사용하면서 도착할 수 있는 가장 빠른 길을 차선책으로 택하기로 하였다.\n각 공항들간 티켓가격과 이동시간이 주어질 때, 찬민이 인천에서 LA로 갈 수 있는 가장 빠른 길을 찾아 찬민의 대회 참가를 도와주자.\n",
        "input_text": "입력 파일의 첫 번째 줄에 테스트 케이스의 수를 의미하는 자연수 T가 주어진다. T는 항상 1이다. 그 다음에는 T개의 테스트 케이스가 주어진다.\n각 테스트 케이스의 첫 줄에는 공항의 수 N (2 ≤ N ≤ 100), 총 지원비용 M (0 ≤ M ≤ 10,000), 티켓정보의 수 K (0 ≤ K ≤ 10,000)가 공백으로 구분되어 주어진다. 이어서 K개의 줄에 걸쳐 각 티켓의 출발공항 u, 도착공항 v (1 ≤ u, v ≤ N, u ≠ v), 비용 c (1 ≤ c ≤ M, 정수), 그리고 소요시간 d (1 ≤ d ≤ 1,000) 가 공백으로 구분되어 주어진다. 인천은 언제나 1번 도시이고, LA는 언제나 N번 도시이다\n",
        "output_text": "각 테스트 케이스당 한 줄에 찬민이 LA에 도착하는 데 걸리는 가장 짧은 소요시간을 출력한다.\n만약, LA에 도착할 수 없는 경우 \"Poor KCM\"을 출력한다.\n",
        "memory_median": 10876.0,
        "time_median": 538.0,
        "length_median": 1604.0,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "89": {
        "problem_text": "세현이의 인생의 목표는 1분 1초 모든 순간 수학과 함께 살아가는 것이다. 그렇기 때문에 매일 수학을 생각하면서 살아가고 있다. 세현이는 밥을 먹을 때도 쌀알의 수를 계산하여 칼로리를 바로 계산하고 한걸음 한걸음 보폭을 계산하여 자신의 활동량을 확인하며 인생의 목표를 실행하며 살아가고 있다.  그런 세현이는 매일 학교를 가면서 지나가는 길에도 수학을 적용시키고 싶었다.\n세현이네 집에서 학교까지 가는 길은 N x N 크기의 바둑판과 같다. 그리고 각 블록은 1x1 정사각형으로 구분 지을 수 있다. 세현이는 그 블록마다 숫자와 연산자가 존재한다고 생각해서 임의의 숫자와 연산자를 각 블록에 넣어 바둑판을 만들었다.\n세현이는 학교에서 집으로 가는 경로에서 만나는 숫자와 연산자의 연산 결과의 최댓값과 최솟값을 구하려고 한다. 세현이는 항상 자신의 집 (1, 1)에서 학교 (N, N)까지 최단거리로 이동한다. 최단거리로 이동하기 위해서는 오른쪽과 아래쪽으로만 이동해야 한다.\n\n위와 같이 N = 5 인 5 x 5 바둑판을 만들었다고 해보자.\n그림 1의 경로를 통해 집(1, 1)에서 학교(N, N)까지 어떻게 연산이 되는지 확인해보자. 경로에서 만나는 연산자들의 우선순위는 고려하지 않는다.\n\n 5 → × → 4 = 20\n 20 → + → 5 = 25\n 25 → ×→ 5 = 125\n 125 → + → 2 = 127\n\n그림 1은 최댓값을 가지는 경로이며 127이라는 최댓값을 얻을 수 있다.\n그리고 위와 같이 연산하여 그림 2의 경로를 통해서 최솟값으로 3을 얻을 수 있다.\n세현이는 이 길을 걸으면서 최댓값과 최솟값을 암산하다가 교통사고를 당해 현재 인하대학교 병원에 입원했다. 아픈 세현이를 위해 최댓값과 최솟값을 구해주자.\n",
        "input_text": "첫 번째 줄에는 지도의 크기 N이 주어진다. (3 ≤ N ≤ 5, N은 홀수) \n그 다음 N 줄에는 N개의 숫자 또는 연산자가 빈칸을 사이에 두고 주어지며, 세현이네 집 (1, 1)과 학교 (N, N)는 반드시 숫자로 주어진다.\n그리고 숫자 다음에는 연산자, 연산자 다음에는 숫자가 나오도록 주어진다. 주어지는 숫자는 0이상 5이하의 정수, 연산자는 (‘+’, ‘-’, ‘*’) 만 주어진다.\n",
        "output_text": "연산 결과의 최댓값과 최솟값을 하나의 공백을 두고 출력한다. 연산자 우선순위는 고려하지 않는다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1408.5,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "90": {
        "problem_text": "우주비행이 꿈이였던 진우는 음식점 '매일매일싱싱'에서 열심히 일한 결과 달 여행에 필요한 자금을 모두 마련하였다! 지구와 우주사이는 N X M 행렬로 나타낼 수 있으며 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료의 양이다.\n[예시]\n\n진우는 여행경비를 아끼기 위해 조금 특이한 우주선을 선택하였다. 진우가 선택한 우주선의 특징은 아래와 같다.\n1. 지구 -> 달로 가는 경우 우주선이 움직일 수 있는 방향은 아래와 같다.\n\n2. 우주선은 전에 움직인 방향으로 움직일 수 없다. 즉, 같은 방향으로 두번 연속으로 움직일 수 없다.\n진우의 목표는 연료를 최대한 아끼며 지구의 어느위치에서든 출발하여 달의 어느위치든 착륙하는 것이다.\n최대한 돈을 아끼고 살아서 달에 도착하고 싶은 진우를 위해 달에 도달하기 위해 필요한 연료의 최소값을 계산해 주자.\n",
        "input_text": "첫줄에 지구와 달 사이 공간을 나타내는 행렬의 크기를 나타내는 N, M (2 ≤ N, M ≤ 1000)이 주어진다.\n다음 N줄 동안 각 행렬의 원소 값이 주어진다. 각 행렬의 원소값은 100 이하의 자연수이다.\n",
        "output_text": "달 여행에 필요한 최소 연료의 값을 출력한다.\n",
        "memory_median": 17764.0,
        "time_median": 148.0,
        "length_median": 1201.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "91": {
        "problem_text": "n개의 정점으로 이루어진 트리가 있다. 이 트리의 각 정점을 색칠하려고 한다. 색칠을 할 때에는 1, 2, 3, …, n번 색깔 중에 하나로 색칠하여야 한다. 각 색깔을 사용하여 한 개의 정점을 색칠할 때마다 1, 2, …, n의 비용이 든다. 즉, i번 색깔로 한 개의 정점을 색칠하면 i만큼의 비용이 든다는 것이다.\n또한 정점에 색칠을 할 때에, 주어진 트리 상에서 인접해 있는 서로 다른 두 정점은 서로 다른 색깔로 칠해야 한다. 이를 만족하면서, 전체 정점을 색칠하는데 드는 총 비용을 최소화 하려 한다. 최소 비용을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 정점 및 색깔의 개수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n-1개의 줄에는 각 줄에 두 개의 정수로 주어진 트리 상에서 연결되어 있는 두 정점의 번호가 주어진다.\n",
        "output_text": "첫째 줄에 최소 비용을 출력한다.\n",
        "memory_median": 16712.0,
        "time_median": 136.0,
        "length_median": 1049.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "92": {
        "problem_text": "한 생물학자가 새로 발견된 짚신벌레 종의 생태에 대해 연구하고 있다. 매우 번식력이 강하다고 알려진 이 종은 아래와 같은 특징을 가지고 있다.\n무성 생식을 한다.\n\n태어난 이후 a일째 되는 날 성체가 된다.\n성체가 된 날부터 매일 한 마리씩 새로운 개체를 만들어낸다: 성체가 되자마자 첫 개체를 만들어내고, 그 이후로 하루가 지날 때마다 새로운 개체를 하나씩 만들어낸다. 새로운 개체 역시 태어난 이후로 a일째 되는 날부터 성체가 되어 새로운 개체를 만든다.\n태어난 이후로 b일째 되는 순간부터는 새로운 개체를 더 이상 만들지 않는다. 태어난 지 a일째 날부터 b일째 되는 날의 전날까지 새로운 개체를 만들어내므로 일생동안 총 b-a 마리의 개체를 만들어낸다.\n태어난 이후로 d일째 되는 순간 죽는다.\n\n아래는 a=2, b=4, d=6일 때 수조에 새로 태어난 짚신벌레 한 마리를 넣고 매일 관찰한 결과를 기록한 것이다. 괄호 안의 숫자들은 수조 안의 짚신벌레들이 각각 태어난 이후 며칠이 되었는지를 나타내는 정수이다.\n\n태어난 날: (0) - 새로운 개체를 집어넣음\n1일째 되는 날: (1) - 짚신벌레가 자람\n2일째 되는 날: (2, 0) - 짚신벌레가 태어난 지 2일째가 되므로 성체가 되고 새 개체를 만들어 냄\n3일째 되는 날: (3, 1, 0) - 2일째 성체가 된 짚신벌레가 오늘도 새 개체를 하나 만들어 냄\n4일 째 되는 날: (4, 2, 1, 0) - 2일째 되는 날 만들어진 짚신벌레가 새로운 개체를 만들어 냄 (처음에 넣은 짚신벌레는 새 개체를 만들어내지 못함)\n5일 째 되는 날: (5, 3, 2, 1, 0, 0)\n6일 째 되는 날: (4, 3, 2, 1, 1, 0, 0) - 처음에 넣은 개체는 죽는다.\n\n6일 째 되는 날 수조안에 살아있는 짚신벌레는 총 7마리가 된다.\n짚신벌레의 번식 정보 a, b, d에 대하여, 새로 태어난 짚신벌레 한 마리를 수조 안에 넣은 이후 N일째 되는 날 살아있는 짚신벌레 수를 1000으로 나눈 나머지를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 a, b, d, N을 나타내는 네 정수가 빈칸 하나를 사이에 두고 차례로 주어진다. 단, 0＜a＜b＜d ≤ 10,000이고, 1 ≤ N ≤ 1,000,000이다.\n",
        "output_text": "첫째 줄에, 수조에 짚신벌레 한 마리를 넣은 지 N일째 되는 날 수조에 살아 있는 짚신벌레의 수를 1000으로 나눈 나머지를 출력한다.\n",
        "memory_median": 5928.0,
        "time_median": 12.0,
        "length_median": 560.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "93": {
        "problem_text": "여자친구가 없는 남자 n명과 남자친구가 없는 여자 m명을 불러 모아서 이성 친구를 만들어 주기로 하였다. 하지만 아무렇게나 해줄 수는 없고, 최대한 비슷한 성격의 사람들을 짝 지어 주기로 하였다.\n당신은 뭔가 알 수 없는 방법으로 각 사람의 성격을 수치화 하는데 성공하였다. 따라서 각 사람의 성격은 어떤 정수로 표현된다. 이와 같은 성격의 수치가 주어졌을 때, 우선 최대한 많은 커플을 만들고, 각 커플을 이루는 두 사람의 성격의 차이의 합이 최소가 되도록 하려 한다. 남자-여자 커플만 허용된다.\n",
        "input_text": "첫째 줄에 n, m(1 ≤ n, m ≤ 1,000)이 주어진다. 다음 줄에는 n명의 남자들의 성격이 주어진다. 그 다음 줄에는 m명의 여자들의 성격이 주어진다. 성격은 1,000,000이하의 자연수이다.\n",
        "output_text": "첫째 줄에 성격의 차이의 합의 최솟값을 출력한다.\n",
        "memory_median": 5944.0,
        "time_median": 4.0,
        "length_median": 881.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "94": {
        "problem_text": "하루 종일 내리는 비에 세상이 출렁이고 구름이 해를 먹어 밤인지 낮인지 모르는 어느 여름 날\n잠 들기 싫어 버티던 호석이는 무거운 눈꺼풀에 패배했다. 정신을 차려보니 바닥에는 격자 모양의 타일이 가득한 세상이었고, 각 타일마다 알파벳 소문자가 하나씩 써있다더라. 두려움에 가득해 미친듯이 앞만 보고 달려 끝을 찾아 헤맸지만 이 세상은 끝이 없었고, 달리다 지쳐 바닥에 드러누우니 하늘에 이런 문구가 핏빛 구름으로 떠다니고 있었다.\n\n이 세상은 N행 M열의 격자로 생겼으며, 각 칸에 알파벳이 써있고 환형으로 이어진다. 왼쪽 위를 (1, 1), 오른쪽 아래를 (N, M)이라고 하자.\n너는 아무 곳에서나 시작해서 상하좌우나 대각선 방향의 칸으로 한 칸씩 이동할 수 있다. 이 때, 이미 지나 왔던 칸들을 다시 방문하는 것은 허용한다.\n시작하는 격자의 알파벳을 시작으로, 이동할 때마다 각 칸에 써진 알파벳을 이어 붙여서 문자열을 만들 수 있다.\n이 곳의 신인 내가 좋아하는 문자열을 K 개 알려줄 터이니, 각 문자열 마다 너가 만들 수 있는 경우의 수를 잘 대답해야 너의 세계로 돌아갈 것이다.\n경우의 수를 셀 때, 방문 순서가 다르면 다른 경우이다. 즉, (1,1)->(1,2) 로 가는 것과 (1,2)->(1,1) 을 가는 것은 서로 다른 경우이다.\n\n호석이는 하늘을 보고서 \"환형이 무엇인지는 알려달라!\" 며 소리를 지르니 핏빛 구름이 흩어졌다가 모이며 아래와 같은 말을 그렸다.\n\n너가 1행에서 위로 가면 N 행으로 가게 되며 반대도 가능하다.\n너가 1열에서 왼쪽으로 가면 M 열로 가게 되며 반대도 가능하다.\n대각선 방향에 대해서도 동일한 규칙이 적용된다.\n하늘에 아래와 같은 그림을 구름으로 그려줄 터이니 이해해 돕도록 하여라.\n예를 들어서, 너가 (1, 1)에서 위로 가면 (N, 1)이고, 왼쪽으로 가면 (1, M)이며 왼쪽 위 대각선 방향으로 가면 (N, M)인 것이다.\n\n\n세상을 이루는 격자의 정보와, K 개의 문자열이 주어졌을 때, 호석이가 대답해야 하는 정답을 구해주도록 하자.\n",
        "input_text": "첫번째 줄에 격자의 크기 N, M과 신이 좋아하는 문자열의 개수 K 가 주어진다.\n다음에 N개의 줄에 걸쳐서 M개의 알파벳 소문자가 공백없이 주어진다. 여기서의 첫 번째 줄은 1행의 정보이며, N 번째 줄은 N행의 정보이다.\n이어서 K개의 줄에 걸쳐서 신이 좋아하는 문자열이 주어진다. 모두 알파벳 소문자로 이루어져 있다.\n",
        "output_text": "K개의 줄에 걸쳐서, 신이 좋아하는 문자열을 만들 수 있는 경우의 수를 순서대로 출력한다.\n",
        "memory_median": 22112.0,
        "time_median": 100.0,
        "length_median": 1192.0,
        "label": [
            0,
            0,
            1,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "95": {
        "problem_text": "N개의 스위치와 N개의 전구를 가진 하나의 스위칭 박스가 있다. 이 박스의 왼편에는 스위치가 있고, 오른편에는 전구가 달려있다. 모든 스위치와 전구들은 1에서부터 N까지의 번호를 가지며 같은 번호의 스위치와 전구는 전선으로 서로 연결되어 있다.\n\n하나의 스위치를 누르면 그 스위치와 연결된 전구에 불이 들어오게 된다. 두 개 이상의 스위치를 같이 누르는 경우, 전선이 서로 만나면 만난 전선에 연결된 전구들의 불은 켜지지 않는다.\n위 그림에서 1번과 4번의 스위치를 같이 누르면 1번과 4번의 전구에는 불이 켜지지만, 1번과 2번의 스위치를 같이 누르면 1번과 2번 전구의 불은 켜지지 않는다. 1번과 3번 그리고 5번 스위치를 같이 누르면 전선이 만나는 1번과 5번 전구는 켜지지 않지만 3번 전구는 켜지게 된다.\n여러분이 할 일은 가장 많은 전구가 켜지도록 스위치를 누르는 것이다. 위 그림에서는 3번과 4번 그리고 5번 스위치를 누르는 경우와 1번과 3번 그리고 4번을 누르는 경우에 세 개의 전구가 켜지게 되고, 이 두 가지 경우가 가장 많은 전구가 켜지는 경우이다.\n스위치의 번호순서와 전구의 번호순서가 주어질 때, 어떤 스위치를 누르면 가장 많은 전구가 켜지는지를 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에는 스위치의 수(전구의 수)를 나타내는 정수 N (1 ≤ N ≤ 10,000)이 주어진다. 두 번째 줄에는 N개의 스위치 번호들이 위에서부터 순서대로 빈칸을 사이에 두고 주어진다. 세 번째 줄에는 N개의 전구 번호들이 위에서부터 순서대로 빈칸을 사이에 두고 주어진다.\n",
        "output_text": "첫 번째 줄에는 가장 많은 전구가 켜지게 하는 스위치의 수를 출력한다. 두 번째 줄에는 눌러야 하는 스위치의 번호를 오름차순(번호가 커지는 순서)으로 빈칸을 사이에 두고 하나의 줄에 출력한다. 단, 두 번째 줄에 출력할 수 있는 답이 두 가지 이상일 때에는 그 중 한 가지만 출력한다.\n",
        "memory_median": 2352.0,
        "time_median": 8.0,
        "length_median": 1169.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "96": {
        "problem_text": "철수는 한양대학교 도서관에서 책을 빌려놓고 까먹고 있다가 며칠 후 책을 반납해야 한다는 사실을 깨달았다. 남은 기간 동안 최대한 많은 페이지를 읽고 연체없이 반납하고 싶다.\n빌린 책은 여러 챕터로 구성된 에세이집인데 챕터들은 서로 독립적이다. 즉, 어느 챕터를 읽기 위해 다른 챕터를 먼저 읽어야 할 필요가 없다. 철수는 중간에 관두는 것을 못견디는 성격이라, 한 챕터를 읽기 시작하면 끝까지 봐야한다. \n남은 기간 N일과, 책의 각 챕터 당 그 챕터를 전부 읽는데 소요되는 일 수와 페이지 수가 주어질 때, N일간 읽을 수 있는 최대 페이지 수를 구하는 프로그램을 작성하라.\n",
        "input_text": "첫째 줄에 N(1 ≤ N ≤ 200)과 챕터의 수 M(1 ≤ M ≤ 20)이 주어진다. 둘째 줄부터 각 챕터 당 읽는데 소요되는 일 수와 페이지 수가 주어진다. 소요되는 일 수는 20보다 작거나 같은 자연수이고, 페이지 수는 300보다 작거나 같은 자연수이다.\n",
        "output_text": "읽을 수 있는 최대 페이지 수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 561.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "97": {
        "problem_text": "석원이는 자신의 현관문에 비밀번호 기계를 설치했다. 그 기계의 모양은 다음과 같다.\n\n지나가던 석원이 친구 주희는 단순한 호기심에 저 비밀번호를 풀고 싶어한다. 이때 주희는 바닥에 떨어져 있는 힌트 종이를 줍게 된다. 이 종이에는 석원이가 비밀번호를 만들 때 사용했던 조건이 적혀 있다. 이제 주희는 이 조건을 가지고, 석원이 집의 가능한 비밀번호의 전체 개수를 알고 싶어 한다. 현재 컴퓨터를 사용할 수 없는 주희는 당신에게 이 문제를 부탁했다. 석원이의 힌트 종이는 다음과 같다.\n\n비밀번호의 길이는 N이다.\n비밀번호는 위 그림에 나온 번호들을 눌러서 만든다.\n비밀번호에서 인접한 수는 실제 위 기계의 번호에서도 인접해야 한다.\n\n(ex. 15 라는 비밀번호는 불가능하다. (1과 5는 인접하지 않는다. ) 하지만 1236이라는 비밀번호는 가능하다.)\n",
        "input_text": "첫 번째 줄에 Test case의 수 T가 주어진다. 그리고 각각의 케이스마다 입력으로 첫 번째 줄에 비밀번호의 길이 N이 주어진다.( 1 <= N <= 1,000 )\n",
        "output_text": "각각의 Test case에 대해서 조건을 만족하는 비밀번호의 개수를 출력하라. 단, 수가 매우 커질 수 있으므로 비밀번호의 개수를 1,234,567으로 나눈 나머지를 출력하라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1083.0,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "98": {
        "problem_text": "높이가 a1, a2, ..., an인 나무 n개를 전기톱을 이용해서 자르려고 한다.\ni번 나무에 전기톱을 사용할 때 마다 그 나무의 높이는 1만큼 감소한다. 전기톱은 사용할 때 마다 충전해야 한다. 전기톱을 충전하는 비용은 완전히 자른 나무의 번호에 영향을 받는다. 즉, 높이가 0이 되어버린 나무의 번호에 영향을 받는다. 완전히 잘려진 나무의 번호 중 최댓값이 i이면, 전기톱을 충전하는 비용은 bi이다. 완전히 잘려진 나무가 없다면 전기톱은 충전할 수가 없다. 가장 처음에 전기톱은 충전되어져 있다.\n나무의 높이 ai와 각각의 나무에 대한 충전 비용 bi가 주어졌을 때, 모든 나무를 완전히 자르는데 (높이를 0으로 만드는데) 필요한 충전 비용의 최솟값을 구하는 프로그램을 작성하시오. \n",
        "input_text": "첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄에는 a1, a2, ..., an이, 셋째 줄에는 b1, b2, ..., bn이 주어진다. (1 ≤ ai ≤ 109, 0 ≤ bi ≤ 109)\na1 = 1이고, bn = 0이며, a1 < a2 < ... < an, b1 > b2 > ... > bn을 만족한다.\n",
        "output_text": "나무를 완전히 자르는 충전 비용의 최솟값을 출력한다.\n",
        "memory_median": 4372.0,
        "time_median": 32.0,
        "length_median": 1183.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "99": {
        "problem_text": "아래 그림과 같이 N개의 회전이 가능한 숫자 나사가 아래위로 연결되어 있다. 가장 위에 있는 숫자나사는 숫자나사 1이고 가장 아래에 있는 숫자나사는 숫자나사 N이다. 모든 숫자나사는 각각 10개의 면을 가지고 있고, 각 면에는 오른쪽 방향으로 0, 1, 2, 3, …, 9까지의 숫자가 하나씩 순서대로 적혀 있다. 하나의 숫자나사를 왼쪽으로 회전 시키면, 이 나사보다 아래에 위치한 모든 나사는 같이 따라서 돌게 되지만, 나사를 오른쪽으로 회전시키면, 다른 나사는 함께 돌지는 않는다. 정면에서 보아 위에서부터 아래쪽으로 숫자를 읽어 내려간다고 할 때, 현재의 상태에서 가장 적은 칸수의 움직임으로 원하는 숫자를 만들기 위한 방법을 출력하는 프로그램을 작성하라.\n예를 들어 세 개의 숫자나사가 주어졌을 때, 정면에서 보는 현재 상태가 326이고 원하는 상태는 446이라면 최소 회전 칸수는 4이다. 먼저 숫자나사 1을 왼쪽으로 한 칸 돌리면 437이 되고, 숫자나사 2를 역시 왼쪽으로 한 칸 돌리면 448이 되며, 마지막으로 숫자나사 3을 오른쪽으로 두 칸 돌리면 446이 된다.\n\n",
        "input_text": "첫째 줄에는 숫자나사의 개수 N이 주어지고, 둘째 줄에는 현재의 상태가, 셋째 줄에는 원하는 상태가 주어진다. N은 3 이상이고 10,000 이하이다.\n",
        "output_text": "첫째 줄에는 현재 상태에서 원하는 상태로 도달하는데 필요한 최소 회전 칸수를 출력한다. 다음 줄부터는 회전 순서대로 각 줄에 하나의 숫자나사 번호와 회전 칸수를 빈칸을 사이에 두고 출력한다. 회전 칸수는 왼쪽을 기준으로 하여 출력한다. 만일 왼쪽으로 4칸 회전한다면 4를, 오른쪽으로 3칸 회전한다면 -3을 출력한다. 답이 여러 개이면 그 중에 하나만 출력한다.\n",
        "memory_median": 3302.0,
        "time_median": 4.0,
        "length_median": 1418.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "100": {
        "problem_text": "무한 수열 A는 다음과 같다.\n\nAi = 1 (i ≤ 0)\nAi = A⌊i/P⌋-X + A⌊i/Q⌋-Y (i ≥ 1)\n\nN, P, Q, X, Y가 주어질 때, AN을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 5개의 정수 N, P, Q, X, Y가 주어진다.\n",
        "output_text": "첫째 줄에 AN을 출력한다.\n",
        "memory_median": 329836.0,
        "time_median": 4834.0,
        "length_median": 460.5,
        "label": [
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "101": {
        "problem_text": "N(1 ≤ N ≤ 31)자리의 이진수가 있다. 이러한 이진수 중에서, L(1 ≤ L ≤ N)개 이하의 비트만 1인 것을 크기 순으로 나열했을 때, I번째로 나오는 이진수를 구해내는 프로그램을 작성하시오. 이진수는 0으로 시작할 수도 있다.\n",
        "input_text": "첫째 줄에 세 정수 N, L, I가 주어진다. I번째 이진수가 있는 입력만 주어진다.\n",
        "output_text": "첫째 줄에 답을 출력한다.\n",
        "memory_median": 2000.0,
        "time_median": 0.0,
        "length_median": 832.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "102": {
        "problem_text": "1부터 n까지 번호가 붙여진 n명의 병사들로 이루어진 군대의 지휘관이 있다. 이 지휘관은 앞으로의 전투를 위하여 n명의 병사들을 여러 개의 특공대로 나누고자 한다. 결속력과 사기를 높이기 위하여 각 특공대는 {i, i+1, ..., i+k}형태의 번호가 연속하는 병사들로 구성된다. \n각 병사 i의 전투력은 xi이다. 병사들 {i, i+1, ..., i+k}로 구성된 특공대의 전투력 x는 원래는 각 병사의 전투력의 합으로 계산되었다. 달리 말하면 x = xi + xi+1 + ... + xk이었다.\n그러나 여러 해의 영광스러운 승리를 통하여 특공대의 전투력을 다음과 같이 조정해야 하는 것으로 결론을 내렸다: 특공대의 조정된 전투력 x′는 등식 x′ = ax2 + bx + c로 계산한다. 여기서 a, b, c는 알려져 있는 계수들로서 a<0이고, x는 특공대의 원래 정의된 전투력이다.\n여러분이 할 일은 모든 특공대의 조정된 전투력의 합을 최대화하도록 병사들을 특공대로 나누는 것이다.\n예를 들어, 4명의 병사들이 있고, 각 병사의 전투력 x1 = 2, x2 = 2, x3 = 3, x4 = 4라 하자. 특공대의 조정된 전투력 등식에 있는 계수가 a=-1, b=10, c=-20이라 하자. 이러한 경우, 최적인 해는 병사들을 다음과 같이 세 개의 특공대로 나누는 것이다: 첫 번째 특공대는 병사 1과 2로 구성하고, 두 번째 특공대는 병사 3으로 구성하고, 세 번째 특공대는 병사 4로 구성한다. 이들 세 특공대의 원래의 전투력은 각각 4, 3, 4이고 조정된 전투력은 각각 4, 1, 4이다. 이렇게 나눌 때 조정된 전체 전투력은 각 특공대의 조정된 전투력의 합인 9이며, 이보다 더 좋은 해가 없음을 알 수 있다.\n",
        "input_text": "입력은 세 줄로 구성된다. 첫 번째 줄에 전체 병사들 수인 양의 정수 n이 주어진다. 두 번째 줄에 특공대의 조정된 전투력 계산 등식의 계수인 세 정수 a, b, c가 주어진다. 마지막 줄에 병사들 1, 2, ..., n의 전투력을 나타내는 n개의 정수 x1, x2, ..., xn이 공백을 사이에 두고 주어진다.\nn ≤ 1,000,000, -5 ≤ a ≤ -1, |b| ≤ 10,000,000, |c| ≤ 30,000,000, 1 ≤ xi ≤ 100\n",
        "output_text": "얻을 수 있는 최대의 조정된 전체 전투력을 나타내는 하나의 정수를 한 줄에 출력한다. \n",
        "memory_median": 41100.0,
        "time_median": 140.0,
        "length_median": 1324.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "103": {
        "problem_text": "요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.\nN과 K가 주어지면, 마지막으로 남는 사람의 번호를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000,000)\n",
        "output_text": "첫째 줄에 마지막으로 남는 사람의 번호를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 44.0,
        "length_median": 239.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "104": {
        "problem_text": "정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.\n\n1+1+1+1\n1+1+2\n1+2+1\n2+1+1\n2+2\n1+3\n3+1\n\n정수 n과 m이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. 단, 사용한 수의 개수는 m개 이어야 한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n과 m이 주어진다. n은 양수이며 1,000보다 작거나 같다. m도 양수이며, n보다 작거나 같다.\n",
        "output_text": "각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다. 단, 사용한 수의 개수는 m개 이어야 한다.\n",
        "memory_median": 9008.0,
        "time_median": 12.0,
        "length_median": 597.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "105": {
        "problem_text": "상근이는 건강을 위해 산책을 하려고 한다.\n상근이가 사는 마을은 아래 그림과 같이 가로 방향 도로가 (H+1)개, 세로 방향 도로가 (W+1)개가 바둑판 모양으로 배치되어 있다. 상근이네 집은 가장 왼쪽 위 교차로에 있으며, 이곳에서 산책을 시작한다.\n(a,b)는 위쪽에서 a번째, 왼쪽에서 b번째에 있는 교차로이다. 예를 들어, 상근이네 집은 교차로 (1,1)에 있다.\n\n상근이는 산책 경로가 매일 달라야 질리지 않고 산책을 할 수 있다고 생각한다. 따라서, (1,1)에서 (H,W)까지 H × W개 교차로에 오른쪽을 뜻하는 오 또는 아래를 뜻하는 아를 쓰고, 다음과 같은 규칙에 따라서 산책을 하기로 했다.\n교차로에 쓰여 있는 문자가 오라면, 이 문자를 지우고 아를 쓴다. 그 다음에 오른쪽으로 진행한다. 만약, 교차로에 쓰여 있는 문자가 아라면, 이 문자를 지우고 오를 쓴뒤, 아래로 진행한다.\n이렇게 산책을 하다가 가장 오른쪽이나 아래쪽 도로에 도착하면 산책을 종료한다.\n상근이는 이런 방법으로 산책을 계속 한다면, N번째 산책 경로가 어떻게 될지 궁금해졌다. H, W와 각 교차로에 써놓은 글자가 주어졌을 때, N번째 산책 경로를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 H, W, N이 주어진다. (1 ≤ H,W ≤ 1000, 1 ≤ N ≤ 107)\n둘째 줄부터 H개 줄에는 W개 정수가 주어진다. 이 정수는 상근이가 교차로에 써 놓은 문자의 정보이다. 0은 아래쪽을 의미하는 '아', 1은 오른쪽을 의미하는 '오'이다.\n",
        "output_text": "N번째 산책에서 산책을 종료하는 교차로가 (i,j)라고 할 때, i와 j를 공백으로 구분하여 출력한다.\n",
        "memory_median": 9840.0,
        "time_median": 92.0,
        "length_median": 948.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "106": {
        "problem_text": "욱제는 ‘삼’이란 음절을 참 좋아한다. 인삼, 홍삼, 해삼, 삼성, 이춘삼(李春森), 삼식이, 삼시세끼, ㄴㄴ 그거 안 삼, 삼과 죽음, 알았삼, 걷다보니 신천역 삼, 그리고 특히 일이삼을 좋아한다. 그래서 욱제는 3을 가지고 놀아보기로 했삼.\n3개 숫자(0, 1, 2)만 가지고 N자리 3의 배수를 만들어 보삼. 만드는 배수는 자연수 이삼. 0으로 시작하는 수는 만들 수 없는 수 이삼. 3의 배수가 몇 개나 나올 수 있삼?\n",
        "input_text": "N을 입력 받으삼 (1 ≤ N ≤ 33,333)\n",
        "output_text": "0, 1, 2만 가지고 만들 수 있는 N자리 3의 배수의 개수를 출력하삼. 숫자가 너무 커질 수 있으니까 답을 109+9(1,000,000,009)로 나눈 나머지를 출력하삼.\n",
        "memory_median": 2280.0,
        "time_median": 0.0,
        "length_median": 376.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "107": {
        "problem_text": "랜드 씨는 퇴직금으로 땅을 사서 목장을 지으려 한다.  그가 사려고 소개받은 땅은 직사각형이고 대부분 들판이지만, 여기저기에 베기 어려운 나무와 치울 수 없는 바위가 있다.\n그는 목장을 하나의 정사각형으로 최대한 크게 지으려 하는데, 그 안에 나무나 바위는 없어야 한다. \n땅의 세로 길이가 M미터, 가로 길이가 N미터일 때, 1미터 간격의 격자로 된 땅의 지도를 M x N행렬로 표현하자. \n이때, 행렬의 원소 0은 들판, 1은 나무 그리고 2는 돌을 의미한다.  랜드씨의 땅에서 지을 수 있는 가장 큰 정사각형 목장의 한 변의 크기 L을 출력하시오.\n",
        "input_text": "\r\nM N\r\nM x N 행렬\n\n1 <= M <= 1000\n1 <= N <= 1000\n\n",
        "output_text": "\r\nL\n",
        "memory_median": 9816.0,
        "time_median": 88.0,
        "length_median": 723.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "108": {
        "problem_text": "스타트링크에는 세명의 직원이 일을 하고 있다. 세 직원의 이름은 강호(A), 준규(B), 수빈(C) 이다.\n이 회사의 직원은 특별한 룰을 가지고 있는데, 바로 하루에 한 명만 출근한다는 것이다. 3일간의 출근 기록이 \"AAC\"라는 것은 처음 이틀은 A가 출근했고, 셋째 날엔 C만 출근했다는 뜻이다.\nA는 매일 매일 출근할 수 있다. B는 출근한 다음날은 반드시 쉬어야 한다. C는 출근한 다음날과 다다음날을 반드시 쉬어야 한다. 따라서, 모든 출근 기록이 올바른 것은 아니다. 예를 들어, B는 출근한 다음날 쉬어야 하기 때문에, \"BB\"는 절대로 나올 수 없는 출근 기록이다. \n출근 기록 S가 주어졌을 때, S의 모든 순열 중에서 올바른 출근 기록인 것 아무거나 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 출근 기록 S가 주어진다. S의 길이는 50을 넘지 않는다.\n",
        "output_text": "S의 모든 순열 중에서 올바른 출근 기록인 것을 하나만 출력한다. 만약, 올바른 출근 기록이 없는 경우에는 -1을 출력한다.\n",
        "memory_median": 5132.0,
        "time_median": 0.0,
        "length_median": 1284.0,
        "label": [
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "109": {
        "problem_text": "구사과국은 동전만 사용하고, 동전의 가치는 다음과 같다.\n1, 10, 25, 100, 1000, 2500, 10000, 100000, 250000, 1000000 ...\n즉, 식으로 표현하면 K ≥ 0를 만족하는 모든 K에 대해서, 가치가 10K인 동전과 25×100K인 동전이 있는 것이다.\n구사과국에 살고 있는 구사과는 초콜릿을 하나 구매해 5차원 세계로 이사가려고 한다. 초콜릿의 가격이 주어졌을때, 이를 구매하기 위해 필요한 동전 개수의 최솟값을 구해보자. 각 동전의 개수는 무한하고, 구매할 때는 정확하게 초콜릿의 가격만큼만 지불해야 한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄부터 T개의 줄에 초콜릿의 가격이 주어진다. 가격의 1015보다 작거나 같은 자연수이다.\n",
        "output_text": "총 T개의 줄에 각각의 테스트 케이스의 필요한 동전의 개수를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 686.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "110": {
        "problem_text": "상근날드에서 오랜만에 새로운 햄버거를 출시했다. 바로 레벨-L 버거이다. 레벨-L 버거는 다음과 같이 만든다.\n\n레벨-0 버거는 패티만으로 이루어져 있다.\n레벨-L 버거는 햄버거번, 레벨-(L-1) 버거, 패티, 레벨-(L-1)버거, 햄버거번으로 이루어져 있다. (L ≥ 1)\n\n예를 들어, 레벨-1 버거는 'BPPPB', 레벨-2 버거는 'BBPPPBPBPPPBB'와 같이 생겼다. (B는 햄버거번, P는 패티)\n상도가 상근날드에 방문해서 레벨-N 버거를 시켰다. 상도가 햄버거의 아래 X장을 먹었을 때, 먹은 패티는 몇 장일까? 한 장은 햄버거번 또는 패티 한 장이다.\n",
        "input_text": "첫째 줄에 N과 X가 주어진다.\n",
        "output_text": "첫째 줄에 상도가 먹은 패티의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 836.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "111": {
        "problem_text": "3×N 크기의 벽을 2×1, 1×2 크기의 타일로 채우는 경우의 수를 구해보자.\n",
        "input_text": "첫째 줄에 N(1 ≤ N ≤ 1,000,000,000,000,000,000)이 주어진다.\n",
        "output_text": "첫째 줄에 경우의 수를 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1136.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "112": {
        "problem_text": "1번부터 N번까지의 학생들은 각각 블록들을 가지고 있다. 학생마다 최대 M개의 블록을 가지고 있을 수 있으며, 한 명의 학생이 가지고 있는 모든 블록들의 높이는 서로 다르다. 이 때 1번부터 N번까지의 학생들이 가진 블록을 차례대로 사용하여 바닥에서부터 쌓아올려 하나의 탑을 만들고자 한다.\n단, 어떤 학생의 블록은 사용하지 않아도 되며 한 학생당 최대 1개의 블록만을 사용할 수 있다.\n1번부터 N번까지의 학생들이 가지고 있는 블록들에 대한 정보가 주어졌을 때, 높이가 정확히 H인 탑을 만들 수 있는 경우의 수를 계산하는 프로그램을 작성하시오.\n예를 들어 N=3, M=3, H=5일 때, 각 학생마다 가지고 있는 블록들의 높이가 다음과 같다고 가정하자.\n\n1번 학생: 2, 3, 5\n2번 학생: 3, 5\n3번 학생: 1, 2, 3\n\n이 때, 탑의 높이가 정확히 5가 되도록 블록을 쌓는 경우로는 다음의 6가지가 존재한다. (블록을 사용하지 않는 경우는 X로 표시하였다.)\n\n",
        "input_text": "첫째 줄에 자연수 N, M, H가 공백을 기준으로 구분되어 주어진다. (1 ≤ N ≤ 50, 1 ≤ M ≤ 10, 1 ≤ H ≤ 1,000) 둘째 줄부터 N개의 줄에 걸쳐서 각 학생이 가진 블록들의 높이가 공백을 기준으로 구분되어 주어진다.\n단, 모든 블록의 높이는 1,000 이하의 자연수이며 한 명의 학생이 가지고 있는 모든 블록들의 높이는 서로 다르게 주어진다.\n",
        "output_text": "첫째 줄에 높이가 H인 탑을 만드는 경우의 수를 10,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 2224.0,
        "time_median": 0.0,
        "length_median": 968.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "113": {
        "problem_text": "팰린드롬(palindrome)이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 단어를 말한다. 'aba'나 'a'와 같은 단어는 팰린드롬이며, 'abaccbcb'나 'anavolimilana'와 같은 단어는 팰린드롬이 아니다.\n승수는 주어진 문자열의 부분수열 중 팰린드롬이 되는 부분수열의 개수를 알고싶어한다. (공집합은 포함하지 않는다)\n예를들어 'abb' 의 부분수열은 {'a'}, {'b'}, {'b'}, {'ab'}, {'ab'}, {'bb'}, {'abb'} 이고 이 가운데 팰린드롬은 {'a'}, {'b'}, {'b'}, {'bb'} 으로 4개 이다. \n문자열이 주어졌을 때, 팰린드롬이 되는 부분수열의 개수를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 길이가 1000을 넘지 않는 문자열 S 가 주어진다. 문자열 S는 알파벳 소문자로만 이루어져 있다.\n",
        "output_text": "주어진 문자열 S 의 부분수열 중 팰린드롬이 되는 부분수열의 개수를 10,007 로 나눈 나머지를 출력한다.\n",
        "memory_median": 5964.0,
        "time_median": 8.0,
        "length_median": 688.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "114": {
        "problem_text": "평면상에 있는 원의 둘레에 100개의 점이 일정한 간격으로 시계방향으로 번호가 1, 2, ... 100으로 붙여져 있다. 이 점들을 끝점으로 갖는 N개의 선분(원의 현)이 입력으로 주어질 때, 이들중에서 서로 교차하지 않는 것들을 최대한 많이 찾아서 그 개수를 출력하는 프로그램을 작성하라.\n단, 1 ≤ N ≤ 50이고, 주어진 각 점은 많아야 한 현의 끝점이 될 수 있다.\n",
        "input_text": "첫 번째 줄은 주어지는 현의 개수 N이고, 다음의 N줄은 각 현의 양끝점의 번호가 주어진다.\n",
        "output_text": "구한 현의 개수를 출력한다.\n",
        "memory_median": 2068.0,
        "time_median": 0.0,
        "length_median": 655.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "115": {
        "problem_text": "준규는 새 RPG 게임을 시작했다. 이 게임에서 캐릭터는 2가지 스탯을 가지고 있다. 하나는 힘(STR)이고, 다른 하나는 지력(INT)이다. 캐릭터를 생성했을 때, 두 스탯은 모두 1이다.\n게임에는 총 N개의 퀘스트가 있다. i번째 퀘스트를 깨려면 캐릭터의 힘이 STR[i]보다 크거나 같거나, 지력이 INT[i]보다 크거나 같아야 한다. 이 퀘스트를 깨면, 스탯을 올릴 수 있는 포인트를 PNT[i]개 만큼 얻게 된다.\n모든 퀘스트는 단 한 번만 깰 수 있으며, 퀘스트를 깨는 순서는 준규가 마음대로 정할 수 있다. 또, 퀘스트 보상으로 얻게되는 포인트로 준규 마음대로 스탯을 올릴 수 있다.\n준규가 깰 수 있는 퀘스트 개수의 최댓값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 퀘스트의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다.\n둘째 줄부터 N개의 줄에 STR[i], INT[i], PNT[i]가 주어진다. 이 숫자는 모두 1,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 준규가 깰 수 있는 퀘스트 개수의 최댓값을 출력한다.\n",
        "memory_median": 5940.0,
        "time_median": 84.0,
        "length_median": 1146.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "116": {
        "problem_text": "KOI 무선통신사는 직선의 통신라인 상에 기지국들을 설치하여 주변의 주요 건물들을 모두 통신범위에 포함 시키고자 한다. 각 기지국의 통신범위는 기지국을 중심으로 하고 밑변이 통신라인과 평행한 정사각형이고, 이 정사각형의 한 변의 길이를 통신폭이라 한다. 기지국들의 총 설치비용은 각 기지국의 통신폭의 합이고, 기지국의 수와는 무관하다. \n평면상에 주요건물들의 위치가 주어졌을 때, 기지국들을 설치하여 모든 주요 건물을 통신범위에 포함하는 최소의 총 설치비용을 구하는 프로그램을 작성하시오. 통신라인은 x-축과 일치하고 건물들의 위치좌표는 정수이다. 통신라인 상에는 건물이 위치하지 않으며, 모든 건물들의 위치는 서로 다르다.\n다음 그림의 예를 보면, 첫 번째 기지국의 위치는 (-2, 0) 이고, 통신폭이 4인 정사각형의 통신범위로 세 개의 건물을 포함한다. 두 번째 기지국의 위치는 (2, 0)이고, 통신폭이 2인 정사각형의 통신범위로 두 개의 건물을 포함한다. 세 번째 기지국의 위치는 (6.5, 0) 이고, 통신폭이 3인 정사각형의 통신범위로 두 개의 건물을 포함한다.\n\n",
        "input_text": "첫째 줄에는 건물의 개수 N이 주어지고 (1 ≤ N ≤ 10,000), 그 다음 N개의 줄에는 한 줄에 한 건물의 x-좌표와 y-좌표가 빈 칸을 사이에 두고 차례로 주어진다. x-좌표와 y-좌표는 절댓값이 1,000,000 이하인 정수이다.\n",
        "output_text": "최소의 총 설치비용(기지국의 통신범위를 나타내는 통신폭의 총합)을 첫째 줄에 출력한다.\n",
        "memory_median": 2104.0,
        "time_median": 112.0,
        "length_median": 764.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "117": {
        "problem_text": "외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.\n1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 모든 도시 사이에는 길이 있다. 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.\n도시 A에서 도시 B로 가는 비용은 두 도시 사이의 거리와 같다. 한 도시 A의 좌표가 (xA, yA), B의 좌표가 (xB, yB)라고 한다면, 두 도시의 거리는 √((xB-xA)2 + (yB-yA)2)와 같다.\n도시의 수 N과 모든 도시의 위치가 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 도시의 좌표 x, y가 주어진다. 모든 좌표는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다. 두 도시의 위치가 같은 경우는 없다.\n",
        "output_text": "첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다. 절대/상대 오차는 10-6까지 허용한다.\n",
        "memory_median": 10284.0,
        "time_median": 36.0,
        "length_median": 1158.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "118": {
        "problem_text": "정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.\n\n1+1+1+1\n1+1+2\n1+2+1\n2+1+1\n2+2\n1+3\n3+1\n\n정수 n과 m이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. 단, 사용한 수의 개수는 m개 이하 이어야 한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n과 m이 주어진다. n은 양수이며 1,000보다 작거나 같다. m도 양수이며, n보다 작거나 같다.\n",
        "output_text": "각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다. 단, 사용한 수의 개수는 m개 이하 이어야 한다.\n",
        "memory_median": 9816.0,
        "time_median": 16.0,
        "length_median": 688.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "119": {
        "problem_text": "규환이는 리그 오브 레전설이라는 게임을 좋아한다. 이 게임에서는 N초의 시간 동안 싸움을 하는데, 규환이가 플레이하는 캐릭터는 A, B 두 가지 스킬을 사용할 수 있다.  A 스킬의 시전 시간은 1초고, B 스킬의 시전 시간은 M초이다. 규환이는 다양한 스킬 조합을 원하기 때문에 가능한 모든 스킬 조합을 알아보고 싶어 한다. 단, 시전 시간 동안은 다른 스킬을 사용할 수 없으며, 스킬을 안 쓰고 있는 시간은 없어야 한다.\n예를 들어, N이 4초이고, M이 2초이면 가능한 스킬 조합은 AAAA, AAB, ABA, BAA, BB로 5가지가 가능하다.\n",
        "input_text": "첫 번째 줄에 싸움 시간 N과 B 스킬의 시전 시간 M이 주어진다. (N은 10,000 이하의 자연수, M은 2 이상 100 이하의 자연수)\n",
        "output_text": "가능한 조합의 수를 1,000,000,007로 나눈 나머지 값을 출력한다.\n",
        "memory_median": 2064.0,
        "time_median": 0.0,
        "length_median": 407.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "120": {
        "problem_text": "연구소에서 “초 울트라 캡쑝 으라차 마징가 Z”(이하 마징가)를 완성했다. 하지만 지구는 이미 태권 V로 인해 평화로운 상태를 유지하고 있기 때문에 마징가는 동네에서 가로등을 끄는 일을 시키기로 했다.\n마을의 중심에는 매우 긴 도로가 있는데, 이 도로 변에는 가로등이 세워져 있다. 마징가는 이 가로등을 매일 새벽 5시에 끄기 시작해야 한다. 새벽 5시 정각에 마징가는 정확히 여러 가로등 중에서 어느 한 가로등 바로 밑에 위치하고 있다가 일을 시작한다. 그런데, 가로등에는 일정량의 전력을 소비하는 전구가 달려있고, 우리의 날쌘돌이 마징가는 절약정신이 매우 투철하기 때문에 쓸데없이 전력을 낭비하길 원치 않는다.\n그래서 소비전력을 최소화할 수 있도록 가로등을 끄는 순서를 알아내고 싶어 한다. 마징가는 일정하게 1m/sec 의 속도로 움직이며, 가로등을 끈 동안의 시간은 무시해도 된다. 왜냐하면 마징가는 너무 날쌔기 때문에 지나가면서 순식간에 가로등을 끌 수 있기 때문이다.\n그렇다면, 절약정신으로 똘똘 뭉쳐진 우리의 날쌘돌이 마징가를 도와줄 수 있는 프로그램을 작성하시오.\n가로등의 위치와 그 가로등이 소비하는 전력의 양이 주어져 있을 때, 5시 정각이후에 낭비될 수 있는 전력의 최솟값을 구하면 된다.\n",
        "input_text": "첫째 줄에는 2개의 정수 N(1 ≤ N ≤ 1,000), M 이 있다. 첫 번째 정수 N은 가로등의 개수를 나타내는 정수이고, 두 번째 정수 M은 마징가 처음에 위치하는 가로등 번호이다. 다음 N 개의 줄에는 각 가로등에 관한 두 개의 정수가 입력된다. 첫 번째 정수 D(0 ≤ D ≤ 1,000)는 가로등의 위치를 나타내고, 두 번째 정수는 이 가로등의 전력소비량 W(1 ≤ W ≤ 100,000,000)을 나타낸다. 가로등의 위치는 마을이 시작되는 부분부터의 거리를 나타내며, 전력소비량은 1초당 소비되는 전력량을 나타낸다. 그러므로, 어떤 가로등의 전력소비량이 w 이고, 이 가로등이 s 초 동안 켜져 있는 동안에 소비된 전력량은 ws 가 된다. 가로등은 위치를 나타내는 정수 D 의 오름차순으로 입력된다. 같은 줄에 나타나는 정수들 사이에는 하나의 space 가 있다. 가로등 번호는 입력되는 순서대로 1번, 2번, ..., N 번을 부여한다.\n단, 낭비되는 전력의 최솟값이 1,000,000,000 보다는 항상 작은 데이터가 입력된다.\n",
        "output_text": "첫 줄에 낭비되는 전력의 최솟값을 나타내는 정수를 출력한다.\n",
        "memory_median": 16796.0,
        "time_median": 12.0,
        "length_median": 1157.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "121": {
        "problem_text": "트리는 N개의 정점과 N-1개의 간선으로 구성된 그래프이다. 트리의 성질 중 하나는 어느 두 정점 간에도 유일하게 하나의 경로가 존재한다는 것이다.\n트리의 모든 간선에 음이 아닌 정수인 가중치가 배정되었다. ‘경로의 가중치’란 경로에 해당하는 간선의 곱으로 정의된다. 또한 ‘트리의 가중치’는 트리 상에 가능한 모든 경로에 대해 ‘경로의 가중치’의 합을 의미한다. 문제는 트리가 주어졌을 때 ‘트리의 가중치’를 구하는 것이다.\n",
        "input_text": "첫째 줄에 트리의 정점의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N-1개의 줄에 대해 각 줄에는 세 개의 정수 A, B, W(1 ≤ A, B ≤ N, 0 ≤ W ≤ 1,000)가 입력되는데 이는 A점과 B점이 연결되어 있고 이 간선의 가중치는 W라는 것을 의미한다.\n",
        "output_text": "첫째 줄에 트리의 가중치를 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 10464.0,
        "time_median": 68.0,
        "length_median": 957.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "122": {
        "problem_text": "BOJ 알고리즘 캠프에 강사로 참여하고 있는 dotorya, kesakiyo, hongjun7은 301호에서 도원결의를 맺고 프로젝트 아이돌 그룹 Acka을 결성했다. \nAcka의 데뷔 앨범에는 총 S개의 곡이 수록될 예정이다. 각각의 곡은 세 사람중 적어도 한 명이 불러야 한다. 즉, 어떤 곡은 두 사람이 불러도 되고, 세 사람이 모두 함께 불러도 된다.\n세 사람이 녹음해야 하는 곡의 수가 주어질 때, 앨범을 만들 수 있는 방법의 수를 구하는 프로그램을 작성하시오.\n두 앨범 A와 B가 있을 때, 참여한 사람이 다른 곡이 존재한다면, 두 앨범은 다른 앨범이라고 한다. \n",
        "input_text": "첫째 줄에 앨범에 포함된 곡의 개수 S와 dotorya, kesakiyo, hongjun7이 불러야 하는 곡의 수가 주어진다. (1 ≤ S ≤ 50, 1 ≤ dotorya, kesakiyo, hongjun7 ≤ S)\n",
        "output_text": "첫째 줄에 앨범을 만들 수 있는 방법의 수를 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 54836.0,
        "time_median": 80.0,
        "length_median": 945.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "123": {
        "problem_text": "연종이는 창업했다. 오늘은 창업한지 N일이 되었고, 매일 매일 수익을 적어놓았다.\n어느 날 연종이는 가장 많이 돈을 번 구간이 언제인지 궁금해졌다.\n오늘이 창업한지 6일 되었고, 수익이 다음과 같다고 하자.\n\n1일: -3\n2일: 4\n3일: 9\n4일: -2\n5일: -5\n6일: 8\n\n이때, 가장 많은 돈을 번 구간은 2~6까지이고 총 수입은 14이다.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 N이 주어져 있다. (1 ≤ N ≤ 250,000) 둘째 줄부터 N개의 줄에는 매일 매일의 수익 P가 주어진다. (-10,000 ≤ P ≤ 10,000) 수익은 첫 날부터 순서대로 주어진다. 입력의 마지막 줄에는 0이 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해서 가장 많은 수익을 올린 구간의 수익을 출력한다. 단, 구간이 비어있으면 안 된다.\n",
        "memory_median": 3090.0,
        "time_median": 104.0,
        "length_median": 508.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "124": {
        "problem_text": "오민식은 오늘이 크리스마스라고 생각해서, 크리스마스 트리를 만들려고 한다. 트리는 N개의 레벨로 이루어져 있다. 위에서부터 레벨1, ... 레벨 N이다. 또, 민식이는 빨강, 파랑, 초록색의 장난감을 가지고 있다. 그리고 민식이는 이 장난감을 일정한 규칙에 의해서 장식하려고 한다.\n레벨 K에는 딱 K개의 장난감이 있어야 한다. 또, 각 레벨에 놓으려고 선택한 색이 있으면, 그 색의 장난감의 수는 서로 같아야 한다. 예를 들어, 레벨 3에 장난감을 놓으려고 할 때, 빨강 2, 파랑 1과 같이 놓으면, 빨강과 파랑의 수가 다르기 때문에 안 된다. 하지만, 레벨 4에 빨강 2, 파랑 2와 같이 놓으면, 가능하다.\nN과, 장난감의 수가 주어질 때, 트리를 장식하는 경우의 수를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 트리의 크기 N, 빨강의 개수, 초록의 개수, 파랑의 개수가 주어진다. N은 10보다 작거나 같다. 빨강, 초록, 파랑의 개수는 0보다 크거나 같고, 100보다 작거나 같다.\n",
        "output_text": "첫째 줄에 경우의 수를 출력한다. 만약 주어진 장난감으로 트리를 장식할 수 없으면 0을 출력한다. 문제의 정답은 263-1보다 작거나 같다.\n",
        "memory_median": 89656.0,
        "time_median": 32.0,
        "length_median": 1379.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "125": {
        "problem_text": "N(2 ≤ N ≤ 10,000)개의 돌들이 같은 간격으로 놓여 있다. 편의상 순서대로 1, 2, …, N번 돌이라고 부르자. 당신은 현재 1번 돌 위에 있는데, 이 돌들 사이에서 점프를 하면서 N번째 돌로 이동을 하려 한다. 이때 다음 조건들이 만족되어야 한다.\n\n이동은 앞으로만 할 수 있다. 즉, 돌 번호가 증가하는 순서대로만 할 수 있다.\n제일 처음에 점프를 할 때에는 한 칸밖에 점프하지 못한다. 즉, 1번 돌에서 2번 돌이 있는 곳으로 점프할 수 있다. 그 다음부터는 가속/감속 점프를 할 수 있는데, 이전에 x칸 점프를 했다면, 다음번에는 속도를 줄여 x-1칸 점프하거나, x칸 점프하거나, 속도를 붙여 x+1칸 점프를 할 수 있다. 물론 점프를 할 때에는 한 칸 이상씩 해야 한다.\n각 돌들은 각기 그 크기가 다르고, 그 중 몇 개의 돌은 크기가 너무 작기 때문에 당신은 그러한 돌에는 올라갈 수 없다.\n\n위와 같은 조건들을 만족하면서 1번 돌에서 N번 돌까지 점프를 해 갈 때, 필요한 최소의 점프 횟수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 두 정수 N, M(0 ≤ M ≤ N-2)이 주어진다. M은 크기가 맞지 않는, 즉 크기가 작은 돌의 개수이다. 다음 M개의 줄에는 크기가 작은 돌들의 번호가 주어진다. 1번 돌과 N번 돌은 충분히 크기가 크다고 가정한다.\n",
        "output_text": "첫째 줄에 필요한 최소의 점프 횟수를 출력한다. 만약 N번 돌까지 점프해갈 수 없는 경우에는 -1을 출력한다.\n",
        "memory_median": 9958.0,
        "time_median": 28.0,
        "length_median": 940.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "126": {
        "problem_text": "\n< Picture: Designed by Kstudio / Freepik >\n갑은 아주대학교 학생입니다. 갑은 팔달관 1층에서 학과 개강총회를 준비하고 있습니다. 갑은 피자를 N 판 시켰습니다. 식탁 위에 피자 N 판이 탑처럼 쌓여있습니다. 갑은 높이가 N 인 이 한 피자탑을, 높이가 1인 피자탑들로 분리시켜야 합니다. 갑은 이 일을 하기 싫었습니다. 하지만 다음과 같은 격언이 있습니다.\n“피할 수 없다면 즐겨라!” - 로버트 엘리어트\n격언대로, 갑은 혼자 놀기를 하며 즐겁게 일을 해결하기로 합니다. 그래서 다음과 같은 놀이를 하기로 했습니다. \n먼저 놀이를 시작하기 전에, 식탁 위엔 N 개의 피자판이 하나의 탑으로 쌓여있습니다. 놀이가 시작되면, 갑은 식탁 위에 있는 피자탑들 중 하나를 고릅니다. 그리고 고른 피자탑을 두 개의 피자탑으로 분리합니다. 이때 갑은, 분리된 두 피자탑의 높이의 곱만큼 즐거움을 느낍니다. 즉, 갑이 고른 피자탑의 높이가 A이고, 갑이 이 피자탑을 높이 B인 피자탑과 높이 C인 피자탑으로 분리했다면, 갑은 이때 B * C만큼의 즐거움을 느낍니다. 단, 높이가 1인 피자탑은 더는 분리시키지 않습니다. 갑은 계속 피자탑들을 분리해나갑니다. 이 놀이를 하다가 식탁 위에 더 이상 분리할 수 있는 피자탑이 없어진다면, 갑의 개강총회 준비 일은 끝나게 됩니다. \n갑은 문득, 혼자 놀기를 통해 얼마나 재밌게 놀 수 있을지 궁금해졌습니다. 갑이 주문한 피자판의 수 N 이 주어질 때, 갑이 혼자 놀기를 통해 얻을 수 있는 즐거움의 총합의 최댓값을 구해주세요.\n\n< 높이가 8인 피자탑을 높이가 4인 피자탑 둘로 분리시키는 과정 >\n",
        "input_text": "첫 번째 줄에는 피자판의 개수를 의미하는 양의 정수 N(1 ≤ N ≤ 109) 이 주어진다.\n",
        "output_text": "갑이 얻을 수 있는 즐거움의 총합의 최댓값을 한 줄에 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 221.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "127": {
        "problem_text": "꿍 협회는 매년 세계체스대회에 나갈 팀을 만들고 있다. 팀은 흑으로 플레이하는 15명과 백으로 플레이하는 15명, 총 30명으로 이루어진다. 꿍 협회는 가능한 최고의 팀을 만들려고 하는데 각 플레이어의 흑,백 능력치는 각각 1부터 100까지의 정수로 주어진다. 대회가 진행되는 동안 플레이어는 흑, 백 중 한 가지만으로 참여를 해야하며 팀의 전체 능력치는 흑 플레이어의 능력치를 합한것과 백 플레이어의 능력치를 합한것을 모두 더한 값이다. 어떻게 하면 꿍 협회는 가능한 높은 능력치의 팀을 만들수 있을까.\n",
        "input_text": "입력은 각 플레이어들의 능력치로 이루어진다. 각 줄은 공백으로 구분되는 두 개의 정수로 주어진다. 첫 번째 숫자는 해당 플레이어가 백으로 플레이를 할 때 능력치고 두 번째 숫자는 흑으로 플레이를 할 때의 능력치다. 최소한 30줄 이상이며 1000줄은 넘지 않는다.\n",
        "output_text": "꿍 협회가 만들 수 있는 팀 중 가장 큰 능력치를 갖는 팀의 능력치를 출력한다.\n",
        "memory_median": 2992.0,
        "time_median": 0.0,
        "length_median": 860.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "128": {
        "problem_text": "정수 N개로 이루어진 수열 A가 있다. 이때, i번째 수가 그 앞에 있는 수 세 개의 합으로 나타낼 수 있을 때, 그 수를 좋다고 한다. (같은 위치에 있는 수를 여러 번 더해도 된다)\n수열이 주어졌을 때, 총 몇 개의 수가 좋은 수 일까?\n",
        "input_text": "첫째 줄에 수열 A의 크기 N이 주어진다. (1 ≤ N ≤ 5000) 둘째 줄에는 수열 A의 각 숫자가 공백으로 구분되어 주어진다. (-100,000 ≤ Ai ≤ 100,000)\n",
        "output_text": "첫째 줄에 좋은 수의 개수를 출력한다.\n",
        "memory_median": 2596.0,
        "time_median": 16.0,
        "length_median": 546.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "129": {
        "problem_text": "민건이네 과일 농장은 N가지 종류의 과일을 재배하는 중이다. 평소 민건이에게 앙심을 품고 있던 지환이는 민건이를 골탕 먹이기 위하여 민건이네 과일 농장에서 과일들을 훔치기로 다짐했다. 지환이는 완벽한 범죄를 위하여 처음 생각한 개수 만큼만 훔치려고 한다. 이때 지환이가 훔칠 수 있는 경우의 수가 몇가지나 될 지 알아보자. 단, 모든 종류의 과일을 적어도 1개는 훔친다.\n",
        "input_text": "첫째 줄에 과일의 종류 수 N(1 ≤ N ≤ 10)이 주어진다.\n둘째 줄에 훔치려 하는 과일의 개수 M(N ≤ M ≤ 30)이 주어진다.\n",
        "output_text": "첫째 줄에 훔칠 수 있는 경우의 수를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 409.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "130": {
        "problem_text": "정수 N과 K가 주어졌을 때, 다음 두 조건을 만족하는 문자열 S를 찾는 프로그램을 작성하시오.\n\n문자열 S의 길이는 N이고, 'A', 'B', 'C'로 이루어져 있다.\n문자열 S에는 0 ≤ i < j < N 이면서 S[i] < S[j]를 만족하는 (i, j) 쌍이 K개가 있다.\n\n",
        "input_text": "첫째 줄에 N과 K가 주어진다. (3 ≤ N ≤ 30, 0 ≤ K ≤ N(N-1)/2)\n",
        "output_text": "첫째 줄에 문제의 조건을 만족하는 문자열 S를 출력한다. 가능한 S가 여러 가지라면, 아무거나 출력한다. 만약, 그러한 S가 존재하지 않는 경우에는 -1을 출력한다.\n",
        "memory_median": 15108.0,
        "time_median": 12.0,
        "length_median": 797.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "131": {
        "problem_text": "동주는 항상 혼자 노느라 심심하다. 하지만 혼자 놀기의 고수가 된 동주는 매일매일 게임을 개발하여 혼자놀기의 진수를 우리에게 보여준다. 어느 날 동주는 새로운 게임을 개발하였다. 바로 점수 따먹기라는 게임인데 그다지 재밌어 보이지는 않는다.\n동주가 개발한 게임은 이렇다. 일단 N*M 행렬을 그린 다음, 각 칸에 -10,000 이상 10,000 이하의 정수를 하나씩 쓴다. 그런 다음 그 행렬의 부분행렬을 그려 그 안에 적힌 정수의 합을 구하는 게임이다.\n동주가 혼자 재밌게 놀던 중 지나가는 당신을 보고 당신을 붙잡고 게임을 하자고 한다. 귀찮은 당신은 정수의 합이 최대가 되는 부분행렬을 구하여 빨리 동주에게서 벗어나고 싶다.\n",
        "input_text": "첫째 줄에 N (1 < N < 200), M (1 < M < 200)이 주어진다. 그 다음 N개의 줄에 M개씩 행렬의 원소가 주어진다.\n",
        "output_text": "첫째 줄에 최대의 합을 출력하라.\n",
        "memory_median": 2288.0,
        "time_median": 408.0,
        "length_median": 823.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "132": {
        "problem_text": "세준이는 크기가 N*M인 직사각형 도시에 살고 있다. 또, 세준이의 집은 (1, 1)에 있고, 학원은 (N, M)에 있고, 오락실이 C개 있다.\n세준이의 현재 위치가 (r, c) 일 때, (r+1, c) 또는 (r, c+1)로만 이동할 수 있다. 오락실을 방문할 때는 규칙이 하나 있는데, 오락실 번호가 증가하는 순서대로 가야한다는 것이다. 2번 오락실을 먼저 가고, 그 후에 1번 오락실을 가면 안 되고, 2번 오락실을 가려면, 그 전에 아무 오락실도 가지 않거나, 1번 오락실을 방문했을 때만 가능하다.\n세준이는 오락실을 K번 방문해서 학원에서 도착하는 경로의 경우의 수가 궁금해지기 시작했다. 오락실을 0개 방문했을 때부터, C개 방문했을 때 까지 경우의 수를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N M C가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, C는 50보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 C개의 줄에 1번 오락실부터 C번 오락실까지 위치가 차례대로 주어진다. 오락실의 위치가 중복되는 경우는 없지만, 오락실의 위치가 (1,1) 또는 (N,M)일 수도 있다.\n",
        "output_text": "첫째 줄에 0개 방문했을 때, 1개 방문했을 때, ..., C개 방문했을 때 총 경로의 개수를 한 줄에 공백을 사이에 두고 출력한다. 경로의 개수는 1,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 28456.0,
        "time_median": 84.0,
        "length_median": 1287.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "133": {
        "problem_text": "상근이는 사탕에 중독된 아이이다. 상근이는 캔디 매거진의 열렬한 구독자이며, 올해 열리는 국제 사탕 줍기 대회에 한국 대표로 참가하게 되었다.\n이 대회는 사탕을 포함하고 있는 박스가 M행 N열로 놓여져있는 곳에서 진행된다. (따라서 박스는 총 M × N개 있다) 각 박스에는 들어있는 사탕의 개수가 겉에 적혀져 있다.\n대회의 참가자는 박스를 하나 고른다. 그 다음, 그 박스 안에 있는 사탕을 모두 가져가게 된다. 박스를 고르면, 고른 박스의 바로 위쪽 행과 바로 아래쪽 행에 있는 모든 박스, 그리고 고른 박스의 왼쪽과 오른쪽에 있는 박스에 들어있는 사탕이 모두 사라지게 된다. 참가자는 사탕이 들어있는 박스가 없을 때까지 박스를 고를 수 있다.\n아래 그림을 살펴보자. 각 칸은 박스에 들어있는 사탕의 개수를 나타낸다. 각각의 단계에서 참가자가 고른 박스는 동그라미로 표시되어 있고, 회색으로 칠해진 박스는 참가자의 선택 때문에 사탕이 사라질 박스이다. 총 여덟 단계가 지나면 게임은 끝나게 되고, 상근이는 총 10+9+8+3+7+6+10+1 = 54개의 사탕을 가져가게 된다.\n\nM과 N이 주어졌을 때, 상근이가 이 대회에서 가져갈 수 있는 사탕의 최대 개수를 구하는 프로그램을 작성하시오. \n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 M과 N이 주어졌다. (1 ≤ M × N ≤ 105) 다음 M개 줄에는 박스에 들어있는 사탕의 개수 N개가 주어진다. 박스에 들어있는 사탕은 적어도 1개이며 103개를 넘지 않는다.\n입력의 마지막 줄에는 0이 두 개 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해 상근이가 집을 수 있는 사탕의 최대 개수를 출력한다.\n",
        "memory_median": 3552.0,
        "time_median": 60.0,
        "length_median": 890.0,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "134": {
        "problem_text": "M개의 행(가로줄)과 N개의 열(세로줄)이 있는 격자의 각 칸에는 로봇이 있다.\n각 행에는 위에서부터 아래로 1부터 M까지의 번호가 붙어 있고, 각 열에는 왼쪽에서부터 오른쪽으로 1 부터 N까지의 번호가 붙어 있다. 이를 통해 격자 칸의 위치를 (행 번호, 열 번호)의 좌표로 표시할 수 있다.\n각 로봇은 하나 이상의 입력 값, 하나의 저장 값, 하나의 출력 값을 가진다.\n로봇들은 제일 왼쪽 열의 로봇들부터 열 번호 순서대로 동작한다. 같은 열에 있는 로봇들은 동시에 동작 한다.\n로봇들의 동작은 다음과 같다. (표현 |A|는 정수 A의 절댓값을 의미한다. 즉, A ≥ 0인 경우 |A| = A, A < 0 인 경우 |A| = −A.)\n\n제일 왼쪽 열에 있는 로봇의 입력 값은 0 하나로 정한다\n좌표 (i, j)의 로봇의 입력 값은 |i−a| ≤ j −b, b < j인 모든 좌표 (a, b)에 있는 로봇들의 출력 값들이다. (아래 그림에서 별로 표시된 칸의 로봇의 입력 값들은 왼쪽 회색 칸들의 로봇들의 출력 값들이다.)\n\n\n\n각 로봇은 자신의 입력 값들 중 최댓값을 자신의 저장 값으로 한다.\n각 로봇은 자신의 저장 값에 자신의 가중치 Di,j를 더한 값을 자신의 출력 값으로 한다.\n\n로봇들의 가중치를 입력받아 로봇들의 저장 값 중 최댓값(가장 큰 값)을 계산하는 프로그램을 작성하라.\n",
        "input_text": "첫 번째 줄에 두 정수 M과 N이 공백 하나를 사이로 두고 주어진다.\n다음 M개의 줄에는 로봇들의 가중치들이 행 순서대로 주어진다. 각각의 줄은 한 행에 해당하며 N개의 숫자(한 자리 수)로 이루어진 문자열이 주어진다. 각 숫자는 격자 칸의 로봇의 가중치를 의미한다. 즉, 여기서 i번째 줄의 j번째 문자가 Di,j이다.\n",
        "output_text": "첫 번째 줄에 로봇들의 저장 값 중 최댓값을 출력한다.\n",
        "memory_median": 33584.0,
        "time_median": 304.0,
        "length_median": 724.5,
        "label": [
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "135": {
        "problem_text": "무방향, 무가중치, 연결 그래프가 주어진다. 그래프의 각 간선은 빨간색 또는 파란색으로 색칠되어져 있다. 이 그래프의 스패닝 트리 중 파란색 간선이 정확히 k개인 것이 있는지 없는지 알아내는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스의 첫 줄에는 세 정수 n, m, k가 주어진다. n은 그래프의 정점의 개수 (2 ≤ n ≤ 1,000)이고, m은 간선의 개수, k는 문제에 설명되어 있는 파란색 간선의 개수 (0 ≤ k < n) 이다.\n다음 m개 줄에는 간선의 정보가 주어지며, 각 정보는 세 정수 c, f, t로 이루어져 있다. c는 간선의 색상을 나타내며, 빨간색인 경우에는 R, 파란색인 경우에는 B이다. f와 t는 정수로 간선이 연결하는 두 정점을 나타낸다. (1 ≤ f, t ≤ n, f ≠ t) 두 정점을 연결하는 간선은 최대 한 개이다.\n입력의 마지막 줄에는 0이 세 개 주어진다.\n",
        "output_text": "각 테스트 케이스마다 파란색 간선이 정확하게 k개인 스패닝 트리를 만들 수 있으면 1, 없으면 0을 출력한다.\n",
        "memory_median": 11376.0,
        "time_median": 268.0,
        "length_median": 1587.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "136": {
        "problem_text": "명우가 소트 알고리즘을 하나 발명했다. 이 알고리즘의 이름은 터보소트이다. \n터보소트는 1부터 N까지 총 N개의 수가 섞여있을 때만 사용할 수 있으며, 다음과 같이 N단계로 이루어져 있다.\n\n첫 번째 단계에서 숫자 1의 위치를 찾는다. 그 다음 바로 앞의 숫자와 위치를 바꾸어가면서, 1이 제일 앞에 오게 바꾼다.\n두 번째 단계에서는 숫자 N의 위치를 찾는다. 그 다음 바로 뒤의 숫자와 위치를 바꾸어가면서, N이 제일 마지막에 오게 바꾼다.\n세 번째 단계는 숫자 2의 위치를 찾은 후에, 바로 앞의 숫자와 위치를 바꾸어가면서, 두 번째 위치에 오게 바꾼다.\n네 번째 단계는 숫자 N-1의 위치를 찾은 다음에, 바로 뒤의 숫자와 위치를 바꾸면서, 뒤에서 2번째 위치에 오게 바꾼다.\n다섯 번째 단계도 위와 같은 식으로 하면 되고 이를 N번 반복하는 것이다.\n\n정리하면, 홀수번째 단계이면, 아직까지 고르지 않은 숫자 중 제일 작은 수를 고른 다음에, 그것을 인접한 숫자와 위치를 바꾸면서 올바른 위치로 이동시키고, 짝수번째 단계일때는, 제일 큰 수를 고른 다음에 위치를 이동시키는 것이다.\n명우는 이때, 각 단계에서 숫자의 위치를 몇 번 바꾸는지 구하려고 한다.\n1부터 N까지 총 N개의 수로 이루어진 배열이 주어졌을 때, 터보 소트의 각 단계에서, 숫자의 위치를 몇 번씩 바꾸는지 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이며, 배열의 크기이다.\n둘째 줄부터 N개의 줄에는 1보다 크거나 같고, N보다 작거나 같은 수가 중복 없이 주어진다. 이 숫자가 차례대로 배열에 포함되어 있는 수이다.\n",
        "output_text": "각 단계에서 숫자의 위치를 몇 번 바꾸는지 출력한다. 총 N줄을 출력해야 한다.\n",
        "memory_median": 3828.0,
        "time_median": 48.0,
        "length_median": 1236.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "137": {
        "problem_text": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. \n\n1 x y v: Ai = (Ai + v) % MOD를 수행한다. (x ≤ i ≤ y)\n2 x y v: Ai = (Ai × v) % MOD를 수행한다. (x ≤ i ≤ y)\n3 x y v: Ai = v를 수행한다. (x ≤ i ≤ y)\n4 x y: (ΣAi) % MOD를 출력한다. (x ≤ i ≤ y)\n\n여기서 MOD는 항상 109+7이며, %는 나머지 연산을 의미한다.\n",
        "input_text": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)\n둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)\n셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)\n넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ y ≤ N, 1 ≤ v ≤ 109)\n",
        "output_text": "4번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.\n",
        "memory_median": 11842.0,
        "time_median": 224.0,
        "length_median": 2748.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "138": {
        "problem_text": "상근이는 자동차를 매우 좋아한다. 자동차 공장에 취직한 상근이는 계속된 승진 끝에 드디어 사장이 되었다. 공장에는 총 N명의 직원이 있다. 상근이를 제외한 모든 직원은 한 명의 상사가 있다. (상근이는 모든 사람의 상사이다) 상근이의 번호는 1번이고, 나머지 직원의 번호는 2부터 N이다.\n모든 직원은 자신의 모든 부하 직원(직속 부하와 부하의 부하등등을 모두 포함)의 월급을 인상하거나 삭감할 수 있다. 상근이는 권력 남용을 막기 위해 직원의 월급을 모니터링 하려고 한다.\n월급의 변화를 모니터링하는 프로그램을 작성하시오.\n모든 직원의 월급은 항상 양의 정수이고 231-1 이하이다.\n",
        "input_text": "첫째 줄에 직원의 수 N과 월급 변화와 조사 쿼리의 수 M이 주어진다. (1 ≤ N, M ≤ 500,000)\n다음 N개 줄의 i번째 줄에는 직원 i의 초기 월급과 상사의 번호가 주어진다. (상근이는 상사가 없기 때문에, 초기 월급만 주어진다)\n다음 M개 줄에는 월급 변화와 조사 쿼리가 주어진다.\n\np a x가 주어진 경우 a의 모든 부하의 월급을 x만큼 증가시킨다. (-10,000 ≤ x ≤ 10,000)\nu a가 주어진 경우에는 a의 월급을 출력한다.\n\n",
        "output_text": "입력으로 u가 주어질 때마다 해당하는 직원의 월급을 출력한다.\n",
        "memory_median": 47836.0,
        "time_median": 532.0,
        "length_median": 1939.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "139": {
        "problem_text": "안녕? 내 이름은 ntopia!\n나는 원래 지구에 살고 있던 평범한 20대 청년이었어. 어느 날 길을 걷다가 괴한의 칼에 찔려 죽어버렸어. 그런데 이게 무슨 일이람! 정신을 차려보니 이세계에 떨어져 버렸지 뭐야. 여기에서 나는 슬라임을 전문으로 연구하는 슬라임 연구자가 되어버린 것 같아. 나는 지금 아주 중요한 연구를 진행하고 있어. 이 연구가 성공하면 나는 내가 살던 세계로 돌아갈 수 있게 될 거야. 이 연구를 도와주지 않겠니?\n이곳의 슬라임은 모두 슬라임 에너지라는 것을 갖고 있고 그 양은 2 이상의 자연수로 표현돼. 나는 슬라임을 합성했을 때 슬라임 에너지가 어떻게 변화하는지에 대해 연구하고 있어.\n슬라임 합성 과정은 2마리를 합성해서 1마리를 만들어내는 식으로 이루어져. A만큼의 슬라임 에너지를 가진 슬라임과 B만큼의 슬라임 에너지를 갖고 있는 슬라임이 있었다고 해보자. 이 슬라임 2마리를 합성하면 슬라임 에너지가 A × B 인 슬라임을 만들 수 있어.\n그리고 슬라임 합성 기술이 아직 완벽하지 않아서 슬라임을 합성할 때마다 크나큰 전기 에너지가 필요해. 구체적으로, A만큼의 슬라임 에너지를 가진 슬라임과 B만큼의 슬라임 에너지를 가진 슬라임을 합성하려면 A × B 만큼의 전기 에너지가 필요해.\n\n에너지가 4인 슬라임과 에너지가 6인 슬라임을 합성한 모습. 4 × 6의 전기 에너지를 사용해 슬라임 에너지가 24인 슬라임이 합성되었다.\n나에겐 지금 N마리의 슬라임이 있어. 이 슬라임들을 모두 적절히 합성해서 1마리의 슬라임으로 만들려고 해. 그런데 내가 소속된 연구소에서 각 합성 단계마다 필요한 전기 에너지들을 모두 곱한 값을 나에게 비용으로 청구하겠다고 했지 뭐야. 그래서 이 값이 최소가 되도록 합성을 적절히 수행하는 것이 내 연구의 목표야.\n내 연구를 도와줘! 부탁이야!!\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 수 T 가 주어지고, 이어서 T 개의 테스트 케이스가 주어진다.\n각 테스트 케이스의 첫 번째 줄에는 슬라임의 수 N (1 ≤ N ≤ 60)이 주어지고, 두 번째 줄에는 N 개의 자연수가 주어진다. i번째 자연수 Ci (2 ≤ Ci ≤ 2 × 1018) 는 i번째 슬라임의 슬라임 에너지를 나타낸다. 끝까지 합성하고 난 후에 생기는 슬라임의 에너지의 양이 2 × 1018 이하라는 것이 보장된다.\n모든 테스트 케이스에 대한 N 의 총합이 1, 000, 000을 넘지 않음이 보장된다.\n",
        "output_text": "각 테스트 케이스마다 슬라임을 끝까지 합성했을 때 청구될 비용의 최솟값을 1, 000, 000, 007로 나눈 나머지를 출력한다. 전기 에너지가 전혀 필요하지 않은 경우엔 1 을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 196.0,
        "length_median": 715.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "140": {
        "problem_text": "개미집은 n개의 방으로 구성되어 있으며 n개의 방은 1번부터 n번 까지 번호가 부여되어 있다. 그 중에서 1번 방은 지면에 바로 연결되어 있는 방이다. 각 방들은 서로 굴을 통해 연결되어 있다. 각 굴을 이동하기 위해서는 굴의 길이만큼 에너지가 소모된다.\n개미는 집짓기의 달인이기 때문에 불필요한 굴은 짓지 않는다. 그래서 굴을 타고 한 방에서 다른 방으로 갈 수 있는 경로는 항상 존재하며 유일하다. 임의의 두 방 사이의 거리는 두 개의 방을 연결하는 경로를 구성하는 굴의 길이의 합이다.\n겨울잠을 자던 개미들은 겨울잠에서 깨어나 지면으로 올라가 햇살을 보고 싶어한다. 그렇기 때문에 지면과 연결된 1번 방으로 이동을 하려고 한다. 하지만 불행하게도 개미는 긴 겨울잠을 자느라 축적해 놓은 에너지가 적다. 그래서 개미는 에너지를 1번 방에 도달하기 전에 모두 소모 할 수도 있다. 이렇게 에너지가 0이 된 개미는 더 이상 움직일 수 없다. 또한 1번 방에 도착한 개미는 더 이상 움직이지 않는다.\n현재 모든 방에는 개미가 한 마리씩 있고 각각의 개미는 각자 축적된 에너지를 가지고 있다. 잠에서 깨어난 모든 개미는 1번 방을 향해서 이동한다. 이때 각각의 개미에 대해 도달할 수 있는 방 중에서 가장 1번 방에 가까운 방의 번호를 출력하시오.\n",
        "input_text": "자연수 n이 주어진다. n은 방의 개수이다. (1 ≤ n ≤ 105) 다음 n개의 줄에는 차례대로 현재 각각의 개미가 보유하고 있는 에너지 값이 주어진다. i+1번째 줄에는 i번째 방에 있는 개미가 가진 에너지를 나타내는 100,000이하의 자연수 값이 주어진다. 이후 n-1개의 줄에는 두 개의 방을 연결하는 굴의 정보가 3개의 정수 a b c 으로 주어진다. a, b는 연결된 방을 의미하고 c는 이 굴의 길이를 의미한다. 굴의 길이는 10,000 이하의 자연수이다.\n",
        "output_text": "n개의 줄을 출력한다. i번째 줄에는 i번 방에 있던 개미가 도달할 수 있는 방 중에 1번 방과 가장 가까운 방의 번호를 출력한다.\n",
        "memory_median": 22640.0,
        "time_median": 108.0,
        "length_median": 1368.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "141": {
        "problem_text": "평행 세계의 성필은 숫자와 연산자를 만든 당대 최고의 수학자이다. 그리고 놀랍게도 이 숫자와 연산자는 현재 우리가 사용하는 것과 같다. 하지만 수식은 연산자가 피연산자 가운데 위치하는 우리와는 다르게 연산자가 피연산자 뒤에 위치한다고 한다.\n우리 세계의 식을 성필의 식으로 바꾸는 방법을 간단히 설명하자면 이렇다. 우선 주어진 식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.\n예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 a+bc*가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.\n천재 수학자 성필은 자신이 만든 이런 간단한 식조차 1초 안에 계산하지 못하는 사람들을 위하여 답을 구해주는 프로그램을 개발하려고 했지만 아쉽게도 성필의 세계에는 프로그래밍 언어가 없다. 프로그래밍을 할 수 있는 우리가 성필을 위해 평행세계의 식을 계산하는 프로그램을 만들어주자.\n",
        "input_text": "길이가 100이 넘지 않는 수식이 예제 입력과 같이 공백 없이 입력된다. 수식은 0부터 9까지의 숫자와 연산자 '+', '-', '*', '/' 로만 이루어져 있다.\n또한, 수식의 계산 중간 과정의 모든 결과는 항상 2,147,483,647을 넘지 않는 정수이고 0으로 나누는 경우는 없습니다.\n잘못된 수식이 입력되는 경우도 없습니다.\n",
        "output_text": "입력으로 주어진 성필의 수식의 답을 첫째 줄에 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 738.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "142": {
        "problem_text": "성화는 악독하기로 유명한 편의점 사장이다. 그의 편의점에는 특이한 임금 체계를 가지고 있다.\n\n각 날마다 일의 차이때문에 일마다 급여가 정해져 있다.\n돈은 당일에 주지 않고 퇴직을 할 때 한번에 준다.\n성화는 욕심쟁이라서 해당 일을 한 동안 중 가장 일급이 작을 때를 기준으로 급여를 지급한다.\n일급이 다른 것을 들키지 않기 위하여 한번이라도 퇴직한 자를 다시 취직 시키지 않는다. (만약 취직을 한다면, 일을 시작 한 날부터 끝날 때까지 하루도 빠지면 안 된다.)\n\n준수는 n+1일 후에 001에 월세를 내야 해서 성화가 사장으로 있는 편의점에 취직하려 한다. 다행히 주변 퇴직자들의 얘기로 급여에 관련해 파악했다. 또한 퇴직자들의 급여 통계를 통해 당장 n일 후까지 일급 정보를 알아냈다. 최대로 많이 일했을 때가 최대 이익이 아닐 수 있다.\n어제까지 과제를 제출하고 지금도 001에서 자고 있는 준수를 위해 코딩 잘하는 여러분이 일을 해서 벌 수 있는 최대 이익을 준수에게 알려주도록 하자.\n",
        "input_text": "일을 할 수 있는 날의 수 (0 < n ≤ 100000) 가 주어진다.\n그 다음 줄 에는 1일부터 n일 까지 일급 Ti 가 순서대로 주어진다. (0 < Ti ≤ 1,000,000)\n",
        "output_text": "준수가 일을 해서 벌 수 있는 최대 이익을 출력한다.\n",
        "memory_median": 2800.0,
        "time_median": 20.0,
        "length_median": 962.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "143": {
        "problem_text": "상훈이는 $N$개의 선물 상자를 가지고 있다. 선물 상자에는 현재 담겨있는 선물의 개수가 적혀있다.\n선물을 받을 아이들이 $M$명 있다. 아이들은 각자 $1$에서 $M$까지의 서로 다른 번호를 하나씩 부여받았다.\n$1$번 아이부터 $M$번 아이까지 한 번에 한 명씩, 현재 선물이 가장 많이 담겨있는 상자에서 각자 원하는 만큼 선물을 가져간다. 이 때, 앞서 누군가 선물을 가져갔던 선물 상자에서 또다시 가져가도 상관없다.\n하지만 상자에 자신이 원하는 것보다 적은 개수의 선물이 들어있다면, 선물을 가져가지 못해 실망한다.\n상훈이는 한 명이라도 실망하지 않고 모두가 선물을 가져갈 수 있는지 궁금하다.\n",
        "input_text": "첫째 줄에 선물 상자의 수 $N$ 과 아이들의 수 $M$이 공백을 사이에 두고 주어진다. ($1\\le M \\le N\\le 10^5$)\n둘째 줄에 각 선물 상자에 들어있는 선물의 개수 $c_1,c_2,\\ldots ,c_N$이 공백을 사이에 두고 주어진다. ($1\\le c_i\\le 10^5$)\n셋째 줄에 아이들의 번호 순으로 각 아이가 원하는 선물의 개수 $w_1,w_2,\\ldots ,w_M$이 공백을 사이에 두고 주어진다. ($1\\le w_i\\le 10^5$)\n",
        "output_text": "모든 아이들이 실망하지 않고 각자 원하는 만큼 선물을 가져갈 수 있으면 $1$을, 그렇지 않으면 $0$을 출력한다.\n",
        "memory_median": 2916.0,
        "time_median": 32.0,
        "length_median": 619.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "144": {
        "problem_text": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.\n모든 칭찬에는 칭찬의 정도를 의미하는 수치가 있는데, 이 수치 또한 부하들에게 똑같이 칭찬 받는다.\n이번에는 내리 칭찬이 실시간으로 일어날 것이다.\n입력으로 아래와 같은 쿼리가 주어질 것이다.\n\n1 i w: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. (2 ≤ i ≤ n, 1 ≤ w ≤ 1,000)\n2 i: i번째 직원이 칭찬을 받은 정도를 출력한다.\n\n직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력한다.\n",
        "input_text": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)\n둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.\n다음 m줄에는 위와 같이 쿼리가 주어진다. 사장은 상사가 없으므로 칭찬을 받지 않는다.\n",
        "output_text": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.\n",
        "memory_median": 15478.0,
        "time_median": 68.0,
        "length_median": 1814.5,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "145": {
        "problem_text": "최근에 진솔이는 로봇 공학을 하기 시작했다. 그래서 포커 카드가 완전한 세트인지 확인하는 로봇을 만들기로 결심했다.\n그는 프로그램을 작성하는 일을 분담했다. 그 프로그램은 카드의 모양(스페이드(♠), 하트(♡), 다이아몬드(♢), 클럽(♣))을 인식하는 것이다. 문제를 간단하게 하기 위해서 모든 카드는 하나의 모양과 하나의 숫자를 가진다고 가정한다.\n여기서 그 모양은 실제 그림 대신 문자로 대체한다. P,K,H,T에 해당한다. 그리고 숫자는 1~13에 해당하는 정수이다. 로봇은 각각의 카드를 TXY의 형태로 '카드 이름'을 정하는데 T는 모양에 해당하고 XY는 숫자에 해당한다. 만약 만약 숫자가 1자리 숫자이면 X=0에 해당한다. ex) 01.\n만약에 모양이 P이고 숫자가 9이면 P09이다.\n완벽한 카드 한 세트는 52개로 이루어져 있다. (4 (모양)x 13(숫자))\n로봇은 모든 카드의 '카드이름'을 읽고 문자열 S로 결합한다.\n이제 진솔이가 프로그래밍 하는 것을 도와주자.  문자열을 읽어 얼마나 많은 카드를 잃어버렸는지 세면 된다.\n만약에 2개의 같은 카드가 존재한다면 GRESKA이라고 출력하면 된다.\n",
        "input_text": "오직 1줄만 문자열 S(1 ≤ |S| ≤ 1000)가 들어온다. 이것은 현재 가지고 있는 카드 이름에 해당한다.\n",
        "output_text": "만약 똑같은 카드가 존재한다면 GRESKA을 출력한다.\n그렇지 않으면 4개의 정수를 공백 문자로 구분하여 출력한다. 각각 P, K, H, T에 해당한다.\n",
        "memory_median": 1992.0,
        "time_median": 0.0,
        "length_median": 784.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "146": {
        "problem_text": "백설 공주와 난쟁이 N명과 함께 숲 속에 살고 있다. 난쟁이는 매일 광산에 일하러가고, 백설 공주는 그동안 페이스북을 하고 있다.\n매일 아침 난쟁이는 한 줄로 휘파람을 불면서 광산으로 출근을 한다. 백설 공주는 그 주변을 돌아다니면서 난쟁이들 사진을 찍는다.\n난쟁이가 광산에 들어가면, 백설 공주는 다시 집으로 돌아간다. 집으로 돌아가면서 찍은 사진 중에 페이스북에 올릴 예쁜 사진을 고른다. 각 난쟁이는 모두 모자를 쓰고 있다. 모자의 색상은 총 C가지가 있다. 사진에 찍힌 난쟁이가 쓰고 있는 모자의 색상 중 절반보다 많은 색이 같은 색이라면 예쁜 사진이다. 즉, 사진에 난쟁이가 K명 찍혀있고, K/2보다 많은 난쟁이의 모자 색이 같다면 예쁜 사진이다.\n백설공주가 찍은 사진 M개와 각 사진에 찍힌 난쟁이가 주어졌을 때, 예쁜 사진인지 아닌지를 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 난쟁이의 수 N과 모자 색상의 수 C가 주어진다. (3 ≤ N ≤ 300,000, 1 ≤ C ≤ 10,000)\n둘째 줄에는 각 난쟁이가 쓰고 있는 모자의 색상이 줄을 서 있는 순서대로 주어진다. 색상은 C이하의 자연수로 나타낸다.\n셋째 줄에는 사진의 수 M이 주어진다. (1 ≤ M ≤ 10,000)\n다음 M개 줄에는 두 정수 A와 B가 주어진다. (1 ≤ A ≤ B ≤ N) 이 줄은 사진의 정보를 의미하고, A번째 난쟁이부터 B번째 난쟁이까지 사진에 찍혔다는 뜻이다.\n",
        "output_text": "출력은 총 M 줄이다. 각 사진이 예쁘지 않다면 \"no\"를 출력하고, 예쁘다면 \"yes X\"를 출력한다. 예쁜 사진인 경우에 X는 사진에 절반이 넘는 모자의 색상이다.\n",
        "memory_median": 5780.0,
        "time_median": 184.0,
        "length_median": 1570.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "147": {
        "problem_text": "KOI 중학교에는 N개의 학급이 있으며, 각 학급의 학생 수는 모두 M명으로 구성된다. 이 중학교에서는 체육대회에 새로운 종목의 경기를 추가하였다. 이 경기에 대해 모든 학생들은 저마다의 능력을 나타내는 능력치를 가지고 있으며, 이 능력치는 모든 학생이 서로 다르다.\n이 경기는 한반에서 한 명의 대표선수를 선발하여 치른다. 경기의 형평성을 위하여, 각각의 반에서 대표로 선발된 모든 학생들의 능력치 중 최댓값과 최솟값의 차이가 최소가 되도록 선수를 선발하려고 한다. 예를 들어, N=3, M=4인 경우 학생들의 능력치가 1반=[12, 16, 67, 43],  2반=[7, 17, 68, 48], 3반=[14, 15, 77, 54]로 주어질 때, 각 학급으로부터 능력치 16, 17, 15를 가진 학생을 각각 선택하면, 최댓값과 최솟값의 차이가 17-15=2로 최소가 된다. \n대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "입력의 첫 번째 줄에는 학급의 수를 나타내는 N과 각 학급의 학생의 수를 나타내는 M이 하나의 빈칸을 사이에 두고 주어진다. 단, 1 ≤ N, M ≤ 1,000이다. 두 번째 줄부터 N개의 줄에는 각 줄마다 한 학급 학생들의 능력치를 나타내는 M개의 양의 정수가 하나의 빈칸을 사이에 두고 주어진다. 능력치는 0이상 109이하이다.\n",
        "output_text": "대표로 선발된 모든 학생들 능력치의 최댓값과 최솟값 차이가 최소가 되는 경우의 값을 하나의 정수로 출력한다.\n",
        "memory_median": 9296.0,
        "time_median": 300.0,
        "length_median": 993.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "148": {
        "problem_text": "은기는 술병 N개(1부터 N까지 번호가 매겨져 있다)와 서랍 L개(1부터 L까지 번호가 매겨져 있다)를 가지고 있다. 술병은 은기의 방 바닥에 흩어져 있고, 어린이날을 맞이해 방 청소를 하려고 한다.  서랍에는 술병이 하나 들어갈 수 있다. 나중에 원하는 술을 빠르게 찾을 수 있게 하기 위해 은기는 각각의 술병이 들어갈 수 있는 서랍의 번호 Ai와 Bi를 공책에 적어 놓았다.\n은기는 술병을 1번부터 N번까지 순서대로 정리할 것이고, 각각의 술병에 대해서 다음과 같은 과정을 거친다.\n\n서랍 Ai가 비어있다면, i번 술을 그 서랍에 보관한다.\n서랍 Bi가 비어있다면, i번 술을 그 서랍에 보관한다.\nAi에 들어있는 술을 다른 서랍으로 이동시킨다.(다른 서랍은 Ai에 들어있는 술이 들어갈 수 있는 서랍 중 하나이다) 만약, 그 서랍에도 이미 술이 들어있다면, 그 술을 다른 서랍으로 이동시킨다. 이런 과정을 거쳐서 빈 서랍을 하나 찾아 술을 모두 이동할 수 있는 경우에는, 술을 이동시키고 i번 술을 Ai에 보관한다. 불가능한 경우에는 다음 규칙으로 넘어간다.\nBi에 들어있는 술을 다른 서랍으로 이동시킨다. 만약, 그 서랍에도 이미 술이 들어있다면, 그 술을 다른 서랍으로 이동시킨다. 이런 과정을 거쳐서 빈 서랍을 하나 찾아 술을 모두 이동할 수 있는 경우에는, 술을 이동시키고 i번 술을 Bi에 보관한다. 불가능한 경우에는 다음 규칙으로 넘어간다.\n위의 과정이 모두 불가능한 경우에는 i번 술을 그 자리에서 마셔버린다. (은기는 전혀 취하지 않는다)\n\n각각의 술에 대해서, 서랍에 보관할 수 있는지, 그 자리에서 마셔버리는지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 L이 주어진다. (1 ≤ N, L ≤ 300,000)\n다음 N개 줄에는 Ai와 Bi가 주어진다. (1 ≤ Ai, Bi ≤ L, Ai ≠ Bi)\n",
        "output_text": "1번 술부터 N번 술까지 순서대로 보관할 수 있는지, 그 자리에서 먹어야 하는지를 출력한다.\n보관할 수 있는 경우에는 \"LADICA\"를, 먹어버려야 하는 경우에는 \"SMECE\"를 출력한다.\n",
        "memory_median": 3560.0,
        "time_median": 136.0,
        "length_median": 926.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "149": {
        "problem_text": "이진 탐색 트리는 모든 노드가 많아야 2개의 자식 노드를 가지고 있는 트리이고, 각 노드에는 수가 하나씩 쓰여있다. 만약 어떤 노드에 쓰여 있는 수가 X라면, 그 노드의 왼쪽 서브트리에는 X보다 작은 수, 오른쪽 서브트리에는 X보다 큰 수만 저장되어 있어야 한다.\n1보다 크거나 같고, N보다 작거나 같은 수 N개가 한 번씩 등장하는 수열이 입력으로 주어진다. 이 수열을 이용해서 이진 탐색 트리를 만들려고 한다. 이제 배열의 첫 번째 수를 루트 노드로 놓고, 다른 나머지 수들을 순서대로 삽입하면서 이진 탐색 트리를 만들려고 한다. 즉, 첫 번째 수를 제외한 모든 수에 대해서 insert(X,root)를 실행하는 것과 같다. 그 함수는 다음과 같다. \n이진 탐색 트리에 삽입하는 함수는 다음과 같다.\n\r\ninsert(number X, node N)\r\n    카운터 C값을 1 증가시킨다\r\n    if X가 노드 N에 있는 수보다 작다면\r\n        if N의 왼쪽 자식이 없다면\r\n            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다\r\n        else\r\n            insert(X, N의 왼쪽 자식)\r\n    else (X가 노드 N에 있는 수보다 크다면)\r\n        if N의 오른쪽 자식이 없다면\r\n            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만들기\r\n        else\r\n            insert(X, N의 오른쪽 자식)\n각 수를 삽입한 후에 C의 값을 출력하는 프로그램을 작성하시오. 카운터 C의 값은 0으로 초기화되어 있다.\n",
        "input_text": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 300,000)\n다음 N개의 줄에는 수열의 수가 차례대로 주어진다. 수는 구간 [1, N]에 포함된 정수이고, 중복되지 않는다.\n",
        "output_text": "N개의 줄에 각 수가 트리에 삽입된 후에 카운터 C값을 한 줄에 하나씩 출력한다.\n",
        "memory_median": 17280.0,
        "time_median": 232.0,
        "length_median": 733.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "150": {
        "problem_text": "현재 대한민국 해군에 소속되어있는 준하는 문제를 풀기 위해 매일같이 사이버 지식 정보방 통칭 싸지방에 다닌다. 그러나 최근 문제가 생겼다. 싸지방에 사람이 몰려 컴퓨터 수가 모자라게 된 것이다. 이런 사태를 도저히 용납할 수 없었던 준하는 곧 전역하는 선임을 설득해 민원을 넣도록 하는 데 성공했다.\n마침내 부대에서는 민원을 받아들이기로 하였고, 컴퓨터를 증설하기로 했다. 또한, 컴퓨터 간의 사용률에 따라 다른 성능의 컴퓨터를 설치하고자 한다.\n하지만 예산이 부족해 사람 수 만큼 컴퓨터를 살 수가 없었다. 고심에 고심을 거듭한 준하는 모든 사람이 항상 정해진 시간에 싸지방을 이용한다는 사실을 발견했다.\n컴퓨터가 있는 자리에는 1번부터 순서대로 번호가 매겨져 있다. 모든 사람은 싸지방에 들어왔을 때 비어있는 자리 중에서 번호가 가장 작은 자리에 앉는 것이 규칙이다.\n준하가 발견한 사실과 이용 규칙을 가지고, 모든 사람이 기다리지 않고 싸지방을 이용할 수 있는 컴퓨터의 최소 개수와 자리별로 몇 명의 사람이 사용했는가를 구하시오.\n",
        "input_text": "첫째 줄에 사람의 수를 나타내는 \\(N\\)이 주어진다. \\((1 \\le N \\le 100,000)\\) 둘째 줄부터 \\(N\\)개의 줄에 걸쳐서 각 사람의 컴퓨터 이용 시작 시각 \\(P\\)와 종료 시각 \\(Q\\)가 주어진다. \\((0 \\le P \\lt Q \\le 1,000,000)\\)\n시작 시각이나 종료 시각이 다른 사람과 겹치는 경우는 없다.\n",
        "output_text": "첫째 줄에 사람이 모든 사람이 기다리지 않아도 되는 컴퓨터의 최소 개수 \\(X\\)를 출력한다.\n둘째 줄에는 1번 자리부터 \\(X\\)번 자리까지 순서대로 각 자리를 사용한 사람의 수를 띄어쓰기 간격으로 출력한다.\n",
        "memory_median": 5100.0,
        "time_median": 60.0,
        "length_median": 1231.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "151": {
        "problem_text": "백준이는 BOJ 알고리즘 캠프 참가자 중 한 명에게 기념품을 주려고 한다. 하지만, 많은 참가자 중에서 어떤 사람을 뽑아서 기념품을 줘야하는지 고민이 되기 시작했다. 따라서, 백준이는 게임을 통해서 기념품을 받을 사람을 정하기로 결정했다.\n게임이 시작하기 전에 모든 참가자 N명은 원을 이루어서 앉아있다. 다음, 1부터 N까지 번호가 적혀있는 티셔츠를 시계방향으로 입는다. 이 티셔츠는 게임에 사용되지 않으며, 게임을 쉽게 하기 위해서 입는 티셔츠이다.\n게임은 단계로 이루어져 있으며, 첫 단계는 1단계이다. 각 단계가 시작될 때, 백준이는 어떤 참가자의 앞에 서있다. 그 다음, \"하나\"를 외친다. 그 다음, 시계 방향으로 다음 사람에게 이동하며 \"둘\"을 외친다. 이 과정은 t단계인 경우에 t3을 외칠 때 까지 진행한다. 예를 들어, 1단계에서는 1까지 외치며, 2단계에서는 8까지, 3단계에서는 27까지 외친다.\n각 단계가 끝난 경우에, 백준이가 앞에 서 있는 사람은 게임에서 제외된다. (t단계인 경우에 t3을 외칠 때 앞에 있던 사람) 사람이 제거된 후에는 백준이는 시계 방향으로 다음 사람에게 이동한다. 1단계에서 백준이는 티셔츠 1번을 입고 있는 사람의 앞에 있다. 게임은 원에 한 명이 남을 때 까지 진행되며, 마지막 남은 사람이 기념품을 가져가게 된다.\n참가자의 수 N이 주어졌을 때, 어떤 티셔츠를 입고 있는 사람이 기념품을 받는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 BOJ 캠프 참가자의 수 N (1 ≤ N ≤ 5,000)이 주어진다.\n",
        "output_text": "첫째 줄에 기념품을 받는 사람이 입고 있는 티셔츠의 번호를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 16.0,
        "length_median": 512.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "152": {
        "problem_text": "성규는 로봇을 조립해야 한다. 상자 안에는 여러 로봇의 부품들이 섞여 있다. 그런데 어떤 부품이 어느 로봇의 부품인지 표시가 되어있지 않다. 호재는 전자과라서 두 부품을 보면 같은 로봇의 부품인지 알 수 있다. 그래서 성규는 호재의 지시에 따라 부품들을 정리하기로 하였다.\n부품들은 1부터 106까지의 정수로 표현된다. 그리고 부품 i가 속한 로봇은 robot(i)라고도 표현한다. 예를 들어, 부품 11과 부품 22가 로봇 A의 부품이라고 알고 있는 경우, robot(11)은 로봇 A를 의미하고, robot(22)도 로봇 A를 의미한다.\n서로 다른 로봇은 공통 부품을 가지지 않는다. 즉 어떤 부품이 로봇 A의 부품이라면, 로봇 B의 부품은 될 수 없다.\n호재는 2가지 지시를 한다.\n\n서로 다른 부품 2개를 말해주며, 두 부품은 같은 로봇의 부품이라는 정보를 알려준다.\n부품 i에 대해서, 지금까지 알아낸 robot(i)의 부품이 몇 개냐고 물어본다.\n\n초기에는 부품에 대한 정보가 존재하지 않는다.\n",
        "input_text": "첫 번째 줄에 호재의 지시 횟수 N이 들어온다. (1 ≤ N ≤ 106)\n다음 줄부터 N개의 지시가 들어온다.\n부품 2개가 같은 로봇의 부품인지 알려줄 때에는 \\(I\\) a b 의 형태로 들어온다. 부품 a와 부품 b는 같은 로봇의 부품이라는 의미이다. (1 ≤ a, b ≤ 106, a ≠ b, a, b는 정수)\n어떤 로봇의 부품이 몇 개인지 물어볼 때에는 Q c 의 형태로 들어온다. 지금까지 알아낸 robot(c)의 부품이 몇 개냐는 의미이다. (1 ≤ c ≤ 106, c는 정수)\n입력으로 Q c의 형태가 적어도 한 번 들어온다.\n",
        "output_text": "Q로 시작하는 입력에 대해서 한 줄에 하나씩, 지금까지 알아낸 해당 로봇의 부품 개수를 출력한다.\n",
        "memory_median": 9832.0,
        "time_median": 332.0,
        "length_median": 848.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "153": {
        "problem_text": "캠프 내내 그랬듯이, 여전히 옆 나라와의 전쟁이 한창이다.\n전쟁에는 N개의 부대가 투입되었는데, 전쟁이 장기전이 되다 보니 군사의 적절한 배치를 위해 각 부대에 군인이 늘어나기도 하고 줄어들기도 하고 있다.\n행정의 편의를 위해 각 군인들에겐 번호가 붙어 있는데, 군인들은 1번 부대부터 군번순서대로 차례차례 배치된다. 예를 들어 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있다면 군번이 6번인 군인은 2번 부대에 배치되게 된다.\n문제는 어떤 부대의 인원이 늘어나거나 줄어들었을 때 i번 군인이 어디에 배치되는지 인데, 이럴 때에는 군인도 군번도 처음부터 다시 배치하게 된다. 위의 예에서와 같이 1번 부대에 4명, 2번 부대에 3명, 3번 부대에 7명의 군인이 있었는데, 1번 부대에서 3명의 감원이 일어난다면, 6번 군인은 3번 부대에 재배치 받게 된다.\n전쟁 때는 부대의 감원과 증원이 많아 군사 재배치도 자주 일어나게 되는데, 이렇게 자주 배치가 바뀌자 군인들은 자기가 도대체 어떤 부대에 속하는 지 헷갈리게 되었다. 다행히도 바뀐 군번은 다들 정확하게 숙지하고 있다.\n부대의 개수 N과 각 부대에 속해 있는 군인의 수가 N개 주어질 때, 부대의 감원과 증원을 한 후, 혹은 그 중에 군번 i번의 군인이 몇 번 부대에 속하는 지를 물어봤을 때, 그 질문에 대답을 해 줄 수 있는 프로그램을 작성하시오.\ni번 부대에 증원이나 감원을 할 때엔 \"1 i a\"의 형태로 명령이 주어지고, 이는 i번 부대에 a명을 더한다는 뜻이다. 감원을 할 때엔 a가 0보다 작은 수로 주어진다. 감원을 해서 부대의 인원수가 0보다 작아지는 입력은 들어오지 않는다. a는 절댓값이 1보다 크거나 같고, 3,000보다 작거나 같은 정수이다.\n군번 i번의 군인이 어떤 부대에 배치 받았는지 알고 싶을 때는 \"2 i\"의 형태로 명령이 주어지고, 이런 명령을 받았을 때는 i번 군인이 몇 번 부대에 배치 받았는지를 출력해야 한다. i는 전체 군인 수보다 작거나 같은 자연수이다.\n",
        "input_text": "첫째 줄에 부대의 개수 N(1 ≤ N ≤ 500,000)이 주어지고, 이어서 각 부대의 군사 수를 나타내는 정수가 N개 주어진다. 각 부대의 군사 수는 1000보다 작거나 같은 자연수이다. 그 다음 줄에 명령의 개수 M(1 ≤ M ≤ 10,000)개가 주어지고, 이어서 M줄에 걸쳐 명령이 주어진다.\n",
        "output_text": "질문한 군인이 몇 번 부대에 배치 받았는지를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 10216.0,
        "time_median": 68.0,
        "length_median": 1256.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "154": {
        "problem_text": "소문자로 이루어진 단어 N개가 주어졌을 때, 단어가 총 최소 몇 개의 그룹으로 이루어져 있는지 구하는 프로그램을 작성하시오.\n그룹에 속한 단어는 모두 같은 알파벳으로 이루어져 있어야 하고, 개수도 같아야 한다. 즉, 단어를 구성하는 알파벳의 순서만 달라야 한다.\n",
        "input_text": "첫째 줄에 단어의 개수 N이 주어진다. (2 ≤ N ≤ 100) 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.\n",
        "output_text": "첫째 줄에 그룹의 최소 개수를 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 425.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "155": {
        "problem_text": "김상근은 창영마을에서의 권력을 유지하기 위해 신문을 검열하려고 한다.\n상근이는 텍스트 T에서 A라는 단어를 다음과 같은 알고리즘을 이용해서 모두 없애려고 한다.\n\nT에 A가 없으면 알고리즘을 종료한다.\nT에서 처음 등장하는 A를 찾은 뒤, 삭제한다.\nT에 A가 없으면 알고리즘을 종료한다.\nT에서 마지막으로 등장하는 A를 찾은 뒤, 삭제한다.\n1번으로 돌아간다.\n\n상근이는 마을을 지배해야하기 때문에, 검열을 할 시간이 없다. 상근이의 검열을 대신해주는 프로그램을 작성하시오. \n",
        "input_text": "첫째 줄에 단어 A가, 둘째 줄에 텍스트 T가 주어진다. A와 T는 알파벳 소문자로만 이루어져 있고, A는 최대 25자, T는 최대 300,000자이다.\n",
        "output_text": "검열을 한 이후의 텍스트를 출력한다.\n",
        "memory_median": 3168.0,
        "time_median": 16.0,
        "length_median": 1594.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "156": {
        "problem_text": "승범이는 평소 래퍼 도끼를 흠모해왔지만, 도끼만큼 랩을 잘할 수 없다는 것을 깨닫고 도끼만큼 돈이라도 벌자는 결심을 한다. 그래서 휴학 후 ㈜승범이네를 창업했다.\n㈜승범이네는 판매원들로만 이루어진 다단계 회사이다.\n승범이를 제외한 모든 판매원은 사수가 배정되는데, 사수는 한 회원당 단 한 명씩만 배정된다. 만약 판매원 A가 B의 사수라면, B를 A의 부사수라고 부른다.\n㈜승범이네의 수익구조는 기형적이다.\n판매원들은 제품을 자비로 사서 판매한다. 이때 제품을 구매가격보다 저렴하게 판매하게 되면 손해를 보게 되는데, 어떤 회원 A가 손해를 보면 그 회원의 모든 부사수도 같은 만큼의 손해를 보게 된다. 그러면 부사수들의 부사수들도 손해를 보게 되고, 그들의 부사수들도 손해를 보게 되고, … ,결국 A와 A 밑의 모든 판매원이 A가 잃은 만큼의 손해를 보게 된다.\n반대로 판매원 A가 제품을 비싸게 팔아 이익이 생길 경우, A와 A밑의 모든 판매원이 같은 이익을 얻을 수 있다.\n승범이는 직원들이 현재 얼마만큼 돈을 벌었는지 감시하기 위해 다음 두 종류의 명령을 처리하려고 한다.\n\n1 i w : 직원 i가 w만큼 이익/손해를 본다. (이익은 양수로, 손해는 음수로 주어진다)\n2 i : 직원 i의 현재 통장 잔액을 출력한다.\n\n직원들은 빈 통장을 갖고 일을 시작하며, 이익과 손해가 실시간으로 통장에 기록된다. 물론 통장 잔액은 음수일 수도 있다.\n일을 시작하기 직전에 플래티넘 승급전을 남겨두고 온 것을 떠올린 승범이는 우리에게 일을 맡기고 집으로 달려가버렸다.\n만년 골드 승범이를 위해 문제를 대신 해결해주자.\n",
        "input_text": "첫 번째 줄에 승범이를 포함한 판매원들의 수 N(1 ≤ N ≤ 100,000), 명령의 수 M(1 ≤ M ≤ 100,000)이 주어진다. 판매원들은 1번부터 N번까지 번호가 매겨지며, 승범이는 항상 1번이다.\n두 번째 줄에 판매원 1번부터 N번까지의 사수가 순서대로 공백으로 구분되어 주어진다. 승범이는 사수가 없으므로 -1이 주어진다.\n세 번째 줄부터 M개의 줄에 걸쳐 위에서 설명한 명령(i, w는 정수, 1 ≤ i ≤ N, -10,000 ≤ w ≤ 10,000) 이 주어진다.\n",
        "output_text": "2번 명령이 주어질 때마다 한 줄에 하나씩 해당하는 직원 i의 잔고 상황을 출력한다.\n",
        "memory_median": 15970.0,
        "time_median": 92.0,
        "length_median": 1857.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "157": {
        "problem_text": "종빈이는 아주 큰 그룹의 총수다. 이 그룹은 1부터 N번까지의 번호로 구분할 수 있는 N개의 기업을 운영하고 있다. 현재 각 기업은 서로 독립적인 자체 컴퓨팅 및 통신센터를 가지고 있다.\n어느 날 종빈이는 계열사의 CTO인 서현이에게 서비스 개선을 위해 각 기업의 서버를 네트워크로 연결하여 단일 통신센터에서 관리 가능한 클러스터 형태로 구성할 것을 제안했다. 종빈이의 제안을 들은 서현이는 다음과 같은 병합 과정을 고안해냈다.\n\n클러스터 A를 제공하는 기존에 존재하는 센터 I를 고른다.\n클러스터 B를 제공하는 기업 J를 고른다. B는 A가 아닌 임의의 클러스터이며, J는 센터가 아닐 수 있다.\nI와 J를 통신 라인으로 연결한다. 이때 기업 I와 J를 잇는 라인의 길이는 |I – J|(mod 1000)이다.\n위 방식을 통해 클러스터 A와 B는 새로운 클러스터로 합쳐지며, 이 클러스터는 B의 센터에 의해 제공된다.\n\n이러한 병합 과정을 거치던 중에, 각 기업에서 현재 센터까지 연결되는 라인의 길이가 총 얼마나 되는지에 관한 문의가 들어왔다. 서현이를 위해 병합하는 과정과 그 과정에서 통신센터와 각 기업을 잇는 라인의 길이를 구하는 프로그램을 작성해보자.\n",
        "input_text": "입력은 여러 개의 테스트케이스로 주어진다. 입력의 첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스에는 기업의 수를 나타내는 N(4 ≤ N ≤ 20,000)이 주어진다. 다음은 몇 개의 줄에 걸쳐 아래 두 가지 종류의 명령어가 들어온다.\n\nE I – 기업 I와 현재 I의 센터까지의 거리를 출력한다. \nI I J – 센터 I를 기업 J에 연결한다.\n\n각 테스트케이스의 끝에는 단어 O가 주어진다. 각 테스트케이스에서 명령어의 총 개수는 200,000개를 넘지 않으며, 그중 I 명령어의 개수는 N개보다 작다.\n",
        "output_text": "E 명령어가 들어올 때마다 한 줄에 해당 거리를 출력한다.\n",
        "memory_median": 2168.0,
        "time_median": 40.0,
        "length_median": 977.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "158": {
        "problem_text": "어렸을때부터 컴퓨터 프로그래밍에 엄청난 소질을 보인 상근이는 항상 소셜 네트워킹 웹사이트를 만들고 싶어 했다. 상근이는 페이스북을 벤치마킹하기 위해 지난 3년간 열심히 사용을 했고, 이제 페이스북의 단점을 보완한 새 소셜 네트워킹 웹 2.0 어플리케이션을 만들려고 한다.\n사람들은 소셜 네트워킹 어플리케이션에 가입을 한 다음, 현실에서 아는 사람을 친구로 추가하기 시작한다. 이러한 친구 관계 정보를 이용해 친구 관계 그래프를 그릴 수 있다.\n소셜 네트워킹 어플리케이션에서 가장 중요한 기능은 한 사람이 다른 사람의 페이지를 방문했을 때, 친구 관계 그래프에서 두 사람 사이의 경로를 보여주는 기능이다. 경로가 없는 경우에는 보여주지 않는다.\n상근이의 서비스는 매우 유명해졌고, 위의 기능은 사람들이 점점 많아질수록 경로를 구하는 시간이 매우 느려지게 되었다. 그 이유는 두 사람 사이의 경로가 없는 경우에 경로를 찾기 위해 너무 오랜시간 그래프를 탐색하기 때문이었다. 따라서, 상근이는 두 사람 사이의 경로가 존재하는지 안 하는지를 미리 구해보려고 한다.\n유저의 수와 각 유저의 친구 관계가 입력으로 주어진다. 이때, 주어지는 두 사람이 친구 관계 그래프상에서 경로가 존재하는지 안 하는지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스의 첫째 줄에는 유저의 수 1 ≤ n ≤ 106이 주어진다. 둘째 줄에는 친구 관계의 수 1 ≤ k ≤ 105가 주어진다. 다음 k개 줄에는 두 정수 0 ≤ a, b < n이 주어진다. 두 수는 친구 관계를 나타내며, 유저 a와 b가 친구라는 소리이다. 다음 줄에는 미리 구할 쌍의 수 1 ≤ m ≤ 105가 주어진다. 다음 m개 줄에는 구해야하는 쌍을 나타내는 u, v가 주어진다.\n",
        "output_text": "각 테스트 케이스마다 \"Scenario i:\"를 출력한다. i는 테스트 케이스 번호이며, 1부터 시작한다. 그 다음, 각각의 쌍마다 두 사람을 연결하는 경로가 있으면 1, 없으면 0을 출력한다.\n각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.\n",
        "memory_median": 5928.0,
        "time_median": 140.0,
        "length_median": 971.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "159": {
        "problem_text": "간선(혹은 에지)에 가중치가 주어진 그래프가 있다. 정점들의 수가 N일 때, 모든 정점은 1부터 N까지 번호가 붙여져 있고, 모든 간선들의 가중치는 서로 다르다. 이때 서로 다른 두 정점 u,v에 대하여, Cost(u,v)는 다음에서 제거되는 간선들의 가중치 합이다: u와 v사이의 경로가 있으면 이 그래프의 최소 가중치 간선을 그래프에서 제거한다. 이 과정을 u와 v사이의 경로가 없을 때까지 반복한다.\n예를 들어, 6개의 정점으로 이루어진 다음 그래프를 고려해 보자.\n\n두 정점 2, 6에 대하여, Cost(2,6)을 구하는 과정에서 제거되는 간선들을 차례대로 나열하면 다음과 같다: (2, 3), (4, 5), (3, 5), (3, 4), (2, 6).\n이들 간선들 중 (2, 6)이 제거될 때, 두 정점 2와 6사이의 경로가 없으므로 간선 제거가 끝나게 된다. 따라서  Cost(2,6) = 2 + 3 + 4 + 5 + 6 = 20이다.\n간선에 가중치가 있는 그래프가 주어질 때, u < v인 모든 두 정점 u, v에 대한 Cost(u,v)들의 총 합을 구하는 프로그램을 작성하시오. 총 합이 109보다 크거나 같으면 이를 109으로 나눈 나머지를 출력한다.\n",
        "input_text": "첫 번째 줄에 정점의 수 N (1< ≤ N ≤ 100,000)과 간선의 수 M (1 ≤ M ≤ 100,000)이 빈칸을 사이에 두고 주어진다. 다음 M개의 각 줄에 간선 하나에 대한 정보를 나타내는 세 개의 양의 정수 x,y,w가 빈칸을 사이에 두고 주어진다. 이는 간선 (x,y)의 가중치가w 임을 의미한다. 1 ≤ w ≤ 100,000이다.\n",
        "output_text": "u < v인 모든 두 정점 에 대한 Cost(u,v)들의 총 합을 첫째 줄에 출력한다. 단, 총 합이 109보다 크거나 같으면 이를 109으로 나눈 나머지를 출력한다.\n",
        "memory_median": 5440.0,
        "time_median": 52.0,
        "length_median": 1248.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "160": {
        "problem_text": "민서는 강원대학교 컴퓨터공학과의 신임 교수이다. 그녀가 저술한 효율적인 택배 배달을 위한 최적 경로 설계에 관한 연구 논문은 아직도 널리 인용되고 있다. 오늘도 열심히 강의를 하던 민서는 놀라 자빠질 수밖에 없었다. 한 학생이 꾸벅꾸벅 졸다가 책상에 머리를 아주 세게 박았기 때문이다. 한시라도 수술이 시급한 상황, 민서는 의사가 되어 수술을 집도하기로 결심하였다.\n사람의 뇌는 수백억 개의 뉴런으로 구성되며, 각 뉴런은 시냅스를 통하여 연결된다. 민서의 진찰 결과, 학생은 뇌 속의 일부 뉴런의 연결이 끊어져 잠이 든 것으로 확인되었다. 끊어진 시냅스만 복구된다면 학생은 잠에서 깨어나겠지만, 알다시피 민서는 컴퓨터공학과 교수이다.\n민서는 끊어진 시냅스를 복구하는 대신 뇌 속의 모든 뉴런을 하나의 트리 형태로 연결해보고자 한다. 여기서 트리란 사이클이 존재하지 않는 연결 그래프를 의미한다.\n민서는 손기술이 뛰어나기 때문에 다음과 같은 연산을 무한히 수행할 수 있다. 연결되지 않은 두 뉴런을 연결하거나 이미 연결된 두 뉴런의 연결을 끊는다.\n뉴런의 연결 정보가 주어졌을 때, 모든 뉴런을 하나의 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 뉴런의 개수 N과 시냅스의 개수 M이 주어진다.\n이후 M개의 줄에 걸쳐 시냅스로 연결된 두 뉴런의 번호 u, v가 주어진다.\n모든 입력은 공백으로 구분되어 주어진다.\n",
        "output_text": "첫 번째 줄에 모든 뉴런을 트리 형태로 연결하기 위하여 필요한 최소 연산 횟수를 출력한다.\n",
        "memory_median": 8376.0,
        "time_median": 40.0,
        "length_median": 811.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "161": {
        "problem_text": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오\n\n1 i v: Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)\n2 l r: l ≤ i < j ≤ r을 만족하는 모든 Ai + Aj 중에서 최댓값을 출력한다. (1 ≤ l < r ≤ N)\n\n수열의 인덱스는 1부터 시작한다.\n",
        "input_text": "첫째 줄에 수열의 크기 N이 주어진다. (2 ≤ N ≤ 100,000)\n둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)\n셋째 줄에는 쿼리의 개수 M이 주어진다. (2 ≤ M ≤ 100,000)\n넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.\n",
        "output_text": "2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.\n",
        "memory_median": 5508.0,
        "time_median": 112.0,
        "length_median": 1760.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "162": {
        "problem_text": "여는 괄호 ‘(’와 닫는 괄호 ‘)’로 구성된 문자열에서 아래의 조건을 만족하는 문자열을 올바른 괄호 문자열이라고 부른다.\n\n() 는 올바른 괄호 문자열이다\n어떤 문자열 x가 올바른 괄호 문자열이라면, (x)도 올바른 괄호 문자열이다.\n어떤 문자열 x와 y가 올바른 괄호 문자열이라면, xy도 올바른 괄호 문자열이다.\n\n현욱은 친구로부터 생일 선물로 굉장히 긴 괄호 문자열을 받았다(도대체 왜 이런 걸 선물하는걸까?). 하지만 현욱은 올바른 괄호 문자열이 아니면 굉장히 싫어하기 때문에, 받은 괄호 문자열에서 연속한 일부분을 잘라서 올바른 괄호 문자열을 만들려고 한다. 그리고 이왕이면 긴 문자열이 좋으니 현욱은 부분 구간을 최대한 길게 잘라내려고 한다. 현욱을 도와 주어진 괄호 문자열에서 위의 조건을 만족하는 가장 긴 부분 문자열의 길이를 계산하는 프로그램을 작성해보자.\n",
        "input_text": "첫 줄에 문자열의 길이 n (1 ≤ n ≤ 200,000)이 주어진다.\n둘째 줄에 괄호로만 구성된 길이 n짜리 문자열이 주어진다.\n",
        "output_text": "주어진 문자열에서 길이가 가장 길면서 올바른 괄호 문자열인 부분 문자열의 길이를 출력한다. 올바른 괄호 문자열인 부분 문자열을 찾을 수 없는 경우 0을 출력한다.\n",
        "memory_median": 3778.0,
        "time_median": 4.0,
        "length_median": 578.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "163": {
        "problem_text": "N개의 직사각형 모양의 건물들이 주어졌을 때, 스카이라인을 구해내는 프로그램을 작성하시오. 스카이라인은 건물 전체의 윤곽을 의미한다. 즉, 각각의 건물을 직사각형으로 표현했을 때, 그러한 직사각형들의 합집합을 구하는 문제이다.\n\n예를 들어 직사각형 모양의 건물들이 위와 같이 주어졌다고 하자. 각각의 건물은 왼쪽 x좌표와 오른쪽 x좌표, 그리고 높이로 나타난다. 모든 건물들은 편의상 같은 높이의 지면(땅) 위에 있다고 가정하자. 위의 예에서 스카이라인을 구하면 아래와 같다.\n\n",
        "input_text": "첫째 줄에 건물의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 N개의 건물에 대한 정보가 주어진다. 건물에 대한 정보는 세 정수 L, H, R로 나타나는데, 각각 건물의 왼쪽 x좌표, 높이, 오른쪽 x좌표를 의미한다. (1 ≤ L < R ≤ 1,000,000,000, 1 ≤ H ≤ 1,000,000,000)\n",
        "output_text": "첫째 줄에 스카이라인을 출력한다. 출력을 할 때에는 높이가 변하는 지점에 대해서, 그 지점의 x좌표와 그 지점에서의 높이를 출력한다.\n",
        "memory_median": 7392.0,
        "time_median": 100.0,
        "length_median": 1557.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "164": {
        "problem_text": "1부터 N까지의 숫자가 적힌 카드가 있다. 찬유는 이 카드를 가지고 마술을 하려 한다. 마술을 하는 순서는 다음과 같다.\n\n먼저 1부터 N까지의 숫자가 적힌 카드에서 첫 번째 카드를 가장 뒤로 옮긴다. 그러고 나서 첫 번째 카드를 책상 위에 올려놓는다. 그런데 그 카드는 1이 되어야 한다.\n그리고 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고, 또 가장 앞에 있는 카드를 가장 뒤로 옮긴다.(2번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는다. 그런데 그 카드는 2가 되어야 한다.\n또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고... (3번 반복) 그리고 가장 앞에 있는 카드를 책상위에 올려놓는데 그것은 3이 된다.\n또 남은 카드 중에서 첫 번째 카드를 가장 뒤로 옮기고.. (4번 반복) 그리고 가장 앞에 있는 카드를 책상 위에 올려놓는데 그것은 4이다.\n위 과정을 계속 반복하여 N번 카드만 남을 때 까지 반복한다.\n\n위와 같은 카드를 하려면 미리 카드의 순서를 알고 있어야 한다. 카드의 개수 N이 주어져 있을 때 위의 마술을 하기 위한 카드의 초기 순서를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다.\n",
        "output_text": "첫 번째 줄부터 N번째 줄까지 차례로 카드의 순서를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 476.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "165": {
        "problem_text": "전쟁 당시 Baekjoon World의 국왕은 Cube World를 공격할 작전을 세운 적이 있습니다. Baekjoon World와 Cube World는 p개의 지점과 w개의 길로 표현됩니다. 모든 길은 양방향이며, 각 길마다 너비가 존재하여 이에 비례하는 수의 군사가 지나갈 수 있습니다.\nBaekjoon World의 국왕은 군사들이 뭉치는 것이 유리하다고 생각해서, 미리 Cube World로 가는 경로를 정해 두고 그 경로로만 모든 군사를 보냈습니다. Baekjoon World의 국왕은 총명해서, 경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 최대화하는 경로를 택했습니다.\n그런데 전쟁 때문에 어느 길로 보냈는지에 대한 기록이 불타 없어져 버렸습니다. 전쟁사를 완성하려면 이 기록이 꼭 필요합니다. 위대한 과학자인 당신이 다시 복구해 주세요.\n",
        "input_text": "첫 줄에 p와 w가 공백을 사이에 두고 주어집니다. (2 ≤ p ≤ 1 000; 1 ≤ w ≤ 50 000)\n다음 줄에 Baekjoon World의 수도 c와 Cube World의 수도 v가 공백을 사이에 두고 주어집니다. (0 ≤ c, v < p; c ≠ v)\n다음 w줄에 길이 연결하는 두 지점 wstart, wend,와 길의 너비 wwidth가 공백을 사이에 두고 주어집니다. (0 ≤ wstart, wend < p; wstart ≠ wend; 1 ≤ wwidth ≤ 1 000)\n",
        "output_text": "첫 줄에 Baekjoon World의 국왕이 정한 경로 상에 있는 길 중 너비가 가장 좁은 길의 너비를 출력합니다.\n",
        "memory_median": 3268.0,
        "time_median": 16.0,
        "length_median": 1002.5,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "166": {
        "problem_text": "BOJ의 인기스타, 방송인 권욱제는 통신 회사에 취업했다. 현재 이 통신 회사는 너무나 큰 통신망을 한 지사에서 관리하느라 큰 비용을 지불하고 있었다. 그래서 회사는 최근 IT의 트렌드 중 하나인 '탈중앙화'에 편승하여, 통신망을 분할하도록 결정했다. 그래서 욱제한테 통신망을 분할 할때 발생하는 비용을 분석하도록 지시했다.\n현재 회사 망에는 1번부터 N번까지 총 N개의 통신 탑이 존재하며, 통신탑 간의 연결이 M개 존재한다. 이때 회사에서는 총 Q번 통신탑 간의 연결을 제거함으로써 하나의 통신망을 여러 개의 통신망으로 분리하려고 한다. 통신망이란, 통신탑의 연결을 통해 도달 가능한 통신탑들의 집합이다. 통신탑 간의 연결 관계를 제거할 때 드는 비용은 제거한 후 통신망이 두 개로 나누어진다면 나눠진 두 개의 통신망에 속한 통신탑들의 갯수의 곱이 되며, 나누어지지 않을 경우 0이다.\n\n<그림 1>\n그림 1을 예시로 할때, 연결 (3, 4)를 제거하면 {1, 2, 3}, {4, 5, 6}으로 분할 되며, 이때 발생하는 비용은 3 × 3 = 9가 된다. 대신 연결 (2, 3)을 제거하면, 망이 나눠지지 않았기에 비용은 0이 된다.\n욱제는 회사의 요청에 따라 Q번의 제거를 통해 나오는 비용의 합을 구해야 한다. 하지만 욱제는 회사의 통신망을 이용해 방송하기 바쁘기 때문에 우리가 도와주자.\n",
        "input_text": "첫 번째 줄에는 통신탑의 개수인 자연수 N, 통신탑 사이의 연결의 개수인 자연수 M, 통신망 연결 분할 횟수인 자연수 Q가 공백으로 구분되어 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ M ≤ 100,000, 1 ≤ Q ≤ M)\n두 번째 줄부터 M개의 줄에 걸쳐 두 개의 자연수 X, Y가 공백으로 구분되어 주어진다. 이는 X 통신탑과 Y 통신탑 사이에 연결이 있음을 뜻한다. (1 ≤ X, Y ≤ N, X ≠ Y)\n중복된 연결은 주어지지 않으며, 모든 통신탑은 처음엔 하나의 통신망에 속한다. 조건에 의해 자기 자신과 연결이 있는 통신탑은 없다.\n그 다음 줄부터 Q개의 줄에 걸쳐 제거될 연결의 번호인 자연수 A가 주어진다. 이는 A번째로 입력된 (X, Y)의 연결이 제거되었음을 의미한다. (1 ≤ A ≤ M)\n이미 제거된 연결은 다시 제거되지 않으며, 제거는 입력 순서대로 진행된다.\n",
        "output_text": "첫 번째 줄에 Q개의 연결을 순서대로 제거하는데 드는 비용의 합을 출력한다.\n",
        "memory_median": 4632.0,
        "time_median": 32.0,
        "length_median": 1228.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "167": {
        "problem_text": "내일부터 N일 동안 대구광역시에서 맥주 축제가 열립니다!\n이 축제에서는 무려 K종류의 맥주를 무료로 제공합니다.\n축제 주최자는 축제에서 더 많은 참가자들이 다양한 종류의 맥주를 즐겼으면 합니다. 그래서 축제에서 참가자들은 하루에 맥주 1병만 받을 수 있고, 이전에 받았던 종류의 맥주는 다시 받을 수 없습니다.\n맥주를 정말로 사랑하는 대학생 전씨는 무료 맥주 소식에 신이 났습니다. 전씨는 이 맥주 축제에 참가해 총 N일 동안 맥주 N병을 마시려 합니다.\n하지만 전씨에게는 큰 고민이 있었습니다. 전씨는 맥주를 사랑하지만, 도수가 높은 맥주를 마시면 기절하는 맥주병이 있습니다. 전씨는 맥주를 마시다 기절하면 늦잠을 자 다음 날 1교시 수업에 결석해 F를 받게 될 수도 있습니다.\n전씨는 고민을 해결하기 위해 천재석사 현씨과 천재박사 승씨에게 자신의 간을 강력하게 만들어달라고 부탁했습니다. 하지만 간을 강력하게 만드는 비용이 너무 비싸서, 전씨는 간을 가능한 한 조금만 강화할 계획을 세웠습니다.\n우선, K종류의 맥주에 각각 '선호도'와 '도수 레벨'을 매겼습니다. 선호도는 전씨가 해당 맥주를 얼마나 좋아하는지를 나타내는 수치이고, 도수 레벨은 해당 맥주의 도수가 얼마나 강한지를 나타내는 수치입니다. 편의상 전씨는 선호도와 도수 레벨을 정수로 매겼습니다.\n만약, 마시는 맥주의 도수 레벨이 전씨의 간 레벨보다 높으면 맥주병이 발병해 기절해버리고 맙니다.\n또한, 전씨는 맥주병에 걸리지 않으면서도 자신이 좋아하는 맥주를 많이 마시고 싶어합니다. 따라서, 마시는 맥주 N개의 선호도 합이 M이상이 되게 하려 합니다.\n거창한 계획을 세운 전, 현, 승 세 사람은 서로 머리를 맞대고 고민하다가, 스트레스를 받아 연구를 집어치고 맥주를 마시러 떠나버렸습니다.\n이를 본 여러분은 세 사람을 대신해 조건을 만족하는 간 레벨의 최솟값을 출력하는 프로그램을 만들어 주려고 합니다.\n세 사람을 도와주세요!\n",
        "input_text": "첫 번째 줄에 축제가 열리는 기간 N (1 ≤ N ≤ 200,000) 과, 채워야 하는 선호도의 합 M (1 ≤ M < 231) 과, 마실 수 있는 맥주 종류의 수 K (N ≤ K ≤ 200,000) 가 주어집니다.\n다음 K개의 줄에는 1번부터 K번 맥주의 선호도 vi (0 ≤ vi ≤ 10,000) 와 도수 레벨 ci (1 ≤ ci < 231) (vi, ci는 정수) 이 공백을 사이에 두고 주어집니다.\n1번부터 K번 맥주의 종류는 모두 다릅니다.\n",
        "output_text": "첫 번째 줄에 주어진 선호도의 합 M을 채우면서 N개의 맥주를 모두 마실 수 있는 간 레벨의 최솟값을 출력합니다.\n만약 아무리 레벨을 올려도 조건을 만족시킬 수 없으면 첫 번째 줄에 \"-1\" 하나만 출력하고 더 이상 아무것도 출력하지 않아야 합니다.\n",
        "memory_median": 6244.0,
        "time_median": 96.0,
        "length_median": 984.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "168": {
        "problem_text": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다.\n아래의 두 쿼리를 수행하는 프로그램을 작성하시오.\n\n1 i c: i번 간선의 비용을 c로 바꾼다.\n2 u v: u에서 v로 가는 단순 경로에 존재하는 비용 중에서 가장 큰 것을 출력한다.\n\n",
        "input_text": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.\n둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v와 비용 w가 주어진다.\n다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.\n다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.\n간선의 비용은 항상 1,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.\n",
        "memory_median": 24208.0,
        "time_median": 156.0,
        "length_median": 3104.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "169": {
        "problem_text": "석호촌에는 N 명의 사람이 살고 있다. 굉장히 활발한 성격인 석호촌 사람들은 옆 집 상도 아버님, 뒷집 하은 할머님 , 강 건너 유리 어머님 등 모두가 한 가족처럼 살아가고 있다.\n그러던 어느 날, 유구한 역사를 지닌 석호촌의 도서관에 화재가 나서 계보들이 모두 불타고 말았다. 그래도 계보는 있어야 하지 않겠느냐는 마을 어르신인 대일 촌장님의 의견에 따라 석호촌 사람들은 계보 복원가 호석에게 의뢰를 맡기기로 했다.\n적어도 현재를 함께 살아가는 N 명의 계보는 복원하고 싶은 호석이는 조사를 통해서 각자가 기억하는 조상들의 이름들을 구해냈다. 다행히도 석호촌의 맑은 정기 덕분에 기억력이 굉장히 좋은 주민들은 모든 조상을 완벽하게 기억하고 있다. 또한, 각 가문은 한 명의 시조를 root로 하는 트리 형태를 띈다는 것도 알아냈다. 이 때 \"조상\"이란, \"자신의 부모\"와 \"부모의 조상\"을 모두 합친 것을 의미한다.\n이를 기반으로 몇 개의 가문이 존재했는 지, 각 가문에 대한 정보를 출력하는 프로그램을 작성해서 호석이를 도와주자!\n",
        "input_text": "첫번째 줄에 석호촌에 살고 있는 사람의 수 N 이 주어진다. 두번째 줄에는 현재 살고 있는 사람들의 이름이 차례대로 주어진다. 모든 이름은 길이 1 이상 6 이하의 알파벳 소문자로 이뤄지며, 중복된 이름은 존재하지 않는다.\n세번째 줄에는 기억하는 정보의 개수 M 이 주어진다. 이어지는 M개의 줄에는 \"X Y\" 꼴로 기억들이 주어지는데, 이는 곧 X의 조상 중에 Y가 있다는 것을 의미하며 같은 정보가 중복되어 주어지지 않는다. 입력에 모순이 있는 경우는 주어지지 않는다.\n",
        "output_text": "첫번째 줄에는 가문의 개수 K 를 출력하라. 두 번째 줄에는 각 가문의 시조들의 이름을 공백으로 구분하여 사전순으로 출력하라.\n세번째 줄부터는 이름의 사전순 대로 사람의 이름과 자식의 수, 그리고 사전순으로 자식들의 이름을 공백으로 구분하여 출력하라.\n",
        "memory_median": 5160.0,
        "time_median": 292.0,
        "length_median": 1509.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "170": {
        "problem_text": "포닉스는 길이가 $N$인 순열 $A$와 네 개의 비어 있는 스택을 가지고 있다.\n\n길이가 $N$인 순열이란, $1$ 이상 $N$ 이하의 서로 다른 정수 $N$개가 임의로 나열된 수열을 말한다.\n스택이란 자료구조의 한 종류로 가장 나중에 삽입한 자료가 가장 먼저 나오는 후입선출 (Last In First Out, LIFO)의 특성을 가지고 있다.\n\n포닉스는 PPC를 맞아 더러워진 순열을 청소하려 한다.\n순열을 청소하는 것은 다음과 같은 과정을 통해 순열을 오름차순으로 정렬하는 것을 뜻한다. 즉 순열을 $1, 2, 3, \\cdots N$으로 만들어야 한다.\n\n순열 $A$의 원소들을 앞 원소부터 순서대로 네 개의 스택 중 하나에 삽입한다.\n순열 $A$의 모든 원소를 스택에 삽입했다면, 네 개 중 원하는 스택에서 수를 꺼내는 것을 반복하여 네 개의 스택에서 모든 수를 꺼낸다.\n꺼낸 수들을 꺼낸 순서대로 오른쪽에서 왼쪽으로 나열한다. 즉, 가장 처음에 꺼낸 수가 맨 뒤, 가장 나중에 꺼낸 수가 맨 앞에 위치하게 된다.\n\n포닉스가 주어진 순열을 청소할 수 있는지 판별해 보자.\n",
        "input_text": "첫째 줄에 순열의 길이 $N$이 주어진다. $(1 ≤ N ≤ 100\\,000)$\n둘째 줄에 순열 $A$의 원소 $A_i$가 공백으로 구분되어 주어진다. 모든 $A_i$는 $1$ 이상 $N$ 이하의 서로 다른 정수임이 보장된다. \n",
        "output_text": "포닉스가 순열을 청소할 수 있으면 YES, 불가능하다면 NO를 출력한다.\n",
        "memory_median": 2548.0,
        "time_median": 12.0,
        "length_median": 695.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "171": {
        "problem_text": "A, B, C로만 이루어졌고 길이가 |S|인 문자열 S가 있다. 당신은 이 문자열에 다음과 같은 시행을 할 수 있다.\n\nA와 그 뒤에 있는 B를 지운다.\nB와 그 뒤에 있는 C를 지운다.\n\n각 문자는 최대 한 번만 지울 수 있다.\n예를 들어 ABCBA를 보자. 각 문자에 왼쪽부터 1번, 2번, 3번. . . 과 같이 번호를 붙이면 다음과 같이 시행할 수 있다.\n\n1번 A와 2번 B를 지운다. 이 경우 시행의 횟수는 1번이고, 남은 문자열은 CBA이다. 어떤 두 문자를 골라도 시행의 조건을 만족시킬 수 없으므로, 더 이상 시행을 할 수 없다.\n1번 A와 4번 B를 지우고, 이어 2번 B와 3번 C를 지운다. 이 경우 시행의 횟수는 2번이고 남은 문자열은 A이다. 문자열에 남은 문자가 하나이므로, 더 이상 시행을 할 수 없다.\n\n이외에도 시행을 할 수 있는 여러 경우의 수가 있다.\n시행을 할 수 있는 최대 횟수를 구해라.\n",
        "input_text": "첫 번째 줄에 문자열 S가 주어진다.\n",
        "output_text": "첫 번째 줄에 답을 출력한다.\n",
        "memory_median": 3864.0,
        "time_median": 8.0,
        "length_median": 719.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "172": {
        "problem_text": "임스는 연계 기술을 사용하는 게임을 플레이 중에 있다. 연계 기술은 사전 기술과 본 기술의 두 개의 개별 기술을 순서대로 사용해야만 정상적으로 사용 가능한 기술을 말한다.\n하나의 사전 기술은 하나의 본 기술과만 연계해서 사용할 수 있으며, 연계할 사전 기술 없이 본 기술을 사용했을 경우에는 게임의 스크립트가 꼬여서 이후 사용하는 기술들이 정상적으로 발동되지 않는다. 그렇지만 반드시 사전 기술을 사용한 직후에 본 기술을 사용할 필요는 없으며, 중간에 다른 기술을 사용하여도 연계는 정상적으로 이루어진다.\n임스가 사용할 수 있는 기술에는 $1$~$9$, $L$, $R$, $S$, $K$가 있다. $1$~$9$는 연계 없이 사용할 수 있는 기술이고, $L$은 $R$의 사전 기술, $S$은 $K$의 사전 기술이다.\n임스가 정해진 순서대로 $N$개의 기술을 사용할 때, 기술이 몇 번이나 정상적으로 발동하는지를 구해보자.\n단, 연계 기술은 사전 기술과 본 기술 모두 정상적으로 발동되었을 때만 하나의 기술이 발동된 것으로 친다.\n",
        "input_text": "첫 번째 줄에는 총 기술 사용 횟수 $N$이 주어진다. ($1 \\le N \\le 200\\,000$)\n두 번째 줄에는 임스가 사용할 $N$개의 기술이 공백 없이 주어진다.\n",
        "output_text": "임스가 정상적으로 기술을 사용한 총 횟수를 출력한다.\n",
        "memory_median": 2648.0,
        "time_median": 0.0,
        "length_median": 729.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "173": {
        "problem_text": "Sogang ICPC Team에는 색상 이름과 닉네임의 순서로 이여서 팀명을 지으면 ICPC 리저널에서 수상할 수 있다는 전설이 있다. 색상 이름들과 닉네임들이 주어질 때, Q개의 팀에 대해 다음 리저널에서 수상할 수 있을지 전설에 기반해 알려주는 프로그램을 작성하자.\n",
        "input_text": "첫째 줄에는 색상의 종류 C와 닉네임의 개수 N이 주어진다. (1 ≤ C, N ≤ 4,000)\n다음 C개의 줄에는 색상 이름 C개가 한 줄에 하나씩 주어진다. 색상 이름은 중복되지 않는다.\n다음 N개의 줄에는 Sogang ICPC Team 구성원들의 닉네임 N개가 한 줄에 하나씩 주어진다. 닉네임도 중복되지 않는다.\n다음 줄에는 팀의 개수 Q가 주어진다. (1 ≤ Q ≤ 20,000)\n다음 Q개의 줄에는 팀명 Q개가 한 줄에 하나씩 주어진다. 팀명은 중복되지 않는다.\n모든 색상 이름의 길이와 닉네임의 길이는 1,000글자를 넘지 않는다. 모든 팀명은 2,000글자를 넘지 않는다. 모든 문자열은 알파벳 소문자로만 이루어져 있다.\n",
        "output_text": "팀명이 입력된 순서대로, 전설에 따라 해당 팀이 다음 리저널에서 수상할 수 있다면 Yes, 아니라면 No를 출력한다.\n",
        "memory_median": 878764.0,
        "time_median": 2156.0,
        "length_median": 1769.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "174": {
        "problem_text": "일직선 상의 공간에 N개의 샘터가 존재하며, K채의 집을 짓고자 한다. 모든 샘터 및 집이 존재하는 위치는 항상 정수 형태이다. 이때 일직선 상의 공간에서 N개의 샘터 및 K채의 집들은 모두 서로 다른 위치에 존재한다. 다시 말해 하나의 위치에는 샘터가 있거나, 집이 있거나, 혹은 아무것도 없다.\nK채의 집을 지을 때, 가능하면 샘터의 주변에 집들을 지어서 K채의 모든 집에 대한 불행도의 합이 최소가 되도록 짓고자 한다. 이때 특정한 집에 대한 불행도란, 가장 가까운 샘터까지의 거리(Distance)로 정의된다. 예를 들어 특정한 집이 1에 위치하고, 그 집과 가장 가까운 샘터가 -5에 위치한다고 하면, 이 집의 불행도는 6이다.\nN=2, K=5일 때, 모든 집에 대한 불행도의 합이 최소가 되도록 집을 짓는 경우를 고려해보자. 아래 그림과 같이 두 개의 샘터가 0, 3의 위치에 존재한다고 가정하자.\n\n이때 다음과 같이 5채의 집을 설치하면, 각 집의 불행도의 합이 2+1+1+1+1=6로 최소가 된다. 집을 짓는 가능한 경우의 수는 여러 가지가 될 수 있지만, 불행도의 합을 6보다 작게 만드는 방법은 없다.\n\n",
        "input_text": "첫째 줄에 자연수 N과 K가 공백을 기준으로 구분되어 주어진다. (1 ≤ N, K ≤ 100,000) 둘째 줄에 N개의 샘터의 위치가 공백을 기준으로 구분되어 정수 형태로 주어진다. (-100,000,000 ≤ 샘터의 위치 ≤ 100,000,000) 단, 모든 N개의 샘터의 위치들은 서로 다르게 주어진다.\n",
        "output_text": "첫째 줄에 모든 집에 대한 불행도의 합의 최솟값을 출력한다.\n",
        "memory_median": 12988.0,
        "time_median": 140.0,
        "length_median": 952.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "175": {
        "problem_text": "어떤 암벽에 n(1 ≤ n ≤ 50,000)개의 홈이 파져 있다. 각각의 홈의 좌표는 (x, y)와 같이 표현되는데, |a - x| ≤ 2이고 |b - y| ≤ 2이면 (x, y)에서 (a, b)로 이동할 수 있다. 이와 같이 홈들을 이용하여 이동하면서 y = T(1 ≤ T ≤ 200,000)일 때까지, 즉 암벽의 정상까지 오르려고 한다.\n현재 당신이 있는 위치는 (0, 0)이다. 이 위치에서 시작하여 이동 회수를 최소로 하면서 정상에 오르려고 한다. 정상에 오를 때의 x좌표는 아무 것이나 되어도 상관이 없다.\n",
        "input_text": "첫째 줄에 n, T가 주어진다. 다음 n개의 줄에는 각 점의 x, y좌표가 주어진다. 두 좌표는 모두 0이상이며, x좌표는 1,000,000이하, y좌표는 T이하이다. 입력에 현재 위치인 (0, 0)은 주어지지 않는다.\n",
        "output_text": "첫째 줄에 최소 이동 회수를 출력한다. 만약, 정상에 오를 수 없으면 -1을 출력한다.\n",
        "memory_median": 5196.0,
        "time_median": 140.0,
        "length_median": 1378.0,
        "label": [
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "176": {
        "problem_text": "상렬이에게는 히스토그램 모양의 플라스틱 퍼즐 조각이 많이 있다. 상렬이는 이 퍼즐 조각들이 필요가 없어져 버릴 계획이다. 하지만 갑자기 플라스틱 판이 많이 필요해져 퍼즐에서 직사각형 모양을 잘라내 재활용하려고 한다.\n퍼즐의 모양이 주어질 때 자를 수 있는 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하라.\n히스토그램의 정보는 히스토그램을 구성하는 직사각형들의 높이로 주어진다. 각 직사각형의 너비는 1로 모두 같다.\n",
        "input_text": "히스토그램을 구성하는 직사각형의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 이어 N개의 줄에 걸쳐 각 직사각형의 높이인 정수 Hi(1 ≤ Hi ≤ 1,000,000)가 주어진다.\n",
        "output_text": "잘라낼 수 있는 직사각형의 최대 넓이를 출력하라.\n",
        "memory_median": 3568.0,
        "time_median": 20.0,
        "length_median": 870.5,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "177": {
        "problem_text": "1부터 N번까지로 수로 이루어진 순열이 있다.\n그리고 이 순열과 연관된 \"Inversion sequence\"라고 부르는 수열이 있다. 이 수열의 i번째 원소에는 순열에서 i보다 뒤에 나오면서 i보다 작은 수의 개수가 들어간다.\n2  4  5  1  7  6  3  8\n위의 순열이 있다면 이것의 Inversion sequence는\n0  1  0  2  2  1  2  0 이 된다.\n문제는 역으로 어떤 Inversion sequence가 주어지면 이것에 해당하는 순열을 찾는 프로그램을 작성하는 것이다.\n",
        "input_text": "순열의 크기 N(1 ≤ N ≤ 100,000)이 주어진다. 두 번째 줄에는 순열 1, 2, …, N에 해당하는 Inversion sequence가 공백으로 구분되어 들어온다.\n",
        "output_text": "입력으로 주어진 Inversion sequence에 대응하는 순열을 공백으로 구분하여 한 줄에 출력한다.\n",
        "memory_median": 3972.0,
        "time_median": 44.0,
        "length_median": 1133.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "178": {
        "problem_text": "N개의 수가 주어졌을 때, XOR한 값이 가장 큰 두 수를 찾는 프로그램을 작성하시오.\n즉, A1, A2, ..., AN 중에서 i ≠ j이면서 Ai XOR Aj 가 가장 큰 것을 찾아야 한다.\n",
        "input_text": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.\n둘째 줄에는 N개의 수가 주어진다. 입력으로 주어지는 수는 1,000,000,000보다 작거나 같은 음이 아닌 정수이다.\n",
        "output_text": "첫째 줄에 XOR한 값이 가장 큰 두 수의 XOR한 결과를 출력한다.\n",
        "memory_median": 47032.0,
        "time_median": 176.0,
        "length_median": 1391.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "179": {
        "problem_text": "광재는 전자기기 대여사업을 시작했다. 퇴근하기 전에 다음날 손님들에게 빌려줄 N개의 전자기기를 충전하려 한다. 사용 가능한 콘센트는 M개가 있고, 성능은 모두 동일하다.\n전자기기들은 한 번에 하나의 콘센트에서만 충전이 가능하고, 충전에 필요한 시간은 2k(0 ≤ k ≤ 15, k는 정수) 형태이다.\n광재의 빠른 퇴근을 위해 모든 전자기기를 충전하기 위한 최소 시간이 얼마인지 알려주자.\n",
        "input_text": "첫째 줄에 전자기기의 개수 N과 콘센트의 개수 M이 주어진다. (1 ≤ N ≤ 10,000, 1 ≤ M ≤ 10)\n둘째 줄에 충전에 필요한 시간 ti를 나타내는 N개의 정수가 주어진다. (20 ​≤ ti ≤ 215, ti = 2k (0 ≤ k ≤ 15, k는 정수))\n",
        "output_text": "충전에 필요한 최소 시간을 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 0.0,
        "length_median": 717.0,
        "label": [
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "180": {
        "problem_text": "\n모든 중앙대 컴퓨터공학부(소프트웨어학부) 학생들은 미인이다.\n지무근은 중앙대 컴퓨터공학부 학생이다.\n그러므로 지무근은 미인이다.\n\n위 연역 논증은 대표적인 삼단논법의 예시이다. 삼단논법이란 전제 두 개와 결론 하나로 이루어진 연역 논증이다. 이것을 응용하면, n개의 전제가 있을 때 m개의 결론을 도출할 수 있을 것이다. 이때의 n과 m은 모든 의미에서 적절한 수라고 가정하자. 자세한 것은 입출력 예시를 확인하자.\n",
        "input_text": "첫째 줄에 정수 n(2 ≤ n ≤ 26)이 주어진다.\n둘째 줄부터 n개의 줄에 걸쳐 각 줄에 전제가 하나씩 주어진다. 전제는 모두 a is b의 형식으로 주어지며 a와 b는 서로 다른 임의의 알파벳 소문자이다. 특별한 명시는 없지만 모든 전제는 “모든 a는 b이다”라는 의미이다. 하지만 “모든 b는 a이다”의 의미는 될 수 없다. 또한 a는 b이면서 c일 수 없으나, a와 b가 동시에 c일 수는 있다.\nn + 2번째 줄에 정수 m(1 ≤ m ≤ 10)이 주어진다. 그 다음 m개의 줄에 걸쳐 각 줄에 하나의 결론이 전제와 같은 형식으로 주어진다.\n",
        "output_text": "m개의 줄에 걸쳐 각 줄에 결론이 참인지 거짓인지 출력하라. 참일 경우 T, 거짓일 경우 F를 출력하라. 알 수 없는 경우도 거짓이다. 답은 필히 대문자로 출력해야 한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 882.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "181": {
        "problem_text": "\n경재씨는 저녁 약속을 가기 전 챙기지 않은 물건들이 있는 지 확인하고 있다. 필요한 물건은 전부 챙긴 것 같았고 외출 후 돌아오는 길에 경재씨는 외쳤다.\n\"아 맞다 우산!!!\"\n경재 씨는 매번 외출하고 나서야 어떤 물건을 집에 놓고 왔다는 것을 떠올릴 때마다 자책감에 시달리는 것이 너무 싫었다.\n외출이 잦은 경재 씨는 반복되는 일을 근절하기 위해 꼭 챙겨야 할 물건들을 정리해보았다. 하지만 지갑, 스마트폰, 우산, 차 키, 이어폰, 시계, 보조 배터리 등 종류와 개수가 너무 많았다.\n평소 불필요한 움직임을 아주 싫어하는 경재 씨는 이 물건들을 최대한 빠르게 챙겨서 외출하는 이동 경로를 알고 싶었다.\n경재 씨는 한 걸음에 상하좌우에 인접한 칸으로만 움직일 수 있다.\n경재 씨를 위해 집을 위에서 바라본 모습과 챙겨야 할 물건들의 위치들을 알고 있을 때, 물건을 모두 챙겨서 외출하기까지 최소 몇 걸음이 필요한지 구하는 프로그램을 작성하자.\n",
        "input_text": "첫 번째 줄에는 집의 가로 길이 N과 세로 길이 M이 입력된다. (3 ≤ N, M ≤ 50)\n두 번째 줄부터는 집의 구조가 예제 입력과 같이 주어진다.\n비어있는 곳은 '.'로 벽은 '#'로 입력된다. 경재 씨의 현재 위치는 S, 나가는 문의 위치는 E, 챙겨야 하는 물건은 종류에 상관없이 X로 입력된다.\n챙겨야 하는 물건은 최대 5개까지 있을 수 있다. 집은 언제나 벽으로 둘러싸여 있고, 나가는 문은 언제나 하나이다.\n",
        "output_text": "S에서 출발하여 모든 물건을 챙겨서 E까지 도착할 수 있는 최소 시간을 출력한다. 모든 물건을 챙길 수 없는 경우는 주어지지 않는다.\n",
        "memory_median": 2100.0,
        "time_median": 0.0,
        "length_median": 1926.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "182": {
        "problem_text": "길이가 같은 두 개의 이진수 코드 A와 B가 있다고 하자. 이 두 코드 사이의 해밍 거리는 A와 B의 각 비트를 왼쪽부터 오른쪽으로 차례대로 비교할 때 서로 다른 값을 가진 비트의 수이다. 예를 들어, A=010010, B=011011 이라고 하면, 세 번째 비트와 여섯 번째 비트만 서로 다르므로 이 두 코드 사이의 해밍 거리는 2이다.\n우리는 총 N개의 이진 코드를 가지고 있고, 각 코드의 길이는 K로 같다.\n예를 들어, 다음과 같이 길이가 3인 5개의 이진 코드들이 있다.\n\nA=000\nB=111\nC=010\nD=110\nE=001\n\n두 코드 A와 B사이의 해밍 거리를 H(A,B)로 표현한다. 그러면, H(A,B)=3, H(A,C)=1, H(A,D)=2, H(A,E)=1 이다.\n우리는 이진 코드들에 대해 해밍 경로를 찾고자 한다. 해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다. 위의 예에서 (A,C,D)는 코드 A와 C의 해밍 거리가 1이고, 코드 C와 D의 해밍 거리가 1이므로 해밍 경로이다. (A,E,B)는 코드 A와 E의 해밍 거리는 1이지만, 코드 E와 B의 해밍 거리가 2이므로 해밍 경로가 아니다.\n이 문제는 주어진 두 코드 사이에 가장 짧은 해밍 경로를 구하는 프로그램을 작성하는 것이다.\n",
        "input_text": "첫째 줄에는 두 개의 정수 N과 K가 빈칸을 사이에 두고 주어진다(3 ≤ N ≤ 1,000, 2 ≤ K ≤ 30). 둘째 줄부터 N개의 줄에는 각 줄마다 길이가 K인 이진 코드가 하나씩 주어진다. 하나의 코드는 빈칸이 없이 주어진다. 코드들은 주어진 순서대로 1부터 N까지의 번호로 구분된다. 코드가 같은 경우는 없다. 그 다음 줄에는 해밍 경로를 찾고자 하는 서로 다른 두 개의 코드 A와 B가 각각의 코드번호로 주어진다.\n",
        "output_text": "입력으로 주어진 두 코드 사이에 해밍 경로가 존재하면 그 경로 중 가장 짧은 경로를 코드 A부터 코드 B까지 경로상의 코드 번호로 출력한다. 코드 번호를 출력할 경우에는 코드 번호 사이에 하나의 빈칸을 사이에 두고 출력한다. 만약 답이 여러 개 있으면 그 중에 하나만 출력하고, 경로가 존재하지 않으면 -1을 출력한다.\n",
        "memory_median": 2180.0,
        "time_median": 12.0,
        "length_median": 1325.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "183": {
        "problem_text": "그림 1은 어떤 도시의 주요 지점과 그 지점들 간의 이동시간을 나타낸 그래프이다. 그래프의 노드는 주요 지점을 나타내고 두 지점을 연결한 도로(에지)에 표시된 수는 그 도로로 이동할 때 걸리는 분 단위의 시간을 나타낸다. 두 지점 a와 b를 연결하는 도로는 도로(a,b)로 표시한다.\n\n그림 1\n예를 들어 도로(1,2)와 도로(2,3)를 통하여 지점1에서 지점3으로 갈 때 걸리는 시간은 3분이다. 도로는 모두 양방향이라고 가정하므로 도로(a,b)와 도로(b,a)를 지날 때 걸리는 시간은 항상 같다고 한다.\n어떤 범죄용의자가 입력 데이터에 표시된 도시로 진입하여 이 도시를 가장 빠른 시간 내에 빠져나가고자 한다. 그런데 이 사실을 알고 있는 경찰이 어떤 하나의 도로(에지)를 선택하여 이 도로에서 검문을 하려고 한다. 따라서 용의자는 이 도로를 피해서 가장 빠르게 도시를 탈출하고자 한다. 이 경우 경찰이 검문을 위하여 선택하는 도로에 따라서 용의자의 가장 빠른 탈출시간은 검문이 없을 때에 비하여 더 늘어날 수 있다.\n문제는 도로검문을 통하여 얻을 수 있는 탈출의 최대 지연시간을 계산하는 것이다. 추가설명은 다음과 같다.\n\n두 개의 지점을 직접 연결하는 도로가 있는 경우, 그 도로는 유일하다.\n도시의 지점(노드)은 1에서 N번까지 N개의 연속된 정수로 표시된다.\n용의자가 도시에 진입하는 지점은 항상 1번이고 도시를 빠져 나가기 위하여 최종적으로 도달해야하는 지점은 항상 N번 지점이다.\n용의자는 검문을 피해서 가장 빨리 도시를 빠져나가고자 하고, 경찰은 적절한 도로를 선택하여 이 용이자들의 탈출시간을 최대한 지연시키고자 한다.\n각 도시 지점 간을 이동하는 시간은 항상 양의 정수이다.\n\n입력 도시의 도로망에 따라서 경찰이 어떤 도로를 막으면 용의자는 도시를 탈출하지 못할 수도 있다. 이 경우 검문으로 인하여 지연시킬 수 있는 탈출시간은 무한대이다. 이 경우에는 -1을 출력해야 한다.\n그림 1에서 볼 때 검문이 없을 경우 용의자가 도시를 탈출하는데 걸리는 시간은 4분이다. 만일 경찰이 도로(4,3)을 막으면 그 탈출시간을 지연시킬 수 없으므로 지연시간은 0이다. 만일 도로(2,3)을 막으면, 용의자들이 가장 빠르게 탈출할 수 있는 시간은 5분이므로 탈출지연시간은 1분이고, 도로(3,6)을 막으면 탈출지연시간은 2분이다.\n여러분은 입력 데이터에 표시된 도로망을 읽고, 경찰이 한 도로를 막고 검문함으로써 지연시킬 수 있는 최대시간을 정수로 출력하여야한다. 만일 지연효과가 없으면 0을 출력해야하고, 도시를 빠져나가지 못하게 만들 수 있으면(지연시간이 무한대) -1을 출력해야 한다.\n",
        "input_text": "첫 줄에는 지점의 수를 나타내는 정수 N(6 ≤ N ≤ 1000)과 도로의 수 M(6 ≤ M ≤ 5000)이 주어진다. 그 다음 이어 나오는 M개의 각 줄에는 도로(a, b)와 그 통과시간 t가 a b t 로 표시된다. 단 이 경우 a < b 이고 1 ≤ t ≤ 10000이다.\n",
        "output_text": "경찰이 하나의 도로를 막음으로써 지연시킬 수 있는 최대 시간을 정수로 출력한다. (단, 그 지연시간이 무한대이면 -1을 출력해야 한다.)\n",
        "memory_median": 2308.0,
        "time_median": 96.0,
        "length_median": 1886.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "184": {
        "problem_text": "서강 나라는 N개의 도시와 M개의 도로로 이루어졌다. 모든 도시의 쌍에는 그 도시를 연결하는 도로로 구성된 경로가 있다. 각 도로는 양방향 도로이며, 각 도로는 사용하는데 필요한 비용이 존재한다. 각각 도시는 1번부터 N번까지 번호가 붙여져 있다. 그 중에서 1번 도시의 군주 박건은 모든 도시를 정복하고 싶어한다.\n처음 점거하고 있는 도시는 1번 도시 뿐이다. 만약 특정 도시 B를 정복하고 싶다면, B와 도로로 연결된 도시들 중에서 적어도 하나를 정복하고 있어야 한다. 조건을 만족하는 도시 중에서 하나인 A를 선택하면, B를 정복하는 과정에서 A와 B를 연결하는 도로의 비용이 소모된다. 박건은 한번에 하나의 도시만 정복을 시도하고 언제나 성공한다. 한 번 도시가 정복되면, 모든 도시는 경계를 하게 되기 때문에 모든 도로의 비용이 t만큼 증가하게 된다. 한 번 정복한 도시는 다시 정복하지 않는다.\n이때 박건이 모든 도시를 정복하는데 사용되는 최소 비용을 구하시오.\n",
        "input_text": "첫째 줄에 도시의 개수 N과 도로의 개수 M과 한번 정복할 때마다 증가하는 도로의 비용 t가 주어진다. N은 10000보다 작거나 같은 자연수이고, M은 30000보다 작거나 같은 자연수이다. t는 10이하의 자연수이다.\nM개의 줄에는 도로를 나타내는 세 자연수 A, B, C가 주어진다. A와 B사이에 비용이 C인 도로가 있다는 뜻이다. A와 B는 N이하의 서로 다른 자연수이다. C는 10000 이하의 자연수이다.\n",
        "output_text": "모든 도시를 정복하는데 사용되는 최소 비용을 출력하시오.\n",
        "memory_median": 2768.0,
        "time_median": 12.0,
        "length_median": 1052.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "185": {
        "problem_text": "오늘 팀전을 다들 열심히 하시는 것을 보고 원장선생님은 세미나 실에 인터넷을 설치해 주기로 마음을 먹으셨다. 하지만 비 협조적인 코레스코 콘도는 원장님께서 학생들에게 인터넷 선을 연결하는 것에 대해서 일부에 대해 돈을 요구하였다.\n각각의 학생들의 번호가 1부터 N까지 붙여져 있다고 하면 아무나 서로 인터넷 선이 연결되어 있지 않다. P(P<=10,000)개의 쌍만이 서로 이어 질수 있으며 서로 선을 연결하는데 가격이 다르다.\n1번은 다행히 인터넷 서버와 바로 연결되어 있어 인터넷이 가능하다. 우리의 목표는 N번 컴퓨터가 인터넷에 연결하는 것이다. 나머지 컴퓨터는 연결 되어 있거나 연결 안되어 있어도 무방하다.\n하지만 코레스코에서는 K개의 인터넷 선에 대해서는 공짜로 연결해주기로 하였다. 그리고 나머지 인터넷 선에 대해서는 남은 것 중 제일 가격이 비싼 것에 대해서만 가격을 받기로 하였다. 이때 원장선생님이 내게 되는 최소의 값을 구하여라.\n",
        "input_text": "첫 번째 줄에 N(1 ≤ N ≤ 1,000), 케이블선의 개수 P(1 ≤ P ≤ 10,000), 공짜로 제공하는 케이블선의 개수 K(0 ≤ K < N)이 주어진다. 다음 P개의 줄에는 케이블이 연결하는 두 컴퓨터 번호와 그 가격이 차례로 들어온다. 가격은 1 이상 1,000,000 이하다.\n",
        "output_text": "첫째 줄에 원장선생님이 내게 되는 최소의 돈을 출력한다. 만약 1번과 N번 컴퓨터를 잇는 것이 불가능 하다면 -1을 출력한다.\n",
        "memory_median": 2444.0,
        "time_median": 8.0,
        "length_median": 1382.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "186": {
        "problem_text": "윌리암슨수액빨이딱따구리 세 식구가 정보섬에 올라왔다!\n세 윌리암슨수액빨이딱따구리는 정보섬 2층 어딘가에 모여 앉아 쉬고 있었는데, 저 멀리 청국장과 스시와 맥앤치즈가 있는 것을 발견했다! 아빠는 청국장, 엄마는 스시, 아이는 맥앤치즈가 먹고 싶다. 그래서 이 셋은 현위치로부터 가장 가까운 음식을 먹으러 가기로 했다.\n정보섬 2층은 An×m의 격자로 표현된다. 어떤 Ai,j가 0이면 빈 복도여서 지나갈 수 있고, 1이면 장애물로 막혀 지나갈 수 없다. 윌리암슨수액빨이딱따구리 식구는 2, 청국장은 3, 스시는 4, 맥앤치즈는 5이다. 윌리암슨수액빨이딱따구리는 단위 시간마다 한 칸, 상하좌우로 움직일 수 있다. 2, 3, 4, 5는 장애물이 아니므로 지나갈 수 있다. 격자 밖으로는 나갈 수 없으며 시작점으로부터 시작점까지의 거리는 0이다. 시작점은 윌리암슨수액빨리딱따구리의 위치, 즉 2의 위치이다.\n과연 윌리암슨수액빨이딱따구리 식구는 어떤 음식에 더 빨리 도착할 수 있을까?\n",
        "input_text": "첫째 줄에 정보섬 2층의 크기 n과 m이 주어진다. (1 ≤ n,m ≤ 3000, 4 ≤ n×m ≤ 9×106)\n이후 n행 m열에 걸쳐 0, 1, 2, 3, 4, 5로만 구성된 Ai,j가 주어진다. Ai,j와 Ai,j+1사이에 공백은 주어지지 않는다.\n2, 3, 4, 5는 반드시 하나씩 존재하며 2, 3, 4, 5가 아닌 나머지는 0 또는 1이다.\n",
        "output_text": "첫째 줄에 \"TAK\"(폴란드어로 YES를 의미)을 출력하고, 둘째 줄에 현위치에서 가장 빨리 도착할 수 있는 음식까지의 최단 거리를 출력한다.\n아무 음식도 먹을 수 없으면 \"NIE\"(폴란드어로 NO를 의미)를 출력한다. 이외의 출력은 하지 않는다.\nTAK과 NIE를 출력할 때 따옴표는 출력하지 않으며 반드시 대문자로 출력한다.\n",
        "memory_median": 46232.0,
        "time_median": 528.0,
        "length_median": 1275.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "187": {
        "problem_text": "VUNO는 빅데이터와 딥러닝 기술을 통해 학습한 인공지능을 이용해 의학 전문가들의 판단에 도움을 주는 Medical AI 솔루션을 개발하는 전문 기업이다.\nVUNO는 최근 SP라는 강력한 새로운 촬영 기법을 개발했다. 이 기법을 사용하면 인체 조직이 격자 형태로 표현되고, 격자의 각 칸에는 해당 부분의 각종 분석 결과를 압축한 하나의 데이터 값이 부여된다. VUNO는 이 SP 촬영 기법을 사용해 CPCU-1202라는 새로운 항체를 연구하려고 한다.\n조직에 CPCU-1202 백신을 놓으면, 격자의 칸 중 하나에 항체가 생성된다. 이 항체는 현재 속해 있는 칸과 같은 데이터 값을 가지면서 상하좌우로 인접한 칸이 있을 경우 그 칸으로 퍼져나간다. 이 과정을 계속 반복하다가 항체가 더 이상 퍼져나갈 수 없게 되면, 항체는 조직에 완전히 스며든다. 그 결과로, 항체가 퍼졌던 칸들의 데이터 값은 모두 어떤 동일한 값으로 새로 업데이트된다. 이때, 우연히 원래의 데이터 값과 업데이트된 데이터 값이 동일할 수도 있다.\nVUNO의 연구 데이터는 하나의 조직에 백신을 놓기 전의 촬영 결과와 백신을 놓은 뒤의 촬영 결과가 한 쌍으로 이루어져 있다. 두 장의 촬영 결과가 주어질 때, 이 조직에 놓은 백신이 CPCU-1202 백신일 가능성이 있는지 판단하는 프로그램을 작성하라.\n\n\n\n\n\n\n\n\n\n(a) 백신을 놓기 전\n(b) CPCU-1202 투약\n(c) 항체가 스며드는 중\n(d) 백신을 놓은 후\n\n\n그림 B.1: CPCU-1202 백신 투약 과정\n\n\n\n",
        "input_text": "첫 번째 줄에는 SP 촬영 결과의 크기를 의미하는 두 정수 $N$과 $M$이 주어진다. ($1 \\le N, M \\le 30$) 이는 촬영 결과가 세로로 $N$칸, 가로로 $M$칸 크기의 격자라는 것을 의미한다.\n다음 $N$개의 줄에는 백신을 놓기 전의 촬영 결과가 주어진다. 각 줄에는 $1$ 이상 $1\\ 000$ 이하의 정수 $M$개가 공백으로 구분되어 주어지며, $i$번째 줄의 $j$번째 수는 촬영 결과의 $i$번째 행 $j$번째 칸의 데이터 값을 의미한다.\n다음 $N$개의 줄에는 백신을 놓은 뒤의 촬영 결과가 위와 동일한 형식으로 주어진다.\n",
        "output_text": "촬영 대상이 맞은 백신이 CPCU-1202 백신일 수 있다면 YES, 그럴 수 없다면 NO 를 출력하라.\n",
        "memory_median": 2032.0,
        "time_median": 0.0,
        "length_median": 1609.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "188": {
        "problem_text": "일요일 아침에 형택이는 Maroon5의 Sunday Morning이란 노래를 들으면서 여자친구와의 로맨틱한 여행을 떠나기로 했다. 형택이는 이것저것 환상에 빠져있다가, 계획을 세우는데 실패했다. 따라서, 주위에 있는 숲을 같이 탐험하기로 했다.\n깊은 숲속에는 정말 아름다운 꽃이 하나있다. 형택이는 여자친구의 마음을 감동시키기 위해서, 꽃을 보여주면서 자신의 마음을 전해주려고 급하게 계획했다.\n불행하게도, 사람들이 숲에다 쓰레기를 버려서 형택이의 계획은 정말 망가지기 직전이다.\n형택이는 그동안 여자친구와 사귀면서 2가지 깨달은 것이 있는데, 한 가지는 쓰레기를 통과해서 지나가는 것을 정말 싫어하는 것이고, 쓰레기를 따라 옆을 지나가는 것도 정말 불편하게 느낀다는 것이다.\n형택이는 방금 쓰레기가 어디에있는지 조사를 마쳤다. 입력으로 숲의 지도가 주어진다. S는 형택이와 여자친구의 데이트 시작장소를  나타내고, F는 꽃이 있는 위치를 나타내고, g는 쓰레기가 있는 위치를 나타낸다. 그리고 .은 아무것도 없는 깨끗한 칸이다.\n형택이의 목표는 S에서 F까지 가는데, 쓰레기로 차있는 칸을 되도록이면 적게 지나가는 것이다. 형택이와 여자친구는 한 번에 한 칸 움직일 수 있다. 가로 or 세로로 한 칸 움직일 수 있다. 만약 되도록 적게 지나가는 경우의 수가 여러개라면, 쓰레기 옆을 지나가는 칸의 개수를 최소로 해서 지나려고 한다. 만약 어떤 칸이 비어있는데, 인접한 칸에 쓰레기가 있으면 쓰레기 옆을 지나는 것이다. 그리고, S와 F는 세지 않는다.\n",
        "input_text": "첫째 줄에 숲의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 3보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 숲의 지도가 주어진다. 숲의 지도는 S, F, g, . 만으로 이루어져 있다. S는 반드시 모서리에 위치해 있고, F는 모서리에 위치해있지 않다. 그리고 S와 F는 반드시 하나만 주어진다.\n",
        "output_text": "첫째 줄에 형택이와 여자친구가 가장 최적의 방법으로 숲을 지났을 때, 지나가는 쓰레기의 최소 개수를 출력하고, 공백으로 구분 한 후에 쓰레기 옆을 지나가는 칸의 개수를 출력한다.\n",
        "memory_median": 2052.0,
        "time_median": 0.0,
        "length_median": 2078.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "189": {
        "problem_text": "마포구에는 모든 대학생이 입사를 희망하는 굴지의 대기업 ㈜승범이네 본사가 자리를 잡고 있다. 승범이는 ㈜승범이네의 사장인데, 일을 못 하는 직원들에게 화가 난 나머지 전 직원을 해고하고 신입사원을 뽑으려 한다. 1차 서류전형이 끝난 뒤 합격자들은 면접을 준비하게 되었다.\n면접자들은 서로 다른 N개의 도시에 거주한다. 승범이는 면접자들의 편의를 위해 거주 중인 N개 도시 중 K개의 도시에 면접장을 배치했다. 도시끼리는 단방향 도로로 연결되며, 거리는 서로 다를 수 있다. 어떤 두 도시 사이에는 도로가 없을 수도, 여러 개가 있을 수도 있다. 또한 어떤 도시에서든 적어도 하나의 면접장까지 갈 수 있는 경로가 항상 존재한다.\n모든 면접자는 본인의 도시에서 출발하여 가장 가까운 면접장으로 찾아갈 예정이다. 즉, 아래에서 언급되는 '면접장까지의 거리'란 그 도시에서 도달 가능한 가장 가까운 면접장까지의 최단 거리를 뜻한다.\n속초 출신 승범이는 지방의 서러움을 알기에 각 도시에서 면접장까지의 거리 중, 그 거리가 가장 먼 도시에서 오는 면접자에게 교통비를 주려고 한다.\n승범이를 위해 면접장까지의 거리가 가장 먼 도시와 그 거리를 구해보도록 하자.\n",
        "input_text": "첫째 줄에 도시의 수 N(2 ≤ N ≤ 100,000), 도로의 수 M(1 ≤ M ≤ 500,000), 면접장의 수 K(1 ≤ K ≤ N)가 공백을 두고 주어진다. 도시는 1번부터 N번까지의 고유한 번호가 매겨진다.\n다음 M개의 줄에 걸쳐 한 줄마다 도시의 번호 U, V(U ≠ V)와 도로의 길이 C(1 ≤ C ≤ 100,000)가 공백을 두고 순서대로 주어진다. 이는 도시 U에서 V로 갈 수 있는 도로가 존재하고, 그 거리가 C라는 뜻이다.\n마지막 줄에 면접장이 배치된 도시의 번호 K개가 공백을 두고 주어진다.\n",
        "output_text": "첫째 줄에 면접장까지 거리가 가장 먼 도시의 번호를 출력한다. 만약 그런 도시가 여러 곳이면 가장 작은 번호를 출력한다.\n둘째 줄에 해당 도시에서 면접장까지의 거리를 출력한다.\n",
        "memory_median": 21364.0,
        "time_median": 280.0,
        "length_median": 1308.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "190": {
        "problem_text": "욱제는 구사과의 열렬한 팬이다. 오늘 욱제는 구사과에게 선물()을 전달해주려고 한다. 지난 며칠간의 관찰 끝에 욱제는 구사과의 이동 패턴을 모두 파악했다.\n구사과가 있는 곳은 1×N 크기의 직사각형 지도로 나타낼 수 있으며, 1×1크기의 정사각형으로 나누어져 있다. 구사과의 위치는 (1, x)로 나타낼 수 있으며, (1, x)는 왼쪽에서부터 x번째 칸을 의미한다.\n지도의 각 칸에는 E, W중의 한 문자가 쓰여져 있는데, 구사과는 이 문자를 이용해서 이동한다. 구사과의 위치가 (1, x)인 경우에 E가 쓰여져 있는 칸에 서 있었다면, (1, x+1)로, W의 경우에는 (1, x-1)로 순간이동한다. 구사과는 지치지 않기 때문에, 계속해서 이동한다.\n욱제는 구사과의 위치를 모르기 때문에, 구사과가 이동을 시작하는 위치와 관계없이 선물을 주는 방법을 알아내려고 한다. 최소 몇 개의 칸 위에 선물을 놓으면, 구사과가 항상 선물을 가져가는지 구하는 프로그램을 작성하시오. 선물이 놓여진 칸에 구사과가 이동하면, 구사과는 항상 선물을 가져간다.\n",
        "input_text": "첫째 줄에 골목길의 길이 N이 주어진다. (2 ≤ N ≤ 1,000)\n둘째 줄에 길이 N짜리 구사과가 있는 곳의 지도가 주어진다.\n지도에 쓰여 있는대로 이동했을 때, 지도를 벗어나는 경우는 없다.\n",
        "output_text": "첫째 줄에 최소 몇 개의 칸에 선물을 놓아야 하는지 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 371.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "191": {
        "problem_text": "창영과 상근은 한 동굴을 놓고 소유권을 주장하고 있다. 두 사람은 막대기를 서로에게 던지는 방법을 이용해 누구의 소유인지를 결정하기로 했다. 싸움은 동굴에서 벌어진다. 동굴에는 미네랄이 저장되어 있으며, 던진 막대기가 미네랄을 파괴할 수도 있다.\n동굴은 R행 C열로 나타낼 수 있으며, R×C칸으로 이루어져 있다. 각 칸은 비어있거나 미네랄을 포함하고 있으며, 네 방향 중 하나로 인접한 미네랄이 포함된 두 칸은 같은 클러스터이다.\n창영은 동굴의 왼쪽에 서있고, 상근은 오른쪽에 서있다. 두 사람은 턴을 번갈아가며 막대기를 던진다. 막대를 던지기 전에 던질 높이를 정해야 한다. 막대는 땅과 수평을 이루며 날아간다.\n막대가 날아가다가 미네랄을 만나면, 그 칸에 있는 미네랄은 모두 파괴되고 막대는 그 자리에서 이동을 멈춘다.\n미네랄이 파괴된 이후에 남은 클러스터가 분리될 수도 있다. 새롭게 생성된 클러스터가 떠 있는 경우에는 중력에 의해서 바닥으로 떨어지게 된다. 떨어지는 동안 클러스터의 모양은 변하지 않는다. 클러스터는 다른 클러스터나 땅을 만나기 전까지 게속해서 떨어진다. 클러스터는 다른 클러스터 위에 떨어질 수 있고, 그 이후에는 합쳐지게 된다.\n동굴에 있는 미네랄의 모양과 두 사람이 던진 막대의 높이가 주어진다. 모든 막대를 던지고 난 이후에 미네랄 모양을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 동굴의 크기 R과 C가 주어진다. (1 ≤ R,C ≤ 100)\n다음 R개 줄에는 C개의 문자가 주어지며, '.'는 빈 칸, 'x'는 미네랄을 나타낸다.\n다음 줄에는 막대를 던진 횟수 N이 주어진다. (1 ≤ N ≤ 100)\n마지막 줄에는 막대를 던진 높이가 주어지며, 공백으로 구분되어져 있다. 모든 높이는 1과 R사이이며, 높이 1은 행렬의 가장 바닥, R은 가장 위를 의미한다. 첫 번째 막대는 왼쪽에서 오른쪽으로 던졌으며, 두 번째는 오른쪽에서 왼쪽으로, 이와 같은 식으로 번갈아가며 던진다.\n공중에 떠 있는 미네랄 클러스터는 없으며, 두 개 또는 그 이상의 클러스터가 동시에 떨어지는 경우도 없다.\n",
        "output_text": "입력 형식과 같은 형식으로 미네랄 모양을 출력한다.\n",
        "memory_median": 2184.0,
        "time_median": 24.0,
        "length_median": 2993.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "192": {
        "problem_text": "경비행기 독수리호가 출발지 S에서 목적지 T로 가능한 빠른 속도로 안전하게 이동하고자 한다. 이때, 경비행기의 연료통의 크기를 정하는 것이 중요한 문제가 된다. 큰 연료통을 장착하면 중간에 내려서 급유를 받는 횟수가 적은 장점이 있지만 연료통의 무게로 인하여 속도가 느려지고, 안정성에도 문제가 있을 수 있다. 한편 작은 연료통을 장착하면 비행기의 속도가 빨라지는 장점이 있지만 중간에 내려서 급유를 받아야 하는 횟수가 많아지는 단점이 있다. 문제는 중간에 내려서 급유를 받는 횟수가 k이하 일 때 연료통의 최소용량을 구하는 것이다. 아래 예를 보자.\n\n위 그림은 S, T와 7개의 중간 비행장의 위치를 나타내고 있는 그림이다. 위 예제에서 중간급유를 위한 착륙 허용 최대횟수 k=2라면 S-a-b-T로 가는 항로가 S-p-q-T로 가는 항로 보다 연료통이 작게 된다. 왜냐하면, S-p-q-T항로에서 q-T의 길이가 매우 길어서 이 구간을 위해서 상당히 큰 연료통이 필요하기 때문이다. 문제는 이와 같이 중간에 최대 K번 내려서 갈 수 있을 때 최소 연료통의 크기가 얼마인지를 결정하여 출력하면 된다. 참고사항은 다음과 같다.\n\n모든 비행기는 두 지점 사이를 반드시 직선으로 날아간다. 거리의 단위는 ㎞이고 연료의 단위는 ℓ(리터)이다. 1ℓ당 비행거리는 10㎞이고 연료주입은 ℓ단위로 한다.\n두 위치간의 거리는 평면상의 거리이다. 예를 들면, 두 점 g=(2,1)와 h=(37,43)간의 거리 d(g,h)는 \\(\\sqrt{(2-37)^2 + (1-43)^2}\\) = 54.671... 이고 50＜d(g,h) ≤ 60이므로 필요한 연료는 6ℓ가 된다.\n출발지 S의 좌표는 항상 (0,0)이고 목적지 T의 좌표는 (10000,10000)으로 모든 입력 데이터에서 고정되어 있다.\n출발지와 목적지를 제외한 비행장의 수 n은 3 ≤ n ≤ 1000이고 그 좌표 값 (x,y)의 범위는 0＜x,y＜10000의 정수이다. 그리고 최대 허용 중간급유 횟수 k는 0 ≤ k ≤ 1000이다.\n\n",
        "input_text": "첫 줄에는 n과 k가 하나의 공백을 사이에 두고 주어진다. 그 다음 n개의 줄에는 각 비행장 (급유지)의 정수좌표가 x y 형식으로 주어진다.\n",
        "output_text": "S에서 T까지 k번 이하로 중간급유 하여 갈 수 있는 항로에서의 최소 연료통 용량에 해당되는 정수를 출력한다.\n",
        "memory_median": 2188.0,
        "time_median": 24.0,
        "length_median": 1379.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "193": {
        "problem_text": "당신은 루머를 믿는가?\n한 유명 심리학 실험에서는 사람들에게 두 개의 줄을 보여주고, 어떤 줄이 더 긴지 말하라 했다. 사실 한 사람을 제외하고 나머지는 실험자에 의해 사전에 조작된 사람들이었다. 조작된 사람들은 사실상 더 짧은 줄을 더 길다고 말했다. 주변 모두가 같은 답변을 하자, 진짜 피실험자 또한 짧은 줄이 더 길다고 말했다. 이 실험은 사람들이 주변인의 영향을 강하게 받는다는 것을 보여주었는데, 루머도 이와 같다.\n루머는 최초 유포자로부터 시작한다. 최초 유포자는 여러 명일 수 있고, 최초 유포자를 제외하고 스스로 루머를 만들어 믿는 사람은 없다.\n매분 루머를 믿는 사람은 모든 주변인에게 루머를 동시에 퍼트리며, 군중 속 사람은 주변인의 절반 이상이 루머를 믿을 때 본인도 루머를 믿는다.\n루머를 믿는 순간부터 다른 말은 듣지 않기 때문에, 한번 믿은 루머는 계속 믿는다.\n이때, 사람들이 루머를 처음 믿기 시작하는 시간을 알아내 보자.\n",
        "input_text": "첫째 줄에 사람의 수 $N$이 주어진다. ($1 \\leq N \\leq 200\\ 000$) 이는 $1$번 사람부터 $N$번 사람까지 있음을 의미한다.\n둘째 줄부터 $N$개의 줄이 주어진다. 이 중 $i(1 \\leq i \\leq N)$번째 줄에는 $i$번 사람의 주변인들의 번호와 입력의 마지막을 나타내는 0이 공백으로 구분되어 주어진다. 번호는 $1$ 이상 $N$ 이하의 자연수이고, 같은 줄에 중복된 번호는 없다. 자기 자신이 주변인이거나 일방적으로 주변인인 경우는 없으며, 전체 양방향 주변인 관계는 $1\\ 000\\ 000$개를 넘지 않는다.\n다음 줄에는 루머를 퍼뜨리는 최초 유포자의 수 $M$이 주어진다. $(1 \\leq M \\leq N)$\n마지막 줄에는 최초 유포자의 번호가 공백으로 구분되어 주어진다. 최초 유포자의 번호는 중복되지 않는다.\n",
        "output_text": "$N$개의 정수 $t_1,t_2,\\cdots,t_N$을 공백 단위로 출력한다. $t_i$는 $i$번 사람이 루머를 처음 믿기 시작한 시간(분)이며, 충분히 많은 시간이 지나도 루머를 믿지 않을 경우 $-1$이다. 최초 유포자는 루머를 $0$분부터 믿기 시작했다고 생각한다.\n",
        "memory_median": 23816.0,
        "time_median": 524.0,
        "length_median": 1256.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "194": {
        "problem_text": "오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.\n\r\ndfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)\r\n        if (visited[x] = NO) then dfs(V, E, x);\r\n}\n",
        "input_text": "첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.\n다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.\n",
        "output_text": "첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n",
        "memory_median": 12492.0,
        "time_median": 104.0,
        "length_median": 791.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "195": {
        "problem_text": "노드가 $N$개인 이진 트리가 있다. 트리를 중위 순회와 유사하게 순회하려고 한다. 이를 유사 중위 순회라고 하자.\n순회의 시작은 트리의 루트이고 순회의 끝은 중위 순회할 때 마지막 노드이다. 이때 루트 노드는 항상 1번 노드이다.\n유사 중위 순회는 루트 노드에서 시작하며, 다음과 같이 진행된다.\n\n현재 위치한 노드의 왼쪽 자식 노드가 존재하고 아직 방문하지 않았다면, 왼쪽 자식 노드로 이동한다.\n그렇지 않고 현재 위치한 노드의 오른쪽 자식 노드가 존재하고 아직 방문하지 않았다면, 오른쪽 자식 노드로 이동한다.\n그렇지 않고 현재 노드가 유사 중위 순회의 끝이라면, 유사 중위 순회를 종료한다.\n그렇지 않고 부모 노드가 존재한다면, 부모 노드로 이동한다.\n유사 중위 순회를 종료할 때까지 1 ~ 4를 반복한다.\n\n\n위 그림에 있는 트리에서 중위 순회를 한다면 $4 \\rightarrow 2 \\rightarrow 5 \\rightarrow 1 \\rightarrow 6 \\rightarrow 3 \\rightarrow 7$ 순으로 순회를 한다.\n따라서, 유사 중위 순회의 끝은 노드 7이 된다.\n\n유사 중위 순회는 위 그림과 같이 루트인 노드 $1$에서 시작하여 노드 $7$에서 끝나고 $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 2 \\rightarrow 5 \\rightarrow 2 \\rightarrow 1 \\rightarrow 3 \\rightarrow 6 \\rightarrow 3 \\rightarrow 7$ 이와 같은 순서로 순회를 진행한다. 유사 중위 순회를 진행하면서 총 10번 이동하였다.\n여기서 이동이라는 것은 하나의 노드에서 다른 노드로 한번 움직이는 것을 의미한다. 예를 들면, 노드 1에서 노드 2로 가는 것을 한번 이동하였다고 한다.\n유사 중위 순회를 하면서 이동한 횟수를 구하려고 한다.\n",
        "input_text": "첫 번째 줄에 트리를 구성하는 노드의 개수 $N$이 주어진다.\n두 번째 줄부터 $N + 1$ 번째 줄까지 현재 노드 $a$, 현재 노드의 왼쪽 자식 노드 $b$, 현재 노드의 오른쪽 자식 노드 $c$가 공백으로 구분되어 주어진다. 만약 자식 노드의 번호가 -1인 경우 자식 노드가 없다는 것을 의미한다.\n",
        "output_text": "유사 중위 순회를 하면서 이동한 총 횟수를 출력한다.\n",
        "memory_median": 4564.0,
        "time_median": 32.0,
        "length_median": 839.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "196": {
        "problem_text": "상근이는 여자친구와의 드라이브를 위해서 운전을 배우고 있다. 도로 연수를 10년쯤 하다 보니 운전은 그럭저럭 잘하게 되었다. 하지만, 그는 유턴을 하지 못한다. 10년동안 도로 연수를 받았지만 유턴을 하지 못한다. 밥먹고 유턴만 연습했지만, 결국 유턴은 하지 못했다.\n상근이는 유턴을 연습하기 위해서 시간을 투자하는 대신에 유턴을 할 필요가 없고, 유턴이 금지된 마을로 이사가려고 한다.\n\n상근이가 이사가려고 하는 마을은 막다른 길이 있으면 안 된다. 막다른 길은 유턴을 하지 않고는 빠져나올 수 없기 때문이다. 어떤 마을의 지도가 주어졌을 때, 유턴을 하지 않고 마을의 모든 구역을 돌아다닐 수 있는지 없는지(막다른 길이 있는지 없는지)를 구하는 프로그램을 작성하시오. \n마을의 지도는 R × C 칸으로 이루어진 표로 생각할 수 있다. 각 칸에 빌딩이 있다면 'X'로 표시하고, 길이라면 '.'으로 표시한다. 모든 칸은 빌딩 또는 길이다. 상근이가 어떤 길 위에 있다면, 근처 네 방향(위,아래,오른쪽,왼쪽)의 길로 이동할 수 있다. 빌딩으로는 이동할 수 없다.\n이 마을에 막다른 길이 없다면, 상근이는 임의의 한 길에서 시작해서, 갈 수 있는 어떤 방향으로 움직이더라도, 유턴을 하지 않고 그 위치로 돌아올 수 있어야 한다.\n유턴은 방금 이동한 방향의 반대 방향으로 이동하는 것을 말한다.\n",
        "input_text": "첫째 줄에 마을의 크기 R과 C가 주어진다. (3 ≤ R, C ≤ 10)\n다음 R개 줄에는 마을의 지도가 주어진다. 모든 길은 서로 연결되어 있다. 또, 마을에는 적어도 두 개의 길이 있다.\n",
        "output_text": "첫째 줄에 마을에 막다른 길이 없다면 0을, 그렇지 않다면 1을 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 768.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "197": {
        "problem_text": "세준이는 등산광이다. 세준이는 높은 곳에서 도시를 내려다 보는 것을 좋아한다. 하지만, 겁이 많은 세준이는 어두워지기 전에 호텔로 내려오려고 한다.\n세준이가 가려고하는 산의 지도가 입력으로 주어진다. 산의 지도를 M이라고 했을 때, M[i][j]는 (i,j)의 높이가 M[i][j]라는 것을 의미한다. 그 값이 'A'-'Z'일 때는 0-25를 뜻하는 것이고, 'a'-'z'일 때는, 26-51을 뜻한다.\n세준이의 호텔은 (0,0)에 있다. 그리고, 세준이는 지금 위치에서 바로 인접한 정수 좌표 중 높이의 차이가 T보다 크지 않은 곳으로만 다닐 수 있다.\n만약 세준이가 현재 위치에서 높이가 낮은 곳이나 같은 곳으로 이동한다면 시간은 1초가 걸린다. 하지만 높은 곳으로 이동한다면 두 위치의 높이의 차이의 제곱만큼 시간이 걸린다. 예를 들어 높이가 5에서 높이가 9인 곳으로 간다면, 시간은 (5-9)2=16초가 걸린다. 하지만, 높이가 9인 곳에서 5인 곳으로 간다면 시간은 1초가 걸린다.\n산의 지도와, T, 그리고 어두워지는 시간 D가 주어졌을 때, 세준이가 D보다 크지 않은 시간 동안 올라갈 수 있는 최대 높이를 구하는 프로그램을 작성하시오.(세준이는 호텔에서 출발해서 호텔로 돌아와야 한다.)\n",
        "input_text": "첫째 줄에 산의 세로크기 N과 가로크기 M 그리고, T와 D가 주어진다. N과 M은 25보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 지도가 주어진다. T는 52보다 작거나 같은 자연수이고, D는 1,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 세준이가 갈 수 있는 가장 높은 곳의 높이를 출력한다.\n",
        "memory_median": 2168.0,
        "time_median": 64.0,
        "length_median": 2275.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "198": {
        "problem_text": "민승이는 놀러가기 위해 집을 나섰다. 민승이네 집에서 코레스코 콘도까지 가기 위해서는 복잡하게 얽혀있는 골목길들을 통과해야 한다.\n그런데, 어떤 길에는 깡패가 서식하고 있어, 그 길을 지나게 되면 깡패에게 일정한 양의 금품을 갈취당하게 된다. 그런가하면, 어떤 길에는 지나가던 행인들이 흘리고 간 금품들이 떨어져 있어, 그 길을 지나게 되면 일정한 양의 금품을 획득하게 된다. 한 번 지나간 길을 다시 방문하더라도 금품을 갈취당하거나 획득한다.\n골목길의 연결 상태와, 각 골목길을 지날 때 갈취당하거나 획득하게 되는 금품의 양이 주어졌을 때, 민승이가 최대한 유리한 경로를 따라 집에서 코레스코 콘도까지 가기 위해서는 어떻게 해야 하는지 출력하는 프로그램을 작성하시오. \n보유 중인 금품의 양이 음수가 될 수 있다. 최대한 유리한 경로 또는 최적의 경로는 민승이네 집에서 출발하여 코레스코 콘도에 도착하는 경로 중 금품의 양이 최대가 되는 경로이다. \n",
        "input_text": "첫째 줄에 골목길들이 교차하는 지점의 개수 n (2 ≤ n ≤ 100)과 골목길의 개수 m (1 ≤ m ≤ 20,000) 이 차례로 주어진다. 이어지는 m개의 행에 각각의 골목길을 나타내는 세 정수 u, v, w가 차례로 주어진다. 이는 u번 교차점에서 v번 교차점으로 이동할 수 있는 골목길이 나있다는 의미이다. 즉, 주어지는 골목길들은 기본적으로 모두 일방통행로이다. w (0 ≤ |w| ≤ 1,000)는 이 길을 지날 때 갈취당하거나 획득하게 되는 금품의 양이다. 음수는 갈취, 양수는 획득을 뜻한다.\n골목길의 교차점 번호는 1이상 n이하의 정수이다. 민승이네 집은 1번 교차점에 있고, 이곳 코레스코 콘도는 n번 교차점에 있다.\n",
        "output_text": "최적의 경로를 구할 수 있다면 민승이네 집부터 코레스코 콘도까지 가는 동안 거치게 되는 교차점들의 번호를 공백 하나를 사이에 두고 차례로 출력하면 된다. 그런데, 경우에 따라서는 최적의 경로라는 것이 존재하지 않는 상황이 발생한다. 어떠한 경우에 그런 상황이 발생하는지 생각해 보자. 그러한 경우에는 -1을 출력하도록 한다.\n최적의 경로가 여러 개 존재할 때는 아무거나 출력해도 된다.\n",
        "memory_median": 2292.0,
        "time_median": 4.0,
        "length_median": 1658.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "199": {
        "problem_text": "NxN 크기 체스판의 특정한 위치에 하나의 나이트가 존재한다. 이때 M개의 상대편 말들의 위치 값이 주어졌을 때, 각 상대편 말을 잡기 위한 나이트의 최소 이동 수를 계산하는 프로그램을 작성하시오.\r\n나이트는 일반적인 체스(Chess)에서와 동일하게 이동할 수 있다. 현재 나이트의 위치를 (X,Y)라고 할 때, 나이트는 다음의 8가지의 위치 중에서 하나의 위치로 이동한다.\n(X-2,Y-1), (X-2,Y+1), (X-1,Y-2), (X-1,Y+2), (X+1,Y-2), (X+1,Y+2), (X+2,Y-1), (X+2,Y+1)\nN=5일 때, 나이트가 (3,3)의 위치에 존재한다면 이동 가능한 위치는 다음과 같다. 나이트가 존재하는 위치는 K, 이동 가능한 위치는 노란색으로 표현하였다.\n\n예를 들어 N=5, M=3이고, 나이트가 (2,4)의 위치에 존재한다고 가정하자. 또한 상대편 말의 위치가 차례대로 (3,2), (3,5), (4,5)라고 하자. 이때 각 상대편 말을 잡기 위한 최소 이동 수를 계산해보자. 아래 그림에서는 상대편 말의 위치를 E로 표현하였다. 단, 본 문제에서 위치 값을 나타낼 때는 (행,열)의 형태로 표현한다.\n\n각 상대편 말을 잡기 위한 최소 이동 수는 차례대로 1, 2, 1이 된다.\n",
        "input_text": "첫째 줄에 N과 M이 공백을 기준으로 구분되어 자연수로 주어진다. (1 ≤ N ≤ 500, 1 ≤ M ≤ 1,000) 둘째 줄에 나이트의 위치 (X, Y)를 의미하는 X와 Y가 공백을 기준으로 구분되어 자연수로 주어진다. (1 ≤ X, Y ≤ N) 셋째 줄부터 M개의 줄에 걸쳐 각 상대편 말의 위치 (A, B)를 의미하는 A와 B가 공백을 기준으로 구분되어 자연수로 주어진다. (1 ≤ A, B ≤ N)\n단, 입력으로 주어지는 모든 말들의 위치는 중복되지 않으며, 나이트가 도달할 수 있는 위치로만 주어진다.\n",
        "output_text": "첫째 줄에 각 상대편 말을 잡기 위한 최소 이동 수를 공백을 기준으로 구분하여 출력한다.\n단, 출력할 때는 입력 시에 상대편 말 정보가 주어졌던 순서에 맞게 차례대로 출력한다.\n",
        "memory_median": 3220.0,
        "time_median": 12.0,
        "length_median": 1147.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "200": {
        "problem_text": "수학, 혹은 논리학에서 만약 무엇 이라면 뭣 일 것이다 하는 식의 명제가 널리 쓰인다. 예를 들어 \"P이면 Q일 것이다.\" 라는 명제는 “P => Q” 라는 기호로 표현된다. 이때의 P를 전건, Q를 후건이라고 한다.\n논리학에서 어떤 명제를 증명할 때 가장 널리 쓰이는 방법 중 한 가지가 바로 삼단 논법이다. 만약 두 명제 “P => Q\", \"Q => R\" 가 모두 참이면, 명제 \"P => R\"이 역시 참이 된다. 이러한 방법을 사용했을 때 명제 ”P => R\"이 증명되었다고 한다.\n어떤 참인 명제가 주어졌을 때, 이 명제가 참이므로 이 명제 자체도 증명될 수 있다고 할 수 있다. 하지만 “P => P”와 같은 명제는 항상 참이 되는데, 이런 식으로 전건과 후건이 같은 경우는 출력하지 않기로 한다.\nN개의 참인 명제들이 주어졌을 때, 증명될 수 있는 명제를 모두 구해내는 프로그램을 작성하시오. 명제를 증명하는 방법은 여러 가지가 있을 수 있지만, 위에서 언급한 방법만을 사용하기로 한다.\n",
        "input_text": "첫째 줄에 정수 N(1 ≤ N ≤ 10,000)이 주어진다. 다음 N개의 줄에는 참인 명제들이 주어진다. 명제는 \"P => Q\"의 꼴로 주어지는데, “=>”는 앞뒤가 공백으로 구분되어 있다. P나 Q는 명제를 나타내는 문자인데, 알파벳 대소문자 한 글자를 사용한다. 같은 명제가 여러 번 주어질 수도 있다.\n",
        "output_text": "첫째 줄에 출력할 명제의 개수 X개를 출력한다. 다음 X개의 줄에 증명될 수 있는 명제를 한 줄에 하나씩 출력한다. 명제를 출력할 때에는 전건 순으로 정렬하고, 전건이 같은 경우에는 후건 순으로 정렬한다. 알파벳은 대문자가 소문자에 우선한다. 즉, 정렬했을 때 A, B, …, Z, a, b, …, z 순서로 나와야 한다.\n",
        "memory_median": 2036.0,
        "time_median": 0.0,
        "length_median": 1103.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "201": {
        "problem_text": "희현이와 주경이는 The Game of Death를 좋아한다.\nThe Game of Death 규칙:\n\n플레이어는 각자 한 명씩 지목을 한다(자신도 가능).\n처음 시작하는 사람은 임의의 자연수 K를 말한다.\n시작한 사람부터 지목한 사람을 차례대로 따라가다가 K번째 지목당한 사람이 걸리게 된다.\n\n희현이는 희현이부터 이 게임을 시작할 때 이 게임에서 반드시 주경이를 반드시! 걸리게 하고 싶다. 주경이가 걸릴 수 있도록 희현이를 도와주자.\n",
        "input_text": "첫 줄에는 테스트 케이스의 숫자 T가 주어지며, 이어서 T번에 걸쳐 테스트 케이스들이 주어진다.\n매 테스트 케이스의 첫 줄에는 플레이어의 숫자 N(1 ≤ N ≤ 10,000)이 주어진다.\n이어서 N줄에 걸쳐 각 플레이어가 지명한 사람의 숫자 Ai(1 ≤ Ai ≤ N, 1 ≤ i ≤ N)이 주어진다.\n희현이는 1번, 주경이는 N번이다,\n",
        "output_text": "매 테스트 케이스마다 한 줄에 걸쳐 희현이가 주경이를 걸리게 하고 싶을 때 불러야 하는 최소 숫자 K를 출력한다.\n만약 어떤 숫자를 말해도 주경이가 걸리지 않는다면 0을 출력해야 한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 581.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "202": {
        "problem_text": "N개의 정점과 M개의 양방향간선으로 이루어진 단순 그래프 G가 있다. 단순 그래프란, self-loop 간선(한 정점에서 자기 자신을 이어주는 간선)이 없고, 임의의 두 정점 사이 최대 한 개의 간선이 있는 그래프를 말한다. 단순 그래프의 스패닝 트리(Spanning Tree)는 다음 조건을 만족하는 간선의 집합이다.\n\n스패닝 트리를 구성하는 간선의 개수는 N-1개이다.\n그래프의 임의의 두 정점을 골랐을 때, 스패닝 트리에 속하는 간선만 이용해서 두 정점을 연결하는 경로를 구성할 수 있어야 한다.\n\n스패닝 트리 중에서 간선의 가중치의 합이 최소인 것을 최소 스패닝 트리(Minimum Spanning Tree, MST)라고 부른다.\n이제 그래프에서 MST 게임을 하려고 한다.\n\nMST 게임은 그래프에서 간선을 하나씩 제거하면서 MST의 비용을 구하는 게임이다. MST의 비용이란 MST를 이루고 있는 가중치의 합을 의미한다. 각 턴의 점수는 해당 턴에서 찾은 MST의 비용이 된다. \n이 과정은 K턴에 걸쳐서 진행되며, 첫 턴에는 입력으로 주어진 그래프의 MST 비용을 구해야 한다.\n각 턴이 종료된 후에는 그 턴에서 구한 MST에서 가장 가중치가 작은 간선 하나를 제거한다.\n한 번 제거된 간선은 이후의 턴에서 사용할 수 없다.\n어떤 턴에서 MST를 만들 수 없다면, 그 턴의 점수는 0이다. 당연히 이후 모든 턴의 점수도 0점이다. 첫 턴에 MST를 만들 수 없는 경우도 있다.\n\n양방향 간선으로 이루어진 단순 그래프와 K가 주어졌을 때, 각 턴의 점수가 몇 점인지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 그래프 정점의 개수 N, 그래프 간선의 개수 M, 턴의 수 K가 주어진다. (2 ≤ N ≤ 1,000, 1 ≤ M ≤ min(10,000, N×(N-1)/2), 1 < K ≤ 100)\n그 후 M개의 줄에 간선의 정보가 주어진다. 간선의 정보는 간선을 연결하는 두 정점의 번호 x, y로 이루어져 있다. 같은 간선이 여러 번 주어지는 경우는 없다. 간선의 가중치는 주어지는 순서대로 1, 2, ..., M이다.\n정점의 번호는 1부터 N까지로 이루어져 있다.\n",
        "output_text": "한 줄에 공백으로 구분하여 K개의 정수를 출력해야 한다. K개의 정수는 각 턴에 얻는 점수를 나타낸다. \n",
        "memory_median": 2456.0,
        "time_median": 12.0,
        "length_median": 1390.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "203": {
        "problem_text": "서훈이는 오늘 있었던 알고리즘 과목 기말고사를 망쳐서 기분이 좋지 않다. 서훈이는 스트레스도 풀 겸 시험 문제로 나온 그래프를 불로 태우려고 한다.\n\n서훈이는 그래프의 정점 (위 그림에서 동그라미로 표시된 곳) 중 한 곳에 불을 붙일 수 있다. 정점에 불이 붙으면 곧바로 노드와 연결된 간선을 따라서 불이 전달된다. 간선 위에서는 불은 1초당 1만큼의 거리를 이동한다. 만약 어떤 간선의 양 끝 정점에 불이 붙은 경우 불은 간선의 중앙까지 태운 후 꺼진다.\n서훈이는 그래프를 최대한 빠른 시간 안에 전부 태우고 싶어한다. 서훈이를 도와 어떤 정점에 불을 붙일지 구하는 프로그램을 작성하여라. 단, 위 그림에서 간선끼리 교차하는 것은 무시한다.\n",
        "input_text": "첫 번째 줄에는 그래프의 정점의 수 N과 간선의 수 M이 주어진다. (2 ≤ N ≤ 200, N-1 ≤ M ≤ 20,000)\n두 번째 줄부터 M개의 줄에는 각 간선의 시작점 S, 끝점 E, 길이 L이 주어진다. (1 ≤ L ≤ 100)\n시작점과 끝점이 같은 간선도 있을 수 있으며, 특정 두 정점을 직접 연결하는 간선의 수가 여러 개일 수 있다. 또한, 그래프의 모든 정점들은 간선들을 통해서 연결되어 있다.\n",
        "output_text": "주어진 그래프를 모두 태우는 데 걸리는 최소 시간을 출력한다. 답은 소수점 아래 한 자리까지 출력한다. 문제의 특성 상 오차가 생길 일이 없으므로 출력 데이터와 정확히 일치해야 정답으로 처리한다.\n",
        "memory_median": 2528.0,
        "time_median": 40.0,
        "length_median": 1426.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "204": {
        "problem_text": "안양에 사는 상혁이는 4년간의 통학에 지쳐 서울에 집을 구하려고 한다. 상혁이가 원하는 집은 세가지 조건이 있다.\n\n맥세권 : 맥세권인 집은 맥도날드와 집 사이의 최단거리가 x이하인 집이다.\n스세권 : 스세권인 집은 스타벅스와 집 사이의 최단거리가 y이하인 집이다.\n맥세권과 스세권을 만족하는 집 중 최단거리의 합이 최소인 집\n\n통학 때문에 스트레스를 많이 받은 상혁이는 집을 선택하는 데 어려움을 겪고 있다. 똑똑한 여러분이 상혁이 대신 이 문제를 해결해 주자. 이사 갈 지역의 지도가 그래프로 주어지고 맥도날드와 스타벅스의 위치가 정점 번호로 주어질 때 상혁이가 원하는 집의 최단거리의 합을 출력하는 프로그램을 작성하시오. (맥도날드와 스타벅스가 아닌 정점에는 모두 집이 있다.)\n\n위의 예제 지도에서 사각형은 맥도날드를, 별은 스타벅스가 위치한 정점을 나타낸다. 각 원은 집이 있는 정점을 낸다. x가 6이고 y가 4일 때 가능한 집의 정점은 6이다. 맥도날드까지의 최단거리가 2, 스타벅스까지의 최단거리가 4로 총 합이 6이 되기 때문이다. 정점 7은 맥세권이면서 스세권이지만 맥도날드까지의 최단거리가 6, 스타벅스까지의 최단거리가 2로 총 합이 8로써 정점 6의 값보다 크므로 답이 아니다. 그 외의 정점 2, 3, 4는 맥세권이면서 스세권인 조건을 충족하지 못하므로 답이 될 수 없다.\n",
        "input_text": "첫줄에는 정점의 개수 V(3 ≤ V ≤ 10,000)와 도로의 개수 E(0 ≤ E ≤ 300,000)가 주어진다. 그 다음 E줄에 걸쳐 각 도로를 나타내는 세 개의 정수 (u,v,w)가 순서대로 주어진다. 이는 u와 v(1 ≤ u,v ≤ V)사이에 가중치가 w(1 ≤ w < 10,000)인 도로가 존재한다는 뜻이다. u와 v는 서로 다르며 다른 두 정점 사이에는 여러 개의 간선이 존재할 수도 있음에 유의한다. E+2번째 줄에는 맥도날드의 수 M(1 ≤ M ≤ V-2) 맥세권일 조건 x(1 ≤ x ≤ 100,000,000)가 주어지고 그 다음 줄에 M개의 맥도날드 정점 번호가 주어진다. E+4번째 줄에는 스타벅스의 수 S(1 ≤ S ≤ V-2)와 스세권일 조건 y(1 ≤ y ≤ 100,000,000)가 주어지고 그 다음 줄에 S개의 스타벅스 정점 번호가 주어진다. \n\n맥도날드나 스타벅스가 위치한 정점에는 집이 없다.\n한 정점에 맥도날드와 스타벅스가 같이 위치할 수 있다.\n집이 있는(= 맥도날드나 스타벅스가 위치하지 않은) 정점이 하나 이상 존재한다.\n\n \n",
        "output_text": " 상혁이가 원하는 집의 맥도날드까지의 최단거리와 스타벅스까지의 최단거리 합을 출력한다. 만일 원하는 집이 존재하지 않으면 -1을 출력한다.\n",
        "memory_median": 11092.0,
        "time_median": 168.0,
        "length_median": 1889.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "205": {
        "problem_text": "어제 선물을 모두 포장한 민식이는 이제 선물을 배달하려고 한다. 민식이가 선물을 배달할 곳은 이 문제를 읽는 사람들이 앉아 있는 교실이다. 교실은 직사각형모양이고, 모두 같은 크기의 정사각형 블록으로 나누어져 있다.\n입력으로 교실의 지도가 주어진다. 각각의 정사각형 블록은 다음과 같이 4가지 종류가 있다.\n\nS: 지금 민식이가 있는 곳이다. 이곳이 민식이가 배달을 시작하는 곳이고 1개만 있다.\nC: 민식이가 반드시 선물을 배달해야 하는 곳이다. 이러한 블록은 정확하게 2개 있다.\n#: 민식이가 갈 수 없는 곳이다.\n.: 민식이가 자유롭게 지나갈 수 있는 곳이다.\n\n민식이가 한 블록 동서남북으로 이동하는데는 1분이 걸린다. 민식이는 네가지 방향 중 하나로 이동할 수 있으며, 교실을 벗어날 수 없다. 민식이가 선물을 배달해야 하는 곳에 들어갈 때, 민식이는 그 곳에 있는 사람 모두에게 선물을 전달해야 한다. 이 상황은 동시에 일어나며, 추가적인 시간이 소요되지 않는다.\n민식이는 어느 누구도 자신을 보지 않았으면 하기 때문에, 멈추지 않고 매 시간마다 방향을 바꿔야 한다. 이 말은 같은 방향으로 두 번 연속으로 이동할 수 없다는 말이다. 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 교실의 세로 크기 N과 가로 크기 M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 교실의 지도가 주어진다.\n",
        "output_text": "첫째 줄에 민식이가 선물을 모두 배달하는데 걸리는 시간의 최솟값을 출력한다. 만약 불가능 할 때는 -1을 출력한다.\n",
        "memory_median": 2172.0,
        "time_median": 0.0,
        "length_median": 1915.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "206": {
        "problem_text": "보이저 1호는 1977년에 발사된 NASA의 태양계 무인 탐사선이다. 현재 보이저 1호는 태양권덮개 (헬리오시스)에 있다.\n보이저 1호와 같이 오랜 기간동안 활동하는 탐사선은 경로를 항성계를 만날 때 마다 라디오 시그널 메시지를 이용해서 기록하고 있다.\n항성계를 N * M개의 직사각형으로 나누어져 있는 N행 M열의 직사각형 그리드라고 생각해보자. 각 칸은 행성, 블랙홀을 포함할 수 있으며, 비어있을 수도 있다. 탐사선은 인접한 네 칸(위, 아래, 오른쪽, 왼쪽)중에서 하나를 골라서 시그널을 보낸다.\n시그널은 항상 일직선으로 전파되며, 행성을 만났을 경우에는 전파되는 방향이 90도로 바뀌게 된다. 행성은 '/'와 '\\'로 표현되는 두 종류가 있으며, 반사되는 법칙은 아래 그림과 같다.\n\n시그널이 블랙홀이 있는 칸을 만나거나 항성계를 벗어날 때 까지 계속 전파된다. 시그널이 인접한 칸으로 이동하는데 걸리는 시간은 1초이다.\n탐사선이 어느 방향으로 시그널을 보내면, 시그널이 항성계 내부에 있는 시간이 최대가 되는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 M이 주어진다. (1 ≤ N, M ≤ 500)\n다음 N개 줄에는 M개의 문자가 주어지며, '/'와 '\\'는 행성을, C는 블랙홀을, '.'는 빈 칸을 나타낸다.\n마지막 줄에는 탐사선이 있는 위치 PR과 PC가 주어진다. (1 ≤ PR ≤ N, 1 ≤ PC ≤ M)\n",
        "output_text": "첫째 줄에 시그널을 보내는 방향을 출력한다. (U: 위, R: 오른쪽, D: 아래, L: 왼쪽)\n만약, 방향이 여러 가지가 존재한다면, U, R, D, L의 순서 중 앞서는 것을 출력한다.\n둘째 줄에는 가장 긴 시간을 출력한다. 만약, 시그널이 항성계 내에서 무한히 전파될 수 있다면 \"Voyager\"를 출력한다.\n",
        "memory_median": 3248.0,
        "time_median": 12.0,
        "length_median": 1668.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "207": {
        "problem_text": "오늘은 할로윈이다. 상근이와 친구들은 할로윈을 기념하기 위해 묘지를 방문했다. 상근이와 친구들은 한 명씩 묘지로 들어가고, 혼자서 묘지의 출구를 찾아야 한다. 이제, 상근이의 차례가 돌아왔다.\n상근이가 어렸을 적에 할머니는 상근이에게 할로윈 밤에 묘지에는 귀신 구멍이 나타난다고 말해주었다. 귀신 구멍으로 들어가면, 묘지의 다른 장소로 다시 나오게 된다. 이 구멍은 시간을 이동할 수 있는 구멍이다. 귀신 구멍에 떨어지면, 특정 시간이 지난 후(또는 이전)에 평행 우주의 다른 구멍에서 나오게 된다. \n묘지는 W × H 크기의 그리드로 나타낼 수 있다. 묘지의 입구는 (0, 0)이고, 출구는 (W-1, H-1)이다. 상근이는 겁이 많기 때문에, 최대한 빨리 묘지를 나가려고 한다. 그리고 상근이는 이동하던 도중 출구에 도달하면 뒤도 돌아보지 않고 그 즉시 묘지를 빠져나갈 생각이다. 상근이는 현재 있는 칸과 동, 서, 남, 북으로 인접한 칸으로 이동할 수 있다. 각 칸은 잔디, 묘비, 또는 귀신 구멍이다.\n\n묘비는 매우 높기 때문에, 묘비가 있는 칸으로는 이동할 수 없다.\n귀신 구멍이 있는 칸으로 이동하면, 특정 시간이 지난 후에 묘지의 다른 곳에서 상근이가 나타나게 된다. 시간은 귀신 구멍마다 다르며, 양수, 음수, 0 중 하나이다.\n잔디가 있는 칸으로는 자유롭게 이동할 수 있다.\n\n상근이는 묘지를 빨리 나가기 위해 귀신 구멍도 이용할 것이다. 묘지를 나갈 수 없는 경우나, 계속해서 과거로 이동하는 경우가 존재할 수도 있다.\n\n묘지가 위와 같이 생긴 경우(문제의 두 번째 예제)를 살펴보자. 묘비는 (2,1)와 (3,1)에 있고, 귀신 구멍은 0초만에 (3,0)로 들어가서 (2,2)에서 나오는 구멍 하나가 있다. 묘지를 빠져나오는데 걸리는 가장 빠른 시간은 4초이며, 다음과 같다.\n(0,0) -> 동(1초) (1,0) -> 동(1초) (2,0) -> 동(1초) (3,0) -> 귀신구멍(0초) (2,2) -> 동(1초) (3,2)\n귀신 구멍을 이용하지 않는다면 가장 빠른 시간은 5초이다.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스의 첫째 줄에는 묘지의 너비 W와 높이 H가 주어진다. (1 ≤ W, H ≤ 30) 다음 줄에는 묘비의 개수 G (G ≥ 0)가 주어진다. 다음 G개 줄에는 묘비의 위치를 나타내는 두 정수 X와 Y가 주어진다. (0 ≤ X < W, 0 ≤ Y < H)\n다음 줄에는 귀신 구멍의 수 E (E ≥ 0)가 주어진다. 다음 E개 줄에는 귀신 구멍의 정보를 나타내는 X1, Y1, X2, Y2, T 가 주어진다. (X1, Y1)은 귀신 구멍의 위치이고, (X2, Y2)는 그 귀신 구멍으로 들어갔을 때, 나오는 곳의 위치이다. (0 ≤ X1, X2 < W, 0 ≤ Y1, Y2 < H) (X1,Y1)과 (X2,Y2)가 같을 수도 있다. T는 귀신 구멍에서 나오는데 걸리는 시간이다. (-10,000 ≤ T ≤ 10,000) T가 양수인 경우에는 귀신 구멍을 들어간 이후에 나온다는 의미이다. 두 귀신 구멍이 같은 장소에 있거나, 구멍에서 나오는 지점이 묘비인 경우는 없다. 묘비와 귀신 구멍이 (0, 0)이나 (W-1, H-1)에 있는 경우는 없다.\n입력의 마지막 줄에는 0 0이 주어진다.\n",
        "output_text": "각 테스트 케이스 마다 상근이가 과거로 계속해서 돌아간다면 \"Never\"를 출력하고, 출구를 빠져나올 수 없으면 \"Impossible\"을 출력한다. 그 외의 경우에는 묘지를 빠져나오는데 가장 빠른 시간을 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 132.0,
        "length_median": 2323.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "208": {
        "problem_text": "오랜만에 휴가를 나온 호근이는 문득 동아리방에 있는 장기가 하고 싶어졌다. 하지만 장기를 오랫동안 하지 않은 탓인지 예전에는 잘 쓰던 상을 제대로 쓰는 것이 너무 힘들었다. 호근이를 위해 상을 어떻게 써야 할지 도와주자.\n\n위 그림은 10×9 크기의 장기판을 나타내며, 상은 (5, 4)에, 왕은 (1, 4)에 자리 잡고 있는 기물이다. (0, 3)과 (2, 5)를 꼭짓점으로 하는 사각형과, (7, 3)과 (9, 5)를 꼭짓점으로 하는 사각형은 왕이 위치할 수 있는 궁성이라고 한다. 상은 위 그림과 같이 8가지 방법으로 움직일 수 있는데, 상, 하, 좌, 우로 한 칸을 이동한 후에 같은 방향 쪽 대각선으로 두 칸 이동한다.\n\n만약 상이 이동하는 경로에 위 그림과 같이 다른 기물이 있다면 상은 그쪽으로 이동할 수 없다. 또한, 상이 장기판을 벗어날 수도 없다.\n10×9 크기의 장기판 위에 상과 왕의 처음 위치가 주어졌을 때, 상이 왕에게 도달할 수 있는 최소 이동 횟수를 구하여라.\n",
        "input_text": "첫 번째 줄에는 상의 위치를 의미하는 정수 R1, C1이 주어진다.\n두 번째 줄에는 왕의 위치를 의미하는 정수 R2, C2가 주어진다. 장기판에서 Ri (0 ≤ Ri ≤ 9)는 행을, Ci (0 ≤ Ci ≤ 8)는 열을 의미한다.\n왕은 항상 궁성에 자리 잡고 있으며, 상과 왕의 위치는 겹치지 않는다.\n",
        "output_text": "상이 왕에게 도달할 수 있는 최소 이동 횟수를 출력한다. 만약 도달할 수 없다면 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1542.5,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "209": {
        "problem_text": "진영이는 다이어트를 위해 N×M 크기의 체육관을 달리려고 한다. 체육관은 1×1 크기의 칸으로 나누어져 있고, 칸은 빈 칸 또는 벽이다. x행 y열에 있는 칸은 (x, y)로 나타낸다.\n매 초마다 진영이는 위, 아래, 오른쪽, 왼쪽 중에서 이동할 방향을 하나 고르고, 그 방향으로 최소 1개, 최대 K개의 빈 칸을 이동한다.\n시작점 (x1, y1)과 도착점 (x2, y2)가 주어졌을 때, 시작점에서 도착점으로 이동하는 최소 시간을 구해보자.\n",
        "input_text": "첫째 줄에 체육관의 크기 N과 M, 1초에 이동할 수 있는 칸의 최대 개수 K가 주어진다.\n둘째 줄부터 N개의 줄에는 체육관의 상태가 주어진다. 체육관의 각 칸은 빈 칸 또는 벽이고, 빈 칸은 '.', 벽은 '#'으로 주어진다.\n마지막 줄에는 네 정수 x1, y1, x2, y2가 주어진다. 두 칸은 서로 다른 칸이고, 항상 빈 칸이다.\n",
        "output_text": "(x1, y1)에서 (x2, y2)로 이동하는 최소 시간을 출력한다. 이동할 수 없는 경우에는 -1을 출력한다.\n",
        "memory_median": 15444.0,
        "time_median": 72.0,
        "length_median": 1468.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "210": {
        "problem_text": "준형이는 내일 친구들을 만나기로 했다. 준형이와 친구들은 서로 다른 도시에 살고 있다.\n도시를 연결하는 도로는 일방 통행만 있어서 도시 $A_{i}$에서 도시 $B_{i}$로 가는 시간과 도시 $B_{i}$에서 도시 $A_{i}$로 가는 시간이 다를 수 있다.\n준형이와 친구들은 아래 조건을 만족하는 도시 $X$를 선택하여 거기서 만나려고 한다.\n\n왕복시간은 자신이 살고 있는 도시에서 도시 $X$로 이동하는 시간과 도시 $X$에서 다시 자신이 살고 있는 도시로 이동하는 시간을 합한 것이다.\n준형이와 친구들이 도로를 이용하여 갈 수 있는 도시만 선택한다.\n준형이와 친구들의 왕복시간 들 중 최대가 최소가 되는 도시 $X$를 선택한다.\n준형이와 친구들이 이동할 수 있는 도시가 최소한 하나 이상이 있음을 보장한다.\n\n도시가 많다보니 계산하기 힘들다. 준형이와 친구들을 대신하여 도시 $X$를 알려주자.\n",
        "input_text": "첫 번째 줄에는 도시의 개수 $N$과 도로의 개수 $M$이 주어진다.\n두 번째 줄부터 M + 1줄까지 도시 $A_{i}$, 도시 $B_{i}$, 도시 $A_{i}$에서 도시 $B_{i}$로 이동하는데 걸리는 시간 $T_{i}$가 공백으로 구분되어 주어진다.\n$M + 2$줄에는 준형이와 친구들의 총 인원 $K$가 주어진다.\n$M + 3$줄에는 준형이와 친구들이 살고 있는 도시의 번호 $C_{i}$가 공백으로 구분되어 주어진다.\n",
        "output_text": "위 조건을 만족하는 도시 $X$의 번호를 출력한다. 만약 가능한 도시 $X$가 여러 개인 경우는 도시의 번호를 오름차순으로 출력한다.\n",
        "memory_median": 2184.0,
        "time_median": 20.0,
        "length_median": 1295.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "211": {
        "problem_text": "오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.\n\r\ndfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)\r\n        if (visited[x] = NO) then dfs(V, E, x);\r\n}\n",
        "input_text": "첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.\n다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.\n",
        "output_text": "첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n",
        "memory_median": 12492.0,
        "time_median": 104.0,
        "length_median": 813.0,
        "label": [
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "212": {
        "problem_text": "여러 개의 사과, 파인애플, 그리고 펜이 일렬로 세워져 있다. 이 물건들의 순서를 바꾸지 않고 옆에 있는 물건끼리 연결했을 때, 펜-파인애플-애플-펜을 몇 개나 만들 수 있을지 세어보자.\n단, 펜, 파인애플, 사과, 펜 순서로 연결된 네 개의 물건만을 펜-파인애플-애플-펜으로 인정하며, 하나의 펜이 두 개의 펜-파인애플-애플-펜에 포함될 수 없다. 또한 펜, 사과, 파인애플, 펜 순서로 연결된 네 개의 물건은 펜-파인애플-애플-펜이 아니다.\n",
        "input_text": "첫 번째 줄에 물건의 총 개수 n이 주어진다. (1 ≤ n ≤ 1,000,000)\n두 번째 줄에 물체의 목록이 길이 n의 문자열로 주어진다. 사과는 A로, 파인애플은 P로, 펜은 p로 대소문자를 구분하여 표기한다.\n",
        "output_text": "만들 수 있는 펜-파인애플-애플-펜의 최대 개수를 출력한다.\n",
        "memory_median": 3680.0,
        "time_median": 20.0,
        "length_median": 394.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "213": {
        "problem_text": "1차원 좌표계 위에 선분 N개가 있다. 선분이 최대로 겹쳐있는 부분의 겹친 선분의 개수를 구해보자. 선분의 끝 점에서 겹치는 것은 겹치는 것으로 세지 않는다.\n",
        "input_text": "첫째 줄에는 선분의 개수(1 ≤ N ≤ 1,000,000)가 입력으로 들어온다. 그 다음 N개의 줄에 선분의 시작 좌표 s와 끝나는 좌표 e (s < e)가 입력으로 들어온다. 선분의 좌표는 절댓값이 10억보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에는 최대로 많이 겹치는 선분들의 개수를 출력한다.\n",
        "memory_median": 17648.0,
        "time_median": 576.0,
        "length_median": 626.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "214": {
        "problem_text": "여러분은 주어진 스케이트 코스에서 스케이트를 연습하려고 한다. 이 코스는 시작 지점, $N$개의 중간 지점, 그리고 도착 지점으로 구성되어 있다. 이 연습은 시작 지점에서 $0$의 속력으로 출발하여, $1$번 중간 지점부터 $N$번 중간 지점까지 번호가 증가하는 순서대로 방문하고, $0$의 속력으로 도착 지점에 도달한 이후 종료된다.\n각 중간 지점에는 속력 제한 $V_i$가 있어, 다음으로 방문할 지점의 속력 제한을 초과하지 않도록 이동하는 사이에 속력을 조절해야 한다. 속력을 높일 때는 원하는 만큼 높일 수 있지만, 속력을 낮추는 경우에는 마지막으로 방문했던 지점에서의 속력에서 $1$만큼만 낮출 수 있다. 단, 출발 지점과 도착 지점을 제외한 위치에서 속력은 $0$이 될 수 없다. 속력을 변경하지 않고 그대로 유지하는 것도 가능하다.\n연습의 성과는 각 지점에서의 속력의 합과 같으므로 여러분은 이를 최대화하려고 한다. 스케이트 코스의 속력 제한이 주어졌을 때, 그 코스에서 얻을 수 있는 최대 연습의 성과를 구해보자.\n예를 들어, 중간 지점이 $3$개인 코스의 속력 제한이 $V = [2, 3, 1]$로 주어진 경우, $2$번 중간 지점에서 $3$의 속력을 유지한다면 $3$번 중간 지점에서 $1$이하의 속력이 되도록 조절하는 것이 불가능하다. 이 코스에서 가능한 연습 방법 중 하나로, $[2, 2, 1]$의 순서대로 속력을 조절한다면 속력의 합은 $2 + 2 + 1$인 $5$가 된다. 다른 가능한 연습 방법으로 $[1, 1, 1]$과 $[1, 2, 1]$이 있지만, 이들의 속력의 합은 $5$를 초과하지 않는다. 따라서 이 코스에서 얻을 수 있는 가장 큰 연습의 성과는 $5$이다.\n",
        "input_text": "첫 번째 줄에 $N$이 주어진다.\n두 번째 줄에 $V_1, V_2, \\dots , V_N$이 공백을 사이에 두고 차례대로 주어진다.\n",
        "output_text": "첫 번째 줄에 답을 출력한다.\n",
        "memory_median": 5804.0,
        "time_median": 112.0,
        "length_median": 412.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "215": {
        "problem_text": "문어에게 여덟개의 팔이 있다는 사실은 잘 알려져 있다. 하지만 문어들이 자신의 팔들을 1번, 2번, 3번, ..., 8번이라고 부른다는 말은 오늘 처음 들었을 것이다! 단, 시계방향으로 오름차순이라던가 하는 규칙은 없다. (물론 그러한 문어도 존재할 수 있다.) 문제에선 편의상 팔 대신 손이라고 부르자.\n문어들은 정월 대보름을 맞아 강강술래를 하려고 한다. 각 문어는 양 옆의 서로 다른 두 문어와 손을 맞잡아 원을 만든다. 문어끼리 손을 잡을 때 지켜야 할 예절이 있다.\n\n서로 같은 번호의 손을 잡아야 한다.\n한 문어와 둘 이상의 손을 잡을 수 없다.\n한 손으로 여러 문어의 손을 잡을 수 없다.\n\n모든 문어들은 예의바르기 때문에 예절을 항상 따른다.\n강강술래를 하는 N마리의 문어 중 하나를 골라 1번 문어라 하자. 1번 문어를 기준으로 시계방향 순으로 2번, 3번, 4번, ..., N번 문어라고 부르자. 우리는 인접한 두 문어가 잡은 손의 번호를 이용하여 길이 N의 수열을 만들 것이다. 1번과 2번 문어가 잡은 손의 번호는 1번째 항, 2번과 3번 문어가 잡은 손의 번호는 2번째 항, ..., N - 1번과 N번 문어가 잡은 손의 번호는 N - 1번째 항, N번 문어와 1번 문어가 잡은 손의 번호는 N번째 항이다.\n문어의 수 N이 주어질 때, 이렇게 만들 수 있는 수열 중 사전순으로 제일 앞서는 수열을 알아보자. 다음은 문어가 4마리일 때 사전순으로 제일 앞서는 수열인 1 2 1 2 를 만드는 방법이다.\n\r\n \n",
        "input_text": "문어의 수 N(4 ≤ N ≤ 1,000)이 주어진다.\n",
        "output_text": "N마리의 문어들로 만들 수 있는 길이 N의 수열 중 사전순으로 가장 앞서는 것을 출력한다.\n이 때, 수열을 이루는 숫자들을 순서대로 공백으로 구분하여 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 329.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "216": {
        "problem_text": "진홍이는 숫자를 좋아한다. 오늘도 숫자를 가지고 놀던 진홍이는 두 숫자의 비트 우정지수를 구해보았다. 비트 우정지수란, 10진법으로 나타낸 두 정수를 이진수로 나타내었을 때, 두 숫자를 같게 만드는데 필요한  최소 연산 횟수를 말한다. 연산의 종류는 다음과 같다.\n\n하나의 이진수에서 임의의 자리의 숫자를 0 또는 1로 바꾼다.\n하나의 이진수에서 서로 다른 자리에 있는 두 숫자의 위치를 바꾼다.\n\n예를 들어, 10진수 11과 12의 비트 우정지수를 구해보자. 11을 이진수로 나타내면 1011이고, 12를 이진수로 나타내면 1100이다. 1011에서 2의 자리를 0으로 바꾸고(1011 -> 1001), 1의 자리와 4의 자리의 숫자를 서로 바꾸면(1001 -> 1100) 1100이 된다. 즉, 1011을 1100으로 바꾸는 최소 연산 횟수는 두 번으로, 11과 12의 비트 우정지수는 2가 된다.\n진홍이는 어떤 두 수가 주어졌을 때 두 수의 비트 우정지수를 구하는 프로그램을 만들고 싶다. 하지만, 아쉽게도 진홍이는 프로그래밍에 약해 10진수를 이진수로 바꾸는 것 밖에 하지 못한다. 여러분이 진홍이를 도와 두 수의 비트 우정지수를 구하는 프로그램을 만들어 주자!\n",
        "input_text": "입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 50)가 주어진다.\n각 테스트케이스의 첫 번째 줄에는 두 이진수 N, M이 주어진다. N, M의 자릿수는 1,000,000을 넘지 않으며, 자릿수는 서로 같다.\n",
        "output_text": "각 테스트 케이스마다 두 수의 비트 우정지수를 출력한다.\n",
        "memory_median": 2324.0,
        "time_median": 20.0,
        "length_median": 523.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "217": {
        "problem_text": "욱제는 라스베이거스에서 유명한 베팅꾼이다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다.\n욱제가 주로 하는 게임은 아주 단순하고, 친숙한 게임이다. 바로 동전 뒤집기 게임이다. 이 게임에 쓰이는 동전의 양면에는 절댓값이 같고 부호가 다른 정수가 한 면에 하나씩 쓰여 있다. (단, 동전끼리는 쓰인 수의 절댓값이 다를 수 있다) 한 플레이어 당 두 번의 라운드가 주어진다. 모든 라운드는 같은 동전으로 진행되며, 딜러는 각 라운드마다 N개의 동전을 임의로 섞고 이를 일렬로 배열한다. 이때, 동전의 앞뒤 방향도 바뀔 수 있다. 첫 번째 라운드에서는 동전에 표시된 값들의 합이 최대가 되도록 뒤집어야 하고, 두 번째 라운드에서는 동전에 표시된 값들의 합이 최소가 되도록 뒤집어야 한다. (첫 번째 라운드 동전 값의 합) - (두 번째 라운드 동전 값의 합)이 해당 플레이어가 게임에서 획득한 점수이고, 이 점수가 최대가 되는 플레이어가 바로 게임의 승자가 된다.\n욱제는 엄지, 검지, 중지를 이용해서 항상 연속한 3개의 동전을 뒤집는 최고의 동전 뒤집러이다. 욱제는 연속한 3개의 동전을 뒤집지 않으면 이길 수 없다고 생각하기 때문에 실패하는 경우 없이 항상 연속한 3개의 동전만 뒤집는다. 동전 배열의 양 끝에서 벗어나서 양 끝의 동전만 뒤집거나 양 끝의 두 개 동전만 뒤집는 것도 가능하다. 동전을 뒤집는 횟수에 제한은 없다.\n(!) 너, 강해 보이는군. 나와 승부를 겨루자! 띠리링띠리링디리ㅣ리리ㅣ링~ 앗! 심술쟁이 해커 임준오(동탄 주민)이 승부를 걸어왔다!\n욱제는 이번 게임에서 얼마의 점수를 획득하게 될까? 욱제는 최고의 베팅꾼이기 때문에 항상 게임에서 획득할 수 있는 최고의 점수를 얻는다는 사실은 자명하다.\n",
        "input_text": "첫째 줄에 동전의 수 N이 주어진다. (1 ≤ N ≤ 10,000) 둘째 줄에 욱제의 첫 번째 라운드의 N개 동전의 배열이 주어진다. 셋째 줄에 욱제의 두 번째 라운드의 N개 동전의 배열이 주어진다. 동전에 적히는 수는 절댓값 10,000 이하의 정수이다.\n",
        "output_text": "욱제가 이번 게임에서 획득할 점수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 338.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "218": {
        "problem_text": "2016년 5월 28일 제 2회 인하대학교 프로그래밍 경시대회(IUPC)가 개최된다. 이 대회는 다른 프로그래밍 경시대회와 다르게  손코딩으로 문제를 풀어야한다. CTP회장인 정은이는 모든 대회 참가자들에게 펜을 지급하기 위하여 펜을 구하기로 하였다. 대회 개최를 위한 예산을 아끼기 위하여 펜을 구매하지 않고 CTP회원들에게 펜을 빌리기로 하였다.\nCTP에는 N명의 회원들이 존재하며 각각의 회원들의 필통에 들어있는 펜의 개수는 모두 다르다. 정은이는 여러명의 회원에게 펜을 빌릴경우 펜을 돌려주기에 번거롭다고 생각하여 최소한의 회원들에게 펜을 빌려 참가자들에게 나누어 주려고 한다.\n대회에 참가하는 참가자들은 팀을 구성해서 참가하는데 모든 팀원에게 펜을 지급해야한다. 한 팀이 k명의 팀원으로 구성되어 있을때 몇 명의 회원들에게 펜을 빌려야하는지 출력하시오.\n",
        "input_text": "입력의 첫 줄에는 CTP의 회원수 N(1 ≤ N ≤ 1,000)이 주어진다.\n둘째 줄에는 대회에 참가한 팀의 수 M(1 ≤ M ≤ 1,000)과 팀을 구성하는데 필요한 팀원의 수 K(1 ≤ K ≤ 10)가 주어진다.\n셋째 줄에는 각각의 CTP 회원들이 가지고 있는 펜의 수 A(0 ≤ A ≤ 100)가 공백을 구분으로 주어진다.\n",
        "output_text": "정은이가 최소한의 회원들에게 빌리려고 할 때, 빌린 회원의 수를 출력한다. 만약 펜이 부족한 경우 \"STRESS\"(따옴표는 제외)를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 504.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "219": {
        "problem_text": "혜아는 답답한 3차원 세계를 벗어나 자유로운 2차원 좌표계 위로 집을 옮길 계획이다. 이 좌표계에는 그 어떤 위치에도 주거할 수 있는 시설이 있기 때문에 혜아는 두 실수 Hx, Hy 를 골라 좌표 (Hx, Hy)로 이사할 것이다.\n이사할 집의 위치를 결정하기 위해 절대적으로 중요한 것은 편의시설이 집으로부터 얼마나 멀리 떨어져 있느냐는 점이다. 좌표계에는 N개의 편의시설이 있는데, 좌표계의 주거지역 정책에 따라 x, y 좌표가 모두 정수인 곳에만 편의시설이 있다.\n혜아는 N개의 편의시설로 이동하는 데 드는 거리의 평균값이 최소가 되는 좌표로 이사를 가고 싶었지만, 이런 좌표를 찾는 것이 너무 어렵다는 것을 깨달았다. 그래서 그나마 좌표를 찾기 쉽도록 가장 가까운 편의시설까지의 거리와 가장 먼 편의시설까지의 거리의 평균이 최소가 되는 좌표로 이사하려고 한다. 이 좌표계에서 거리는 유클리드 거리를 사용하여, 두 좌표 (Ax, Ay)와 (Bx, By) 사이의 거리는 $\\sqrt{(A_x-B_x)^2+(A_y-B_y)^2}$으로 나타난다고 할 때, 혜아를 도와 가능한 위치 중 하나를 구해 주는 프로그램을 작성해보자.\n",
        "input_text": "첫 번째 줄에 편의시설의 개수 N(1 ≤ N ≤ 103)이 주어진다.\n다음 N개의 줄의 각 줄에는 두 정수 x와 y(-104 ≤ x, y ≤ 104)가 공백 하나를 사이에 두고 주어진다. 이는 (x, y)에 편의시설이 하나 존재한다는 뜻이다.\n",
        "output_text": "첫 번째 줄에 혜아가 이사할 곳의 좌표 (Hx, Hy)를 나타내는 두 실수 Hx, Hy를 공백 하나로 구분하여 출력한다. 가장 가까운 편의시설까지의 거리와 가장 먼 편의시설까지의 거리의 평균을 정답과 비교했을 때 절대오차 혹은 상대오차가 10-6 이하면 정답으로 인정한다.\n",
        "memory_median": 2028.0,
        "time_median": 4.0,
        "length_median": 824.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "220": {
        "problem_text": "아 과제 하기 싫다. 아무 것도 안 하고 싶다. 더 적극적이고 격렬하게 아무 것도 안 하고 싶다.\n있잖아. 내가 아까 책상에다가 n개의 과제 목록을 적어놨어. 각각의 과제 i는 di 일이 걸리고, 오늘로부터 ti 일 안에 끝내야 해. 그러니까 오늘이 0일이면, ti일이 끝나기 전에 제출이야. 과제는 한번 시작하면 쉬지 않고 계속해야 해. 안 그러면 머리 아파 지거든.\n근데 있잖아. 내가 지금 너무, 너무 아무 것도 안 하고 싶어. 그래서 오늘은 아무 것도 안 할 거야. 더 중요한 게 뭔지 알아? 사실 나 내일도, 모레도, 아무 것도 안 하고 싶어. 한 며칠 동안은 계속 아무 것도 안하려고. 아. 과제가 있을 때 내가 내일부터 연속으로 최대 며칠동안 놀 수 있는지 궁금하다. 궁금하긴 한데, 난 아무 것도 안 하고 싶어.\n좋은 생각이 났다. 너희가 이걸 대신 구해주면, 내가 너희의 맞은 문제 수를 하나 올려줄게.\n",
        "input_text": "첫째 줄에는 과제의 개수인 정수 n (1 ≤ n ≤ 106)이 주어진다.\n이후 n개의 줄에 각각의 과제를 나타내는 두 정수 di, ti (1 ≤ di, ti ≤ 109)가 순서대로 주어진다. 오늘은 0일이다.\n모든 입력에 대해, 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다.\n",
        "output_text": "내일(1일)부터 연속으로 최대 며칠 동안 놀 수 있는지를 출력한다. 가령, 답이 0이면, 내일 과제를 해야 하며, 1 이면, 모레에 과제를 해야 한다.\n",
        "memory_median": 13748.0,
        "time_median": 400.0,
        "length_median": 610.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "221": {
        "problem_text": "백준이는 한 작은 회사에 취직했다. 이 회사에서 백준이는 소스 코드의 뒤죽박죽인 인덴트를 고치고 있다. 인덴트는 각 줄을 탭 키를 이용해 들여 쓰는 것을 말한다. 다행히 백준이가 사용하는 편집기는 연속된 줄을 그룹으로 선택하고, 여기에서 각 줄의 앞에 탭을 추가하거나, 삭제할 수 있다. 백준이를 도와 코드의 뒤죽박죽인 인덴트를 예쁘게 고치는 방법을 생각해보자.\n줄의 개수 N과 각 줄의 앞에 있는 탭의 개수와 올바른 탭의 개수가 주어진다. 이때, 한 번 편집을 할 때, 다음과 같은 명령을 수행할 수 있다.\n\n연속된 줄을 그룹으로 선택한다.\n선택된 줄의 앞에 탭 1개를 추가하거나 삭제한다.\n\n위의 두 명령을 모두 수행하는 것이 하나의 편집이며, 선택된 줄의 개수와는 상관이 없다. 만약, 선택한 줄 중에 단 한 줄이라도 탭이 없을 경우에는, 탭을 삭제하는 명령을 수행할 수 없다.\n백준이가 몇 번 편집 만에 코드의 인덴트를 올바르게 고칠 수 있는지 구하는 프로그램을 작성하시오. 이때, 편집 회수의 최솟값을 구해야 한다.\n",
        "input_text": "첫째 줄에 줄의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 현재 줄에 있는 탭의 개수가 주어지며, 1번째 줄부터 순서대로 주어진다. 탭의 개수는 0보다 크거나 같고, 80보다 작거나 같은 정수이다. 셋째 줄에는 각 줄의 올바른 탭의 개수가 주어진다. 1번째 줄부터 순서대로 주어지며, 이 값도 0보다 크거나 같고, 80보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 코드의 인덴트를 올바르게 고치는 편집 회수의 최솟값을 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 940.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "222": {
        "problem_text": "오늘은 재현이의 생일이다. 재현이는 친구 N명에게 롤케이크를 1개씩 선물로 받았다. 롤케이크의 길이는 A1, A2, ..., AN이다. 재현이는 길이가 10인 롤케이크만 먹는다. 따라서, 롤케이크를 잘라서 길이가 10인 롤케이크를 최대한 많이 만들려고 한다.\n롤케이크는 다음과 같은 과정을 통해서 자를 수 있다.\n\n자를 롤케이크를 하나 고른다. 길이가 1보다 큰 롤케이크만 자를 수 있다. 이때, 고른 롤케이크의 길이를 x라고 한다.\n0보다 크고, x보다 작은 자연수 y를 고른다.\n롤케이크를 잘라 길이가 y, x-y인 롤케이크 두 개로 만든다.\n\n재현이는 롤케이크를 최대 M번 자를 수 있다. 이때, 만들 수 있는 길이가 10인 롤케이크 개수의 최댓값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 롤케이크의 개수 N과 자를 수 있는 최대 횟수 M이 주어진다. (1 ≤ N, M ≤ 1,000)\n둘째 줄에 롤케이크의 길이 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 1,000)\n",
        "output_text": "재현이가 만들 수 있는 길이가 10인 롤케이크 개수의 최댓값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 955.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "223": {
        "problem_text": "마법소녀인 마도카는 너무나도 고양이를 좋아하는 나머지 마법을 이용하여 고양이 $N$마리를 집에서 키우기로 결심했다!\n마도카는 한 번의 행동에서 다음 $2$가지 마법 중 하나를 선택하여 사용한다. 처음에는 마도카의 집에 고양이가 존재하지 않는다.\n\n생성 마법: 고양이 $1$마리를 마도카의 집에 생성한다.\n복제 마법: 마도카의 집에 있는 고양이 일부 또는 전부를 대상으로 하여 복제한다. 즉, 만약 현재 마도카의 집에 고양이가 $k$마리 존재한다면, $0$마리 이상 $k$마리 이하의 고양이를 마도카의 집에 추가할 수 있다.\n\n마도카는 위의 $2$가지 마법을 적절히 사용하여, 최소의 행동 횟수로 마도카의 집에 정확히 $N$마리의 고양이가 있도록 만들고 싶다. 계산을 어려워하는 마도카를 위해 최소의 행동 횟수를 계산해주자!\n",
        "input_text": "첫 번째 줄에 키우기를 원하는 고양이의 수 $N(0\\leq N\\leq 10^{12})$이 정수로 주어진다.\n",
        "output_text": "첫 번째 줄에 정확히 $N$마리의 고양이를 마도카의 집에 들일 수 있는 최소의 행동 횟수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 332.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "224": {
        "problem_text": "은혜는 정육점에서 고기를 사려고 한다. 보통 정육점에서는 자신이 원하는 양을 이야기하면 그 양만큼의 고기를 팔지만, 은혜가 방문한 정육점에서는 세일 행사를 하고 있었기 때문에 N 덩어리의 고기를 이미 잘라놓고 판매하고 있었다.\n각각의 덩어리들은 이미 정해져 있는 무게와 가격이 있는데, 어떤 덩어리를 샀을 때에는 그 덩어리보다 싼 고기들은 얼마든지 덤으로 얻을 수 있다(추가 비용의 지불 없이). 또한 각각의 고기들은 부위가 다를 수 있기 때문에 비용과 무게와의 관계가 서로 비례하는 관계가 아닐 수도 있다. 은혜는 이러한 점을 고려하지 않고, 어느 부위든지 자신이 원하는 양만 구매하면 되는 것으로 가정한다. 또한 만약 가격이 더 싸다면 은혜가 필요한 양보다 더 많은 고기를 살 수도 있다.\n각 덩어리에 대한 정보가 주어졌을 때, 은혜가 원하는 양의 고기를 구매하기 위해 필요한 최소 비용을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 두 정수 N(1 ≤ N ≤ 100,000), M(1 ≤ M ≤ 2,147,483,647)이 주어진다. N은 덩어리의 개수를 의미하고, M은 은혜가 필요한 고기의 양이다. 다음 N개의 줄에는 각 고기 덩어리의 무게와 가격을 나타내는 음 아닌 두 정수가 주어진다. 무게의 총 합과 가격의 총 합은 각각 2,147,483,647을 넘지 않는다.\n",
        "output_text": "첫째 줄에 답을 출력한다. 불가능한 경우에는 -1을 출력한다.\n",
        "memory_median": 3572.0,
        "time_median": 36.0,
        "length_median": 1005.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "225": {
        "problem_text": "월드시에서는 매년 n명의 사람들이 모여 월드 크래프트라는 게임의 토너먼트 대회를 치른다. 이 게임은 특성상 실력만이 승패를 좌우하기 때문에, 아무리 실력이 엇비슷한 사람이 시합을 치러도 랭킹이 높은 사람이 반드시 이기게 된다. 따라서 월드시에서는 게임을 흥미진진하게 만들기 위해서, 부전승을 여러 번 만들더라도 각 시합에 임하는 선수들의 랭킹 차이를 비슷하게 만들려고 한다.\n토너먼트를 만들 때에는 이미 추첨이 된 순서대로 선수들을 배치하고, 왼쪽에서 오른쪽의 순서가 어긋나지 않도록 시합을 정한다. 물론 부전승을 임의로 만들 수 있지만, 토너먼트가 꼬여서는 안 된다. 또한, 각 시합에 임하는 두 선수의 랭킹의 차이의 합이 최소가 되도록 하려 한다.\n\n예를 들어 추첨 결과가 차례로 랭킹 1, 6, 2, 5, 3, 4위의 선수들이었을 때의 토너먼트 세 개가 위에 있다. <A>의 경우는 각 시합이 (1 6), (2 5), (3 4), (1 2), (1 3)으로 랭킹 차이의 합이 5 + 3 + 1 + 1 + 2 = 12가 된다. 반면에 <B>는 11이, <C>는 10이 된다.\n토너먼트 추첨 결과가 주어졌을 때, 각 시합에 임하는 두 선수의 랭킹 차이의 총 합의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 자연수 n(1 ≤ n ≤ 256)이 주어진다. 다음 줄에는 추첨 결과를 나타내는 n명의 선수들의 랭킹이 주어진다. 각 선수의 랭킹은 1부터 n까지의 자연수로 나타나며, 랭킹이 같은 경우는 없다고 가정하자.\n",
        "output_text": "첫째 줄에 답을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 785.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "226": {
        "problem_text": "벌목꾼 백은진은 나무를 종이 공장에 옮겨야 한다. 하지만, 통나무의 길이가 너무 길어서 트럭에 들어가지 않으므로, 여러개의 조각으로 나누려고 한다.\n통나무의 길이는 L이고, K개의 위치에서만 자를 수 있다. 통나무를 자를 수 있는 위치가 주어진다. 이 위치는 통나무의 가장 왼쪽에서부터 떨어진 거리이다. 통나무를 자를 수 있는 횟수는 최대 C번이다.\n통나무의 가장 긴 조각을 작게 만들고, 그 길이를 구해보자.\n",
        "input_text": "첫째 줄에 세 정수 L, K, C가 주어진다. 둘째 줄에는 통나무를 자를 수 있는 위치가 주어진다.\n",
        "output_text": "첫째 줄에 두 개의 수를 출력한다. 첫 번째 수는 가장 긴 조각의 길이이고, 두 번째 수는 그 때 처음 자르는 위치를 출력한다. 만약 가능한 것이 여러 가지라면, 처음 자르는 위치가 작은 것을 출력한다.\n",
        "memory_median": 2058.0,
        "time_median": 4.0,
        "length_median": 1140.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "227": {
        "problem_text": "영선이는 나무꾼으로 나무를 구하러 오전에 산에 오른다. 산에는 $n$개의 나무가 있는데, 영선이는 하루에 한 나무씩 $n$일 산에 오르며 나무를 잘라갈 것이다. 하지만 이 산은 영험한 기운이 있어 나무들이 밤만 되면 매우 빠른 속도로 자라는데, 그 자라는 길이는 나무마다 다르다.\n따라서, 어느 나무를 먼저 잘라가느냐에 따라서 총 구할 수 있는 나무의 양이 다른데,\n나무의 처음 길이와 하루에 자라는 양이 주어졌을 때, 영선이가 얻을 수 있는 최대 나무양을 구하시오.\n참고로, 자른 이후에도 나무는 $0$부터 다시 자라기 때문에 같은 나무를 여러 번 자를 수는 있다.\n",
        "input_text": "첫째 줄에는 나무의 개수 $n$개가 있다. 나무는 $1$번부터 $n$번까지 있다.\n다음 줄에는 첫날 올라갔을 때 나무의 길이들 $H_i$가 $n$개가 순서대로 주어진다.\n그 다음 줄에는 나무들이 자라는 길이 $A_i$가 $n$개가 순서대로 주어진다.\n",
        "output_text": "영선이가 나무를 잘라서 구할 수 있는 최대 양을 출력하시오.\n",
        "memory_median": 2800.0,
        "time_median": 16.0,
        "length_median": 549.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "228": {
        "problem_text": "주택난을 해결하기 위해서 직선 도로 하나를 따라 여러 아파트 단지들을 지었다. 또, 이 아파트 단지 주민을 위해 도로 위 한 지점에 학교 하나를 신설하였다. 아파트 단지들이 서로 멀리 떨어져 있기 때문에 반드시 통학버스를 이용해서만 다닐 수 있고, 통학버스는 한 대이다.\n각각의 아파트 단지와 학교의 위치는 도로 위의 좌표로 주어지며, 또 각 아파트 단지마다 여기에 사는 학생들의 수도 주어진다. 통학버스는 아침에 학교를 출발하여 각 아파트 단지에 있는 학생들을 태우고 학교로 다시 돌아온다. 이 통학버스는 정원을 초과하여 학생을 태울 수 없고, 모든 학생을 등교시킬 때까지 이 과정을 반복한다. \n\n위 규칙을 따라서 모든 학생들을 학교에 등교시키는 예를 보자. 아파트 단지 A, B, C가 각각 좌표 0, 2, 5에 있고 이 단지에 사는 학생은 각각 1, 2, 1명이라고 하자. 두 지점 간의 거리는 두 지점 좌표의 차이로 정의된다. 최대 4명이 탈 수 있는 통학버스가 좌표 4에 있는 학교에서 출발해서 모든 학생들을 등교시킬 때, 버스는 먼저 단지 B를 들러 2명을 태우고, 단지 A를 들러서 1명을 태우고 다시 학교로 돌아온다면 이동 거리는 2 + 2 + 4 = 8이다. 다시 학교에서 아파트 단지 C로 이동하여 1명을 태우고 돌아오면 이동 거리는 1 + 1 = 2가 되고, 총 이동거리는 8 + 2 = 10이 된다. \n학교의 위치, 각각의 아파트 단지의 위치와 학생 수, 통학버스의 정원이 주어졌을 때, 모든 학생을 등교시키는데 필요한 통학버스의 총 이동 거리의 최솟값을 계산하는 프로그램을 작성하시오. \n",
        "input_text": "첫째 줄에는 세 개의 양의 정수 N, K, S가 빈칸을 사이에 두고 순서대로 주어진다. 첫 번째 정수 N은 아파트 단지의 수이며 2 ≤ N ≤ 30,000이다. 두 번째 정수 K는 1 ≤ K ≤ 2,000이며, 통학버스의 정원이다. 세 번째 정수 S는 학교의 위치를 나타낸다. 둘째 줄부터 N+1번째 줄에는 각 아파트 단지의 위치를 나타내는 정수와 이 단지에 사는 학생 수를 나타내는 정수가 빈칸을 사이에 두고 주어진다. 학교와 아파트 단지의 좌표는 0 이상 100,000 이하이며, 이 좌표들은 모두 서로 다르다. 각 아파트 단지의 학생 수는 1 이상 2,000 이하이다. \n",
        "output_text": "첫째 줄에 주어진 입력에서 통학버스의 최소 이동 거리를 출력한다. 최소 이동 거리가 1,000,000,000을 초과하는 경우는 없다.  \n",
        "memory_median": 2408.0,
        "time_median": 8.0,
        "length_median": 1292.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "229": {
        "problem_text": "<그림 1>과 같이 정사각형 모양을 한 여섯 종류의 색종이가 있다. 1번 색종이는 한 변의 길이가 1cm이고, 차례대로 그 길이가 1cm씩 커져, 6번 색종이의 한 변의 길이는 6cm가 된다.\n\n<그림 1>\n주어진 색종이를 <그림 2>와 같이 가로, 세로의 길이가 각각 6cm인 판 위에 붙이려고 한다. 색종이를 붙일 때는 색종이가 판의 경계 밖으로 삐져 나가서는 안되며, 색종이가 서로 겹쳐서도 안 된다. 또한 하나의 색종이는 하나의 판에만 붙여야 한다.\n\n<그림 2>\n각 종류별로 색종이의 장수가 주어질 때, 그 색종이를 모두 붙이기 위해서 위와 같은 판이 최소 몇 개가 필요한지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄부터 여섯째 줄까지 각 종류의 색종이의 장수가 1번부터 6번까지 차례로 주어진다. 각 종류의 색종이의 장수는 최대 100이다.\n",
        "output_text": "첫째 줄에 필요한 판의 최소 개수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1372.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "230": {
        "problem_text": "There are pizza boxes all of which have the same dimensions. The boxes are stacked in piles, forming a three- dimensional grid where the heights are all different. The view from front shows the height of the tallest pile in each column, the view from the side shows the height of the tallest pile in each row.\nWhat is the maximum number of pizza boxes we can remove without changing the front and side views? In the following example, Figure I.2 shows the solution of Figure I.1(a) case. In Figure I.1(a) and Figure I.2, each number (height) represents the number of boxes stacked.\n\nFigure I.1. (a) Grid of heights and (b) the corresponding views.\n\nFigure I.2. Grid of heights after removing boxes.\nYour task is to compute the maximum number of pizza boxes that can be removed without changing the original front and side views.\n",
        "input_text": "Your program is to read from standard input. The input contains two integers, n and m (1 ≤ n, m ≤ 1,000), the number of rows and columns in the grid, respectively. Each of the following n lines contain m integers, the number of pizza boxes (heights) in the corresponding row. All heights are between 0 and 109 inclusive and the heights are all different.\n",
        "output_text": "Your program is to write to standard output. Print exactly one line for the input. The line should contain the maximum number of pizza boxes that can be removed without changing the original views.\n",
        "memory_median": 8944.0,
        "time_median": 224.0,
        "length_median": 944.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "231": {
        "problem_text": "준석이는 두 동생을 위해 사탕 가게에서 사탕을 최대한 많이 사 가려고 한다. 사탕 가게에는 $N$개의 사탕 묶음이 있으며 $i$번째 사탕 묶음에는 $a_i$개의 사탕이 있다. 준석이는 정말 부자라 사탕 묶음을 마음껏 살 수 있다. 하지만 준석이가 사간 총 사탕의 개수가 홀수가 되면 두 동생이 사탕을 한 개라도 더 갖기 위해 서로 싸울 것이라 총 짝수 개의 사탕을 가져가려고 한다. 준석이를 위해서 최대로 가져갈 수 있는 사탕의 개수를 구해주자!\n",
        "input_text": "첫째 줄에 사탕 묶음의 개수 $N$이 주어진다. \\((1 \\leq N \\leq 1000)\\)\n둘째 줄에 각각의 사탕 묶음에 담겨있는 사탕의 개수 $a_1,a_2, \\cdots, a_N$가 주어진다. \\((1 \\leq a_i \\leq 1000)\\)\n입력으로 주어지는 모든 수는 정수이다.\n",
        "output_text": "준석이가 최대로 가져갈 수 있는 사탕의 개수를 출력한다.\n사탕을 홀수 개로만 가져갈 수 있으면 $0$을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 506.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "232": {
        "problem_text": "강호는 전구 N개를 가지고 있다. 전구는 1번부터 N번까지 번호가 매겨져 있으며, 일렬로 놓여져 있다. 전구는 켜져있거나 꺼져있다.\n강호는 모든 전구를 끄려고 한다. 강호는 전구를 켜고 끌 수 있는 스위치 N개를 가지고 있고, 스위치도 1번부터 N번까지 번호가 매겨져 있다. i번 스위치는 i의 배수 번호를 가지는 전구의 상태를 모두 반전시킨다.\n현재 전구의 상태가 주어졌을 때, 모든 전구를 끄기 위해서 스위치를 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 전구의 상태가 1번 전구부터 차례대로 주어진다. Y는 전구가 켜 있는 경우, N은 전구가 꺼져있는 경우이다. 전구의 개수는 1보다 크거나 같고 1,000보다 작거나 같은 자연수이다.\n",
        "output_text": "모든 전구를 끄기 위해서 스위치를 몇 번 눌러야 하는지 출력한다. 만약, 모든 전구를 끌 수 없다면 -1을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 529.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "233": {
        "problem_text": "상근이는 한국 최고의 가수를 뽑는 \"나는 위대한 슈퍼스타K\"의 감독이다. 상근이는 다음과 같이 참가자를 선발하려고 한다.\n\"나는 위대한 슈퍼스타K\"의 예선에는 N명이 참가했고, 서로 다른 M개 장르에 대한 오디션을 보았다. 심사위원은 모든 참가자의 각 장르에 대한 능력을 점수로 매겼다. 이 점수는 실수로 나타낸다.\n본선에는 총 K명이 나갈 수 있다. 각 참가자는 본선에서 단 하나의 장르만 부를 수 있고, 이 장르는 상근이가 정해준다. 한 사람이 여러 장르를 부를 수는 없지만, 여러 사람이 같은 장르를 부를 수는 있다.\n모든 참가자의 각 장르에 대한 능력이 주어진다. 이때, 능력의 합이 최대가 되도록 참가자와 장르를 선택하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N, M, K가 주어진다. (1 ≤ M ≤ 100, 1 ≤ K ≤ N ≤ 100)\n다음 M개의 줄은 각 장르에 대한 참가자의 능력이 주어진다. 이 줄에는 N개의 (i, s)쌍이 주어진다. 여기서 i는 참가자의 번호, s는 그 참가자의 장르에 대한 능력이다. 이 쌍은 능력이 감소하는 순서대로 주어진다. 참가자의 번호는 1부터 N까지 이다.\n각 줄에 모든 학생은 한 번씩 등장한다.\n",
        "output_text": "첫째 줄에 본선 참가자의 능력의 합을 소수점 첫째자리까지 반올림해 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 637.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "234": {
        "problem_text": "메이플스토리에는 전문 기술이라는 제작 시스템이 있다. 전문 기술은 특정량의 피로도가 쌓이는 대신 다양한 장비 및 비약을 제작할 수 있는 시스템이다. 장신구 명장인 임스는 어떻게 하면 더 효율적으로 많은 장신구를 제작할 수 있을지 고민에 빠졌다.\n임스가 만들 수 있는 장신구는 $N$개가 있고, 각각의 장신구를 만들면 $A_i$만큼의 피로도가 누적된다.\n피로도가 $200$ 미만인 경우, 장신구를 제작할 수 있다. 현재 쌓인 피로도가 $P$일 때, 임스가 제작할 수 있는 장신구의 최대 개수를 구해보자!\n",
        "input_text": "첫 번째 줄에 정수 $P$와 정수 $N$이 공백으로 구분되어 주어진다. ($1 \\le P \\le 200$, $1 \\le N \\le 1\\,000$)\n두 번째 줄에는 정수 $A_1, A_2, \\dots, A_N$이 공백으로 구분되어 주어진다. ($1 \\le A_i \\le 200$)\n",
        "output_text": "제작할 수 있는 장신구의 최대 개수를 출력하시오.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 438.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "235": {
        "problem_text": "성실한 농부 존은 시간을 효율적으로 관리해야 한다는 걸 깨달았다. 그는 N개의 해야할 일에 (1<=N<=1000) 숫자를 매겼다. (우유를 짜고, 마굿간을 치우고, 담장을 고치는 등의)\n존의 시간을 효율적으로 관리하기 위해, 그는 끝내야만 하는 일 목록을 만들었다. 완성될 때 필요한 시간을 T_i(1<=T_i<=1,000) 라고 하며, 끝내야하는 시간을 S_i(1<=S_i<=1,000,000) 이라 한다. 농부 존은 하루의 시작을 t = 0으로 정했다. 그리고 일 할 때는 그 일을 마칠 때 까지 그 일만 한다. \n존은 늦잠 자는 걸 좋아한다. 따라서 제 시간에 끝낼 수 있게 결정할 수 있는 한도에서 존이 가장 늦게 일어나도 되는 시간을 출력하라.\n",
        "input_text": "첫 줄에는 일의 개수인 N을 받고\n두 번째 줄부터 N+1줄까지 T_i와 S_i를 입력받는다. \n",
        "output_text": "존이 일을 할 수 있는 마지막 시간을 출력 하라. 존이 제시간에 일을 끝낼 수 없다면 -1 을 출력하라.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 685.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "236": {
        "problem_text": "희원이는 그의 다락방에서 N개의 체인을 찾았다. 각각의 체인은 몇 개의 고리로 연결되어 있는데, 각각의 고리는 최대 두 개의 인접한 고리를 가질 수 있다. 각각의 고리는 열고 닫을 수 있다. 그래서, 체인을 분리하거나 두 체인을 연결하여 하나의 긴 체인으로 만들 수 있다. 희원이는 가능한 한 적은 고리를 열고 닫아서, 모든 체인을 하나의 긴 체인으로 연결하려고 한다.\n예를 들어, 희원이가 세 개의 체인을 가지고 있고, 각 체인이 고리 하나로만 이루어져 있다면, 그 중 하나를 열어서 나머지 두 개를 연결하고 닫으면 된다.\n\n체인의 개수와 각각의 체인의 길이가 주어지면, 하나의 긴 체인으로 모든 체인을 묶기 위해 희원이가 열고 닫아야할 최소한의 고리 수를 찾아라.\n",
        "input_text": "첫 번째 줄에는 체인의 개수를 나타내는 양의 정수 N (2 ≤ N ≤ 500000)이 주어진다. 두 번째 줄에는 각각의 체인의 길이를 나타내는 N개의 양의 정수 Li(1 ≤ Li ≤ 1000000)가 주어진다.\n",
        "output_text": "첫째 줄에 필요한 고리의 최소 개수를 출력한다.\n",
        "memory_median": 3978.0,
        "time_median": 112.0,
        "length_median": 533.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "237": {
        "problem_text": "선물 포장 공장을 말아먹은 욱제는 계곡에서 백숙을 파느라 학교에 자주 가지 못한다. 하지만 월클의 인생은 피곤한 법! 욱제는 지금처럼 힘든 시기에도 자신을 기다리는 5조5억명의 열렬한 팬들을 위해 가끔씩 학교에 가 줘야 한다. 욱제는 백숙이 끓는 걸 지켜봐야 해서 가게를 오래 비울 수 없다. 그래서 욱제는 한 번 학교에 간 뒤 최소 시간동안 머물다가 모든 팬들과 한 번씩 인사를 하고 학교를 떠나려고 한다.\n욱제는 임의의 시각에 학교에 오거나 학교를 떠날 수 있고, 단 한 번의 왕복만 한다. 동시에 여러 팬들에게 인사를 끝낼 수도 있다. 욱제는 잘생겨서 인사하면 팬들이 심쿵사로 바로 쓰러지기 때문에 인사를 하는데 소요되는 시간은 0이라고 하자.\n\n<그림 1>\n예를 들어 3명의 팬 A, B, C가 학교에 머무르는 시간이 <그림 1>과 같다고 하자. 이 경우 시각 2에 3명의 팬이 모두 학교에 있으므로, 욱제는 시각 2에 학교에 와서 3명에게 동시에 인사를 하고 바로 가게로 돌아갈 수 있다. 시각 3이나 4도 마찬가지이다. 이때 욱제가 학교에 머무는 시간의 총합은 0이다.\n\n<그림 2>\n다른 예로 2명의 팬 A와 B가 학교에 있는 시간이 <그림 2>와 같다고 하자. 욱제는 시각 4부터 시각 5까지 학교에 머물면서 시각 4에 A와, 시각 5에 B와 인사를 하고 학교를 떠날 수 있다. 이때 욱제가 학교에 머무는 시간은 1이다.\n백숙집 주방 이모 효빈이는 N명의 팬들이 학교에 머무르는 시간 [s, e]들을 몰래 조사했다. 효빈이는 욱제가 학교에 머무르는 시간을 계산해서 그 시간동안 땡땡이를 치기로 했다. 효빈이와 함께 욱제가 학교에 머무르는 최소의 시간을 계산해 보자!\n",
        "input_text": "첫째 줄에 욱제의 열렬한 팬의 수 N이 주어진다. (1 ≤ N ≤ 100,000)\n둘째 줄부터 N개의 줄에 걸쳐, 각 줄에 정수 si, ei (1 ≤ si ≤ ei ≤ 100,000)가 순서대로 주어진다. 이는 i번째 팬이 학교에 있는 시간 [si, ei]을 의미한다.\n",
        "output_text": "욱제가 학교에 머물러야 하는 최소의 시간을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 28.0,
        "length_median": 426.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "238": {
        "problem_text": "축구는 지구에서 가장 인기있는 스포츠 중의 하나입니다. n 팀으로 이루어진 축구 리그가 있습니다. 하나의 팀은 다른 모든 팀과 정확히 한 번씩만 경기를 합니다. 그러므로, 각 팀은 n - 1 번의 경기를 하게 됩니다. 무승부는 승부차기를 하기 때문에 없습니다. 한 경기 후에 이긴 한 팀은 1 점을 얻게 되고, 진 팀은 0 점을 얻게 됩니다.\n베스트 팀 선정을 위해 경기 일정이 끝난 후에 각 팀은 리그 사무소에 획득한 점수를 보고하게 됩니다. 리그 사무소는 각 팀이 보고한 점수가 실수가 없는지 확실히 해두고 싶습니다. 즉, 보고한 점수가 유효한지 아닌지 알고 싶은 것이고, 이 말은 리그 룰에 따르는 경우 이 점수들을 각 팀에 할당하는 것이 가능해야 합니다.\n주어진 n 개의 정수들은 각 팀에서 보고한 점수들로 이 점수들이 유효한지 아닌지 알아내는 프로그램을 작성해야 합니다.\n",
        "input_text": "프로그램은 표준 입력에서 읽어야 합니다. 입력은 두 줄로 이루어져 있고, 첫째 줄은 하나의 정수 n (2 ≤ n ≤ 10,000) 이고, 팀의 개수를 의미합니다. 다음 줄은 각 팀에서 보고한 점수들입니다. 각 정수는 0 보다 같거나 크고 n - 1 보다 같거나 작습니다.\n",
        "output_text": "프로그램은 표준 출력에 써야 합니다. 보고한 점수들이 유효한 경우라면 1 을 출력하고, 그렇지 않으면 -1 을 출력합니다.\n",
        "memory_median": 2056.0,
        "time_median": 0.0,
        "length_median": 532.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "239": {
        "problem_text": "Let us remind you about how the total penalties are calculated for this contest:\n\nWhen you solve a problem at $T$ minutes, $T+20V$ is added to your penalty, where $V$ is the number of incorrect verdicts (except compile errors) received on that problem.\nIf you do not solve a problem before the contest ends, the incorrect verdicts on that problem are not counted as penalties.\n\nHere is a bad news for all of you: we, the problem setters, are planning to join the competition and solve our own problems!\nWe know our problems really well, so we can solve all the problems before the contest ends. Furthermore, we can precisely predict how long it takes to solve each problem, and how many incorrect verdicts (except compile errors) we get in each problem. Depending on the order of the problems we solve, our total penalty might differ. What is the minimum penalty if we solve all problems?\n",
        "input_text": "11 lines are given as the input. The $i$-th line contains two space-separated integers, $D_i$ and $V_i$, where $D_i$ is the amount of minutes required to solve the $i$-th problem, and $V_i$ is the number of incorrect verdicts on the $i$-th problem.\nFor each $i$, $1 \\leq D_i$ and $0 \\leq V_i \\leq 1\\ 000$. Also, $\\sum_{i=1}^{11} D_i \\leq 300$.\n",
        "output_text": "Output the minimum penalty if we solve all problems.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 448.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "240": {
        "problem_text": "청정수열은 길이가 $2N$이고 $1$부터 $N$까지의 정수들이 정확히 두 번씩 등장하는 수열이다.\n청정수열의 점수는 $1$이상 $N$이하인 모든 정수 $i$에 대해 다음 값의 합이다.\n\n(두 개의 $i$ 사이에 있는 수의 합) × $i$\n\n이때, \"사이\"는 양 끝의 $i$를 포함한다.\n길이가 $2N$이면서 점수가 최소인 청정수열의 개수를 구해보자.\n",
        "input_text": "첫째 줄에 정수 $N$이 주어진다. ($1 \\le N \\le 10$)\n",
        "output_text": "첫째 줄에 길이가 $2N$이면서 점수가 최소인 청정수열의 개수를 출력하라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 234.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "241": {
        "problem_text": "전대프연 대회에서 문제를 푼 팀은 풍선을 받게 된다. 풍선은 사람이 직접 달아주기 때문에 자원 봉사자가 필요하다.\n풍선은 방 A와 방 B에 보관되어 있다. 대회에 참가한 팀의 수는 총 N개이고, 앉아있는 자리는 서로 다르다. 어떤 팀은 방 A에 가깝고, 어떤 팀은 B에 더 가깝다. \n각 팀에게 달아줘야 하는 풍선의 수와 방 A와 B로부터의 거리가 주어진다. 이때, 모든 풍선을 달아주는데 필요한 이동 거리의 최솟값을 출력한다. 대회에서 풍선을 달아주는 사람은 매우 많고, 풍선은 한 가지 색상을 여러 개 달아준다고 가정한다. 풍선을 달기 위해 이동해야하는 거리는 팀이 A와 B로부터 떨어진 거리와 같다. 풍선을 달아주는 사람은 한 번에 풍선 하나만 들고 이동할 수 있다.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 팀의 수 N(1 ≤ N ≤ 1,000)과 방 A와 B에 보관되어있는 풍선의 수 A, B가 주어진다. (0 ≤ A, B ≤ 10,000) \n다음 N개 줄에는 팀에게 달아줘야하는 풍선의 수 K와 방 A로부터 떨어진 거리 DA, B로부터 떨어진 거리 DB (0 ≤ DA, DB ≤ 1,000)가 주어진다. 풍선이 부족한 경우는 없다. 즉, Σi Ki ≤ A+B.\n입력의 마지막 줄에는 0이 세 개 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해서, 모든 팀에게 풍선을 달아주기 위해 필요한 이동 거리의 최솟값을 한 줄에 하나씩 출력한다. 이때, 풍선을 달아주고 방 A나 B로 돌아오는 거리는 포함하지 않는다. 즉, 방 A와 B에서 팀으로 이동하는 거리만 포함한다.\n",
        "memory_median": 2032.0,
        "time_median": 8.0,
        "length_median": 1471.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "242": {
        "problem_text": "n개의 정수로 이루어진 수열이 있다. 이 수열에서 한 정수를 제거하거나, 또는 두 정수를 제거할 수 있다. 한 정수를 제거하는 경우에는 그 정수가 점수가 되고, 두 정수를 제거하는 경우에는 두 정수의 곱이 점수가 된다. 이를 반복하여 수열에 아무 수도 남지 않게 되었을 때, 점수의 총 합의 최대를 구하는 프로그램을 작성하시오.\n예를 들어 -1, 5, -3, 5, 1과 같은 수열이 있다고 하자. 먼저 1을 제거하고, 다음으로는 5와 5를 제거하고, 다음에는 -1과 -3을 제거했다고 하자. 이 경우 각각 점수가 1, 25, 3이 되어 총 합이 29가 된다.\n",
        "input_text": "첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 절댓값이 1,000,000을 넘지 않는 정수가 n개 주어진다.\n",
        "output_text": "첫째 줄에 최대 점수를 출력한다.\n",
        "memory_median": 3284.0,
        "time_median": 20.0,
        "length_median": 957.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "243": {
        "problem_text": "방탈출 게임을 하던 혜민이는 마지막 문제에 봉착했다. 단서는 다음과 같다.\n\n앞에는 일렬로 놓여진 N개의 버튼이 모두 불이 꺼진 상태로 있다.\n0 또는 1로 구성되어 있는 N자리 수가 적힌 쪽지가 있다.\n0은 불이 꺼진 버튼, 1은 불이 켜진 버튼을 뜻한다.\n불이 켜져 있는 버튼을 누르면 불이 꺼지고, 불이 꺼져 있는 버튼을 누르면 불이 켜진다.\n버튼을 누르면 그 버튼 뿐만이 아닌 오른쪽 두 개의 버튼도 같이 눌린다. \n\n혜민이는 현재 모두 불이 꺼진 상태에서 버튼을 최소로 눌러서 쪽지와 똑같은 상태로 만들어야 한다는 것을 알아냈다! 혜민이를 도와줘서 방탈출 게임에 성공하자.\n",
        "input_text": "첫째 줄에 N(1 ≤ N ≤ 1,000,000)가 주어지고 둘째 줄에는 쪽지에 적혀 있는 N자리의 수가 빈 칸을 사이에 두고 주어진다.\n",
        "output_text": "눌러야하는 버튼의 최솟값을 출력한다.\n",
        "memory_median": 5928.0,
        "time_median": 92.0,
        "length_median": 478.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "244": {
        "problem_text": "N개의 문자로 이루어진 문자열 S가 입력된다.\n이 문자열의 각 문자들로 새로운 문자열 T를 만들려고한다.\n문자열 S로 문자열 T를 만드는 규칙은 다음과 같다.\n\n문자열 S의 가장 앞의 문자 하나를 문자열 T의 마지막에 추가한다.\n문자열 S의 가장 뒤의 문자 하나를 문자열 T의 마지막에 추가한다.\n\n위 규칙으로 만들어진 문자열 T들 중 사전순으로 가장 빠른 문자열을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 문자열 S의 길이 N이 주어진다. (N <= 2,000)\n이후 N개의 줄에 S를 이루는 문자들이 주어진다.\n",
        "output_text": "만들어진 사전순으로 가장 빠른 문자열을 출력한다. 80글자마다 새줄 문자를 출력해야 한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 925.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "245": {
        "problem_text": "명예에 죽고 명예에 사는 나라 얼라이언스에는 1명의 왕과  N명의 국회의원이 있다. 각 N 명의 국회의원은 a1, a2, ..., aN 의 명예 점수를 갖고 있으며, 명예 점수가 양수인 한 그들은 국회의원을 계속 할 수 있다. 하지만 명예 점수가 0 이하가 되는 순간 그들은 국회의원에서 박탈당하며 오랫동안 비난의 대상이 된다.\n국회의원들에게 밀려 권력이 없는 왕은 프로젝트 “Defile”을 설계해 모든 국회의원을 없애버릴려고 한다. 프로젝트 “Defile”은 다음과 같은 방식으로 작동한다. \n\n 모든 국회의원을 모독해서 각각의 명예 점수를 1씩 감소시킨다.\n (1)로 인해 1명이라도 국회의원에서 박탈당한 사람이 발생했다면 국민들의 분노를 이용해 (1)로 돌아간다.\n (1)에 의해 국회의원에서 박탈당한 사람이 없다면 프로젝트를 종료한다.\n\n프로젝트 자체가 명예롭지 못한 행동이기에 왕은 단 1번의 “Defile”을 실행해 모든 국회의원을 박탈시키고 싶다. 이를 위해 그는 전문해커집단 “제이나”에서 해커를 여러 명 고용했다. “제이나”에 소속된 각 해커는 사이버 상에 있는 흑역사를 추적해 국회의원 1명의 명예를 1만큼 감소시킬 수 있다. 이 역시 명예롭지 못하기에 왕은 최소한의 해커를 고용하려고 한다. 과연 왕은 최소 몇 명의 해커를 고용해야 할까? \n",
        "input_text": "첫 번째 줄에는 국회의원의 명수 N이 주어진다. (1 ≤ N ≤ 100,000)\n이후 두 번째 줄부터 N개의 줄에 걸쳐 국회의원의 명예 점수가 주어지며, 그중 i번째 줄에는 i번째 국회의원의 명예점수인 정수 ai 가 주어진다. (1 ≤ ai ≤ 100,000)\n",
        "output_text": "첫 번째 줄에 프로젝트를 성공시키기 위해 최소한으로 고용해야하는 해커의 수를 출력한다.\n",
        "memory_median": 2412.0,
        "time_median": 20.0,
        "length_median": 479.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "246": {
        "problem_text": "muse는 네이버 카페에 글을 올리려고 한다. 하지만 키보드가 고장나서, 어떤 키를 누르든 abcdefghijklmnopqrstuvwxyz가 입력된다!\nmuse는 글을 올리고 싶지만, 원하는 글을 쓰기 위해서는 아래와 같은 작업을 해야 한다.\n\nabcdefghijklmnopqrstuvwxyz를 $K$번 반복해서 입력한다.\n원하는 글자를 마우스로 지워, 최종 글을 완성한다.\n\nmuse는 많은 글자를 지우는 일이 귀찮기 때문에, $K$를 최소화하려 한다. muse가 원하는 글을 입력하려면 abcdefghijklmnopqrstuvwxyz를 몇 번 입력해야 하는지 구해 주자.\n",
        "input_text": "muse가 입력하고자 하는 글 $S$가 주어진다. 이 글은 알파벳 소문자만으로 이루어져 있으며, 길이는 $L$이다. ($1 \\le L \\le 10^5$)\n",
        "output_text": "$K$의 최솟값을 출력한다.\n",
        "memory_median": 2268.0,
        "time_median": 0.0,
        "length_median": 302.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "247": {
        "problem_text": "메이플스토리 뉴비 키파가 드디어 레벨 200을 달성하고 5차 전직이라는 시스템을 이용해 캐릭터를 더욱 강력하게 만들려고 합니다. 5차 전직을 하려면 먼저 퀘스트를 통해 아케인스톤이라는 아이템을 받아야 합니다. 아케인스톤을 활성화시키면 캐릭터가 얻는 경험치를 아케인스톤에 모을 수 있습니다. 5차 전직을 하기 위해서는 총 n개의 퀘스트를 진행해서 n개의 아케인스톤을 받아야 하며, 각각의 아케인스톤에 5억 이상의 경험치를 모으면 5차 전직을 진행할 수 있는 자격이 주어집니다.\ni번째 퀘스트를 진행하면 ai의 경험치와 i번째 아케인스톤이 주어집니다. 퀘스트로 얻는 경험치도 사냥으로 얻는 것과 똑같은 경험치이기 때문에, i번째 퀘스트의 보상 경험치를 받을 때 활성화되어 있던 아케인스톤에는 ai의 경험치가 추가됩니다.\n\n메이플월드의 아케인스톤입니다. 멋지죠.\n원래 메이플스토리에서는 한 번에 하나의 아케인스톤만 활성화시켜 놓을 수 있고, 각각의 아케인스톤에는 최대 5억의 경험치를 채울 수 있습니다. 그러나 해킹에는 자신이 있었던 메린이 키파는 서버를 해킹해 아케인스톤의 최대 경험치 제한을 없애 버리고, 최대 k개의 아케인스톤이 동시에 활성화되어 있을 수 있도록 바꿨습니다. 따라서 한 퀘스트의 보상 경험치가 여러 개의 아케인스톤에 추가될 수 있습니다. 예를 들어 1번째와 3번째 아케인스톤이 활성화되어 있는 상태에서 2번째 퀘스트를 진행해 100,000의 경험치와 2번째 아케인스톤을 획득하면, 1번째와 3번째 아케인스톤에 각각 100,000의 경험치가 추가되고 2번째 아케인스톤은 모인 경험치가 0인 상태로 받게 됩니다.\n키파는 퀘스트를 원하는 순서대로 진행할 수 있지만, 같은 퀘스트를 두 번 이상 진행할 수는 없습니다. 키파는 퀘스트를 진행하면서 아케인스톤을 적절히 활성화 또는 비활성화시켜서 아케인스톤에 모인 경험치의 합을 최대화하고 싶습니다. 모인 경험치의 합이 커지면 어쨌든 기분이 좋으니까요. 키파를 대신해서 이 값을 구해 주세요!\n",
        "input_text": "첫째 줄에 정수 n과 k(1 ≤ k ≤ n ≤ 3 · 105)가 주어집니다.\n둘째 줄에 n개의 정수가 공백을 사이에 두고 주어집니다. i번째 정수는 ai이며 0보다 크고 108보다 작거나 같습니다.\n",
        "output_text": "첫째 줄에 키파가 아케인스톤에 모을 수 있는 경험치의 합의 최댓값을 출력합니다.\n",
        "memory_median": 4332.0,
        "time_median": 80.0,
        "length_median": 418.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "248": {
        "problem_text": "민겸이는 크림 파스타를 먹다가 다음과 같은 문제를 생각해냈다.\n빈 배열 \\(A\\)가 있다. 민겸이는 \\(A\\)의 맨 뒤에 정수를 \\(N\\)번 추가하려고 한다. 수를 그냥 추가하기만 하면 재미없으니, 수를 추가할 때마다 1 ≤ \\(i\\) ≤ \\(j\\) ≤ \\(|A|\\) 를 만족하는 정수 \\(i\\), \\(j\\)에 대하여 \\(A_j - A_i\\)의 최댓값을 구하려고 한다. \\(|A|\\)는 배열 \\(A\\)의 현재 길이를 뜻하고, \\(A_i\\)는 민겸이가 \\(i\\)번째로 추가한 정수를 뜻한다.\n민겸이가 식사를 마치기 전에 이 문제를 대신 풀어보자.\n",
        "input_text": "입력은 두 줄로 주어진다.\n첫 번째 줄에는 민겸이가 배열에 추가하려는 정수의 개수 \\(N\\)이 주어진다.\n두 번째 줄에는 \\(A_1\\)부터 \\(A_N\\)까지 \\(N\\)개의 정수가 공백으로 구분되어 주어진다.\n",
        "output_text": "각 \\(A_i\\)가 추가된 직후의 문제의 답 \\(N\\)개를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2800.0,
        "time_median": 52.0,
        "length_median": 466.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "249": {
        "problem_text": "수능 시험을 앞둔 민지는 수능 전날 점집에서 점괘를 받았다. 이 점괘를 통해 민지는 어떤 학교에 합격할지를 해석할 수 있다. 점괘 $S$는 알파벳 대문자로 이루어진 문자열이다.\n점괘를 해석하는 방법은 다음과 같다. 점괘의 첫 글자부터 차례대로 점괘를 읽는다. $i$번 글자까지 읽었을 때, 현재까지 읽은 점괘에서 순서를 유지한 채로 $0$개 이상의 글자를 제거하고 YONSEI나 KOREA를 얻을 수 있다면, 민지는 각각 YONSEI와 KOREA에 합격하는 것이다.\n민지는 YONSEI 또는 KOREA를 반드시 찾을 수 있음이 보장된다. 또한 YONSEI와 KOREA를 모두 찾을 수 있는 경우, 먼저 찾은 학교에 합격하게 된다.\n민지가 어떤 학교에 합격하게 될지를 알아보자. 두 학교를 동시에 합격할 수 없음이 보장된다.\n",
        "input_text": "점괘 $S$가 주어진다.\n",
        "output_text": "민지가 합격할 학교를 출력한다.\n",
        "memory_median": 2912.0,
        "time_median": 4.0,
        "length_median": 581.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "250": {
        "problem_text": "두 변의 길이가 모두 양의 정수인 직사각형 모양의 종이가 주어져 있다. 이 종이를 칼로 여러 번 잘라서 모든 조각이 한 변의 길이가 양의 정수인 정사각형이 되도록 하고자 한다. \n칼로 종이를 자르는 규칙은 다음과 같다.\n\n자르는 방향은 수직 또는 수평만 허용된다. 즉, 사선으로는 자를 수 없다.\n자르는 도중 칼의 방향을 바꿀 수 없다.\n자르는 도중에 칼을 멈출 수 없다. 즉, 일단 어떤 조각을 자르기 시작하면 그 조각이 반드시 둘로 분리될 때 까지 자른다.\n잘려진 조각의 각 변의 길이는 양의 정수이어야 한다. \n\n위의 규칙에 따라 주어진 직사각형 모양의 종이를 잘라 각 조각이 정사각형이 되도록 하되, 잘려진 조각 개수가 최소가 되도록 하고자 한다. \n예를 들어, 아래 왼쪽 그림에서 보인 것과 같이 두 변의 길이가 5와 6인 종이가 주어질 때, 최소 개수의 정사각형 조각을 얻도록 자른 결과를 아래 오른쪽 그림에서 보였다.\n\n두 변의 길이가 주어진 직사각형의 종이를 제시한 규칙에 따라 잘랐을 때, 잘려진 조각의 개수가 최소가 되도록 하는 프로그램을 작성하시오.\n",
        "input_text": "한 줄에 직사각형 변의 길이를 나타내는 두 정수 n (1 ≤ n ≤ 10,000)과 m (1 ≤ m ≤ 100)이 차례로 주어진다.\n",
        "output_text": "주어진 변의 길이를 갖는 직사각형 모양의 종이를 제시한 규칙에 따라 잘랐을 때 생긴 조각의 최소 개수를 표준출력 한 줄에 출력한다. \n",
        "memory_median": 6004.0,
        "time_median": 16.0,
        "length_median": 747.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "251": {
        "problem_text": "타슈는 대전시에서 제공하는 공용자전거 서비스이다. 시민들은 각 무인대여소에 배치된 자전거를 대여해 이용할 수 있고, 이용이 끝난 후에는 다시 무인대여소에 반납해야 한다. 자전거를 대여한 대여소에 다시 반납할 필요 없이 아무 대여소에 반납하면 된다.\n대전시는 $N$개의 대여소를 설치한 후, 자전거의 수요를 고려해서 각 대여소에 $a_1,a_2,\\cdots ,a_N$개의 자전거를 배치하고 서비스를 시작했다. 그리고 얼마 뒤에 서비스의 품질 개선을 위해 잠시 타슈 서비스를 중단하고 모든 자전거를 대여소에 반납하게 했다. 다행히도 유실된 자전거는 없었지만, 각 대여소에 위치한 자전거의 개수가 $b_1,b_2,\\cdots ,b_N$이 되었다.\n대전시에서 일하는 영우는 타슈 서비스를 재개하기 전에 각 대여소에 위치한 자전거의 개수를 다시 $a_1,a_2,\\cdots ,a_N$으로 만들려고 한다. 영우는 직접 발로 뛰면서 $i$번째 대여소에 위치한 자전거 한 대를 들어다가 $j$번째 대여소로 옮길 수 있다. 영우는 자전거를 최소 몇 번 옮겨야 하는지 구해보자.\n",
        "input_text": "첫째 줄에 정수 $N(2\\le N\\le 100)$이 주어진다.\n둘째 줄에 정수 $a_1,a_2,\\cdots ,a_N(1\\le a_i\\le 100)$이 공백으로 구분되어 주어진다.\n셋째 줄에 정수 $b_1,b_2,\\cdots ,b_N(1\\le b_i\\le 100)$이 공백으로 구분되어 주어진다.\n$a_1+a_2+\\cdots +a_N$은 $b_1+b_2+\\cdots +b_N$과 같다.\n",
        "output_text": "각 대여소에 위치한 자전거의 개수를 $a_1,a_2,\\cdots ,a_N$으로 만들기 위해서 자전거를 최소 몇 번 옮겨야 하는지 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 389.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "252": {
        "problem_text": "어떤 원본 문자열 S가 주어졌을 때, 이 문자열의 부분을 복사하여 P라는 새로운 문자열을 만들려고 한다. 복사를 할 때에는 copy(s, p) 이라는 함수를 이용하는데, 이는 S의 s번 문자부터 p개의 문자를 P에 복사해서 붙인다는 의미이다.\n예를 들어 S=\"abaabba\", P=\"aaabbbabbbaaa\"인 경우를 생각해 보자. 이때는 copy(3, 2), copy(4, 3), copy(2, 2), copy(5, 2), copy(2, 3), copy(1, 1) 를 수행하여 P를 만들 수 있다. 각 단계별로 P는 \"aa\", \"aaabb\", \"aaabbba\", …와 같이 변하게 된다.\n이와 같은 copy 연산을 이용하여 S에서 P를 만들려고 하는데, 이때 가능하면 copy 함수를 조금 사용하려고 한다.\nS와 P가 주어졌을 때, 필요한 copy 함수의 최소 사용횟수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 S, 둘째 줄에 P가 주어진다. S와 P는 영어 대소문자와 숫자로만 되어 있다. S의 길이는 1,000을 넘지 않으며, P의 길이는 1,000을 넘지 않는다. copy함수만을 이용하여 S에서 P를 만들어낼 수 없는 경우는 입력으로 주어지지 않는다고 가정하자. 각 문자열은 최소한 한 개의 문자로 이루어져 있다.\n",
        "output_text": "첫째 줄에 copy 함수의 최소 사용횟수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 608.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "253": {
        "problem_text": "알파벳 소문자로 이루어진 길이 L인 문자열이 있다. 이 문자열의 부분문자열 중, 적어도 한 번은 반복되는 (다시 말해서, 전체 문자열에서 두 번 이상 나타나는) 부분문자열을 '반복 부분문자열'이라고 부르자.\n문자열이 주어지면, 가장 긴 '반복 부분문자열'의 길이를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 문자열의 길이 L(1 ≤ L ≤ 200,000)이 주어진다. 둘째 줄에는 문자열을 이루는 L개의 알파벳 소문자들이 띄어쓰기 없이 주어진다.\n",
        "output_text": "첫째 줄에 가장 긴 '반복 부분문자열'의 길이를 출력한다. 만일 '반복 부분문자열'이 하나도 존재하지 않는다면 0을 출력한다.\n",
        "memory_median": 7098.0,
        "time_median": 232.0,
        "length_median": 1469.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "254": {
        "problem_text": "독서를 싫어하는 원섭이는 책에서 단어 하나를 임의로 선택한다. 그 다음, 단어를 세 부분으로 나눈다.\n세 부분으로 나눈 단어를 각각 순서를 뒤집는다. (첫 번째 글자와 마지막 글자의 위치를 바꾸고, 두 번째 위치와 뒤에서 두 번째 글자의 위치를 바꾸고... 이런 식으로 계속)\n마지막으로, 이 세 단어를 나누기 전과 같은 순서로 합쳐 하나로 만든다.\n원섭이는 사전순으로 가장 앞서는 단어를 만들려고 한다. 원섭이가 고른 단어가 주어졌을 때, 만들 수 있는 단어 중 가장 앞서는 단어를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 원섭이가 고른 단어가 주어진다. 고른 단어는 알파벳 소문자로 이루어져 있고, 길이는 3보다 크거나 같고, 50보다 작거나 같다.\n",
        "output_text": "첫째 줄에 원섭이가 만들 수 있는 단어 중 사전순으로 가장 앞서는 단어를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 672.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "255": {
        "problem_text": "\n여러분은 연세를 사랑하십니까?\n연세인이 가장 사랑하는 응원곡,\n사랑한다 연세여, 연세여 사랑한다...\n\n고려대학교 학생 훈규는 2022 정기 연고전에서 열심히 응원을 하다가 정신을 잃고 깨어나 보니 연세대학교의 감옥에 갇혀 있었다. 훈규가 감옥을 탈출하기 위해서는 바닥에 깔린 비밀번호 석판을 이용해서 비밀번호 \"ILOVEYONSEI\"를 입력해야 한다.\n비밀번호 석판은 총 26가지의 석판이 일렬로 나열되어 있고, 각각 알파벳 대문자가 왼쪽부터 알파벳 순서대로 적혀 있다. 즉, $i$번째 석판에는 $i$번째 알파벳 대문자가 적혀 있다. 인접한 석판의 거리는 1이다. 따라서 A가 적힌 석판에서 출발해Z가 적힌 석판에 도착하기 위해서는 25의 거리를 이동해야 한다. 원하는 알파벳을 입력하려면 해당 알파벳이 적혀 있는 석판 위에 올라가 점프해야 한다. 점프는 0의 거리를 이동한다.\n훈규가 현재 위치한 석판의 알파벳이 주어진다. 훈규는 최소로 이동해 비밀번호를 모두 입력하고자 한다.\n",
        "input_text": "입력은 아래와 같이 주어진다.\n$c$\n",
        "output_text": "훈규가 비밀번호를 모두 입력하기 위한 이동 거리의 최솟값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 271.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "256": {
        "problem_text": "방금 도착한 암호문을 해독했는데, 해독에 오류가 없는지 확인해보려 한다. 해독한 문장이 암호문을 해석한 결과로 나올 수 없다면, 그 해독은 잘못된 것이다.\n암호문은 0 이상 52 이하의 정수로 이루어져 있다. 0은 띄어쓰기, 1 - 26 범위 안의 수는 A ~ Z, 27 - 52 범위 안의 수는 a ~ z로 해석된다. 암호문은 띄어쓰기를 포함한 모든 철자를 이와 같이 정수로 치환한 후 순서를 무작위로 뒤섞어서 만들어졌다.\n",
        "input_text": "첫 번째 줄에는 주어질 수열의 길이 N이 주어진다. (1 ≤ N ≤ 100,000)\n두 번째 줄에는 암호문에 해당하는 수 N개가 띄어쓰기와 함께 주어진다.\n세 번째 줄에는 평문이 주어진다. 단, 평문의 길이는 N과 같으며, 띄어쓰기로 시작하거나 끝나지 않는다.\n",
        "output_text": "평문을 암호화해서 주어진 암호문을 만들 수 있다면 \"y\", 아니라면 \"n\"을 따옴표 없이 출력한다.\n",
        "memory_median": 2416.0,
        "time_median": 16.0,
        "length_median": 704.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "257": {
        "problem_text": "팬그램은 모든 알파벳을 적어도 한 번씩을 사용한 영어 문장을 말한다.\n다음은 유명한 팬그램 중 하나이다.\nThe quick brown fox jumps over a lazy dog\n더블 팬그램은 모든 알파벳을 적어도 두 번씩은 사용한 문장을 말하고,\n트리플 팬그램은 모든 알파벳을 적어도 세 번씩은 사용한 문장을 말한다.\n더 이어나갈 수도 있겠지만 시간상 여기까지만 하도록 하겠다.\n",
        "input_text": "입력은 여러 줄의 테스트케이스들로 이루어진다.\n첫째 줄에 테스트케이스의 수 n이 주어진다.\n각 테스트케이스는 영어 소문자와 대문자, 특수기호들로 이루어진다.\n",
        "output_text": "각 케이스마다 한 줄에 하나씩 다음 중 하나를 출력한다.\n\n팬그램이 아닐 경우 - Not a pangram\n팬그램일 경우 - Pangram!\n더블 팬그램일 경우 - Double pangram!!\n트리플 팬그램일 경우 - Triple pangram!!!\n\n트리플 팬그램일 경우에는 자연스럽게 팬그램과 더블 팬그램이 되지만, Triple pangram!!!만을 출력한다. 더블 팬그램도 마찬가지이다.\n",
        "memory_median": 2024.0,
        "time_median": 4.0,
        "length_median": 917.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "258": {
        "problem_text": "Classical information theory is based on the concept of a communication channel.\n\nInformation theory is generally considered to have been founded in 1948 by Claude Shannon in his seminal work, “A Mathematical Theory of Communication.” The central paradigm of classical information theory is the engineering problem of the transmission of information over a noisy channel.\nhttp://en.wikipedia.org/wiki/Information theory\n\nIn this problem, we will specifically consider one of the simplest possible noisy channels, namely the binary symmetric channel (BSC). A BSC transmits a sequence of bits, but each transmitted bit has a probability p of being flipped to the wrong bit. This is called the crossover probability, as can be understood from the figure. We assume independent behaviour on different bits, so a communication of l bits has probability (1 − p)l of being transmitted correctly. Note that one can always assume that p < 1/2, since a channel with p = 1/2 is totally useless, and a channel with p > 1/2 can easily be transformed to a new channel having crossover probability 1 − p by just flipping all bits of the output.\nOf course, it is still possible to communicate over a noisy channel. (In fact, you are doing it all the time!) To be able to do this, one has to add extra bits in order for the receiver to detect or even possibly correct errors. Example implementations of such a feature are parity bits, Cyclic Redundancy Checks (CRC) and Golay codes. These are not relevant to this problem, however, so they will not be discussed here.\nIn this problem you must investigate the behaviour of a binary symmetric channel.\n",
        "input_text": "The first line of the input consists of a single number T, the number of transmissions. Then follow T lines with the input and the output of each transmission as binary strings, separated by a single space.\n\n0 < T ≤ 100\nAll inputs and outputs has length less than 120.\nT is encoded in decimal.\n\n",
        "output_text": "For each transmission, output OK if the communication was transmitted correctly, or ERROR if it was transmitted incorrectly.\n",
        "memory_median": 2024.0,
        "time_median": 4.0,
        "length_median": 273.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "259": {
        "problem_text": "도깨비말은 언어 유희 중 하나로, 글자를 특정 법칙에 따라 재구성하는 것을 말한다.\n영어권에서는 피그라틴어라는 것이 있다. 주로 어린이들이 많이 쓰는 데, 남들에게 무슨 말인지 모르게 하기 위해 종종 쓴다. \n여기엔 규칙이 있는데, 맨 앞글자가 모음이 아닐때 까지 맨 앞 글자를 어미로 돌린 후 그 끝에 ay를 붙여서 완성한다. 예를 들면 frog는 ogfray이 된다. 만약 맨 앞자음이 없는 apple과 같은 경우는 끝에 ay만 붙여 appleay가 된다. 또는, 단어에 모음이 없는 경우에도 단어의 끝에 ay만 붙인다.\n주어진 단어를 피그라틴어로 바꾸는 프로그램을 작성하시오.\n",
        "input_text": "한 줄에 하나의 단어씩 주어진다. 그리고 마지막 줄에 #을 입력받고 끝낸다.\n주어진 단어는 20자를 넘지 않고 공백없이 소문자로만 이루어져있다. 여기서 모음이란 'a', 'e', 'i', 'o', 'u' 를 말한다.\n",
        "output_text": "한 줄에 하나씩 피그라틴어를 출력한다.\n",
        "memory_median": 2006.0,
        "time_median": 0.0,
        "length_median": 605.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "260": {
        "problem_text": "환규와 태욱이는 둘이서 즐길 수 있는 간단한 게임인 탕수육 게임을 하기로 했다. 게임의 규칙은 다음과 같다.\n\n누가 먼저 시작할지 순서를 정한다.\n먼저 시작하는 사람이 단어의 가장 첫 글자를 말한다.\n이후 두 사람이 번갈아 가며 자신의 차례에 이전 사람이 말한 글자의 다음 글자를 말한다.\n만약 이전 사람이 단어의 가장 마지막 글자를 말했다면 자신의 차례에 단어의 가장 첫 글자를 말한다.\n만약 자신의 차례에 잘못된 글자를 말하면 게임에서 지게 된다.\n\n위 규칙을 이용해 탕수육이란 단어를 가지고 게임을 진행하면 다음과 같다.\n탕 수 육 탕 수 육 탕 수 육 탕 수 육 …\n위 예시에서 밑줄 친 부분은 첫 번째 사람이, 밑줄이 없는 부분은 두 번째 사람이 말하게 되는 부분이다. 이때 밑줄 그어진 부분만 따로 살펴보면 “탕육수탕육수…”가 됨을 알 수 있는데, 따라서 먼저 시작하는 사람은 게임을 시작하기 전에 “탕육수” 만을 기억한 후 상대방이 어떤 단어를 말하든 “탕육수” 순서로 계속 반복해서 말하면 절대로 틀리지 않는다. 만약 “탕육”이나 “탕육수탕”을 기억한다면 기억한 문자열을 처음부터 하나씩 순서대로 말했을 때 자신의 차례에 올바르지 않은 문자를 말하게 되어 게임에서 지게 된다. “탕육수탕육수”를 기억한다고 하더라도 자신의 차례에 틀린 문자를 말하게 되지는 않지만, “탕육수” 만을 기억해도 게임을 진행할 수 있으므로 이 경우 항상 기억해야 할 최소한의 글자만을 기억한다고 가정한다. 또한, 나중에 시작하는 사람도 게임을 시작하기 전에 “수탕육”만을 기억한 다음 “수탕육” 순서대로 반복해서 말하면 절대로 틀리지 않는다.\n환규와 태욱이는 이번에는 한글 대신 알파벳을 사용해서 게임을 해보기로 했다. 만약 주어진 단어가 “ABC”이고, 환규가 먼저 시작한다면 환규는 “ACB”를, 태욱이는 “BAC” 만을 기억하면 게임을 지지 않게 된다. 게임에 사용할 알파벳으로 된 문자열이 주어질 때, 두 사람이 미리 기억하고 있어야 되는 문자열 중 가장 짧은 것을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에 테스트 케이스의 개수를 나타내는 자연수 T가 주어진다. 각각의 테스트 케이스의 첫째 줄에 게임에 사용할 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고 26보다 작거나 같다. 게임에 사용할 문자열은 알파벳 대문자로만 이루어져 있으며 같은 알파벳을 두 개 이상 포함하지 않는다.\n",
        "output_text": "출력은 표준 출력을 사용한다. 입력받은 데이터에 대해, 각 테스트 케이스의 답을 순서대로 출력한다. 각 테스트 케이스마다 첫 번째 줄에 먼저 시작한 사람이 기억해야 될 문자열 중 가장 짧은 것을 알파벳 대문자로 출력한다. 두 번째 줄에는 나중에 시작한 사람이 기억해야 될 문자열중 가장 짧은 것을 알파벳 대문자로 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 4.0,
        "length_median": 655.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "261": {
        "problem_text": "Text messaging using a cell phone is popular among teenagers. The messages can appear peculiar because short forms and symbols are used to abbreviate messages and hence reduce typing.\nFor example, “LOL” means “laughing out loud” and “:-)” is called an emoticon which looks like a happy face (on its side) and it indicates chuckling. This is all quite a mystery to some adults.\nWrite a program that will continually input a short form and output the translation for an adult using the following translation table:\n\n\n\nShort Form\nTranslation\n\n\n\n\nCU\nsee you\n\n\n:-)\nI’m happy\n\n\n:-(\nI’m unhappy\n\n\n;-)\nwink\n\n\n:-P\nstick out my tongue\n\n\n(~.~)\nsleepy\n\n\nTA\ntotally awesome\n\n\nCCC\nCanadian Computing Competition\n\n\nCUZ\nbecause\n\n\nTY\nthank-you\n\n\nYW\nyou’re welcome\n\n\nTTYL\ntalk to you later\n\n\n\n",
        "input_text": "The user will be prompted to enter text to be translated one line at a time. When the short form “TTYL” is entered, the program ends. Users may enter text that is found in the translation table, or they may enter other words. All entered text will be symbols or upper case letters. There will be no spaces and no quotation marks.\n",
        "output_text": "The program will output text immediately after each line of input. If the input is one of the phrases in the translation table, the output will be the translation; if the input does not appear in the table, the output will be the original word. The translation of the last short form entered “TTYL” should be output.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 876.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "262": {
        "problem_text": "소떡소떡은 기다란 꼬치에 소세지와 떡을 끼운 음식이다. 편의상 소떡소떡을 알파벳 s와 t로만 구성된 길이 $N$의 문자열로 생각하자. 알파벳 s는 소세지를, t는 떡을 의미한다.\n\n위 그림은 길이가 $7$인 소떡소떡의 예시이다. 유진이는 소떡소떡을 먹기 전에 소떡소떡을 팰린드롬 소떡소떡으로 만들려고 한다. 팰린드롬이란, 앞에서부터 읽었을 때와 뒤에서부터 읽었을 때가 같은 문자열을 말한다. 예를 들어 sts, tsst, tt는 팰린드롬이다.\n\n유진이는 특별한 마법을 사용해서 꼬치에 꽂힌 소세지 하나를 떡으로 바꾸거나, 반대로 떡 하나를 소세지로 바꿀 수 있다. 위 그림은 마법을 한 번 사용해서 떡 하나를 소세지로 바꾼 그림이다.\n\n위 그림은 마법을 한 번 더 사용해서 떡 하나를 소세지로 바꾼 그림이다. 이제 이 소떡소떡은 팰린드롬 소떡소떡이 되었다.\n유진이가 먹으려고 하는 소떡소떡이 주어질 때, 이 소떡소떡을 팰린드롬 소떡소떡으로 만들기 위해서는 마법을 최소 몇 번 사용해야 할까?\n",
        "input_text": "첫째 줄에 소떡소떡의 길이 $N(1 \\le N \\le 100)$이 주어진다.\n둘째 줄에 소떡소떡을 의미하는 길이 $N$의 문자열이 주어진다. 이 문자열은 알파벳 s와 t로만 구성되어 있다.\n",
        "output_text": "소떡소떡을 팰린드롬 소떡소떡으로 만들기 위해서 마법을 최소 몇 번 사용해야 하는지 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 311.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "263": {
        "problem_text": "한신이는 대학교에서 \"복붙의 달인\"으로 유명하다. 한신이는 타이핑 속도가 느리기 때문에 대학에서 가능한 모든 일을 복붙으로 해결한다. 그는 n개의 문자를 입력하는데 있어서 n초의 시간이 걸리지만 뛰어난 \"붙여넣기\" 스킬을 이용하면 어떠한 개수의 문자도 단 1초만에 타이핑 할 수 있다. 만약 한신이가 \"bana\"를 복사한 상태에서 \"banana\"를 타이핑한다면, \"bana\" 붙여넣기 1초, 'n' 입력, 'a' 입력으로 총 3초가 걸린다. 한신이가 클립보드에 저장한 p를 알고 있을 때 s를 입력하는데 걸리는 최소 시간을 계산해보자!\n",
        "input_text": "첫 번째 줄에는 테스트케이스의 개수 T(T ≤ 25)가 입력된다. 각 테스트케이스는 한 줄에 2개의 문자열 s와 p가 공백으로 구분되어 입력되며 한신이는 p를 복사하여 s를 만들어 내는 것을 목표로 한다. s의 최대 길이는 10,000이고, p의 최대 길이는 100이다.\n",
        "output_text": "각 테스트 케이스에 맞는 한신이가 p를 이용하여 s를 타이핑할 때 걸리는 최소 시간(초 단위)을 출력하라!\n",
        "memory_median": 2024.0,
        "time_median": 8.0,
        "length_median": 509.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "264": {
        "problem_text": "서울사이버대학교 빅데이터·정보보호학과는 빅데이터에 관심이 있는 학생들과 정보보호에 관심이 있는 학생들이 골고루 섞여 있는 학과이다.\n빅데이터·정보보호학과에서 수업을 하던 노교수는 학생들이 빅데이터와 정보보호 중 어느 분야에 더 관심이 많은지 궁금해졌다. 그래서 학생들을 만날 때마다 항상 이를 물어보고 답을 bigdata 혹은 security로 구분하여 메모장에 적어두었는데, 실수로 띄어쓰기와 개행이 전혀 없는 상태로 기록해두었다.\n이대로는 학생들이 빅데이터와 정보보호 중 어느 분야에 더 관심이 많은지를 알아낼 수 없기 때문에, 당신에게 분석을 의뢰했다. 물어본 학생의 수와 답이 주어질 때, 결과를 출력하자.\n",
        "input_text": "첫 번째 줄에 물어본 학생의 수 $N$이 주어진다. ($1 \\le N \\le 100\\,000$)\n두 번째 줄에 메모장에 적힌 답들이 한 줄의 문자열로 주어진다. 문자열은 bigdata 또는 security로만 구성되어 있으며, 띄어쓰기 등의 다른 문자가 포함되어 있지 않다.\n",
        "output_text": "첫 번째 줄에 정보보호 분야보다 빅데이터 분야에 관심이 있는 학생이 더 많으면 \"bigdata?\"를, 빅데이터 분야보다 정보보호 분야에 관심이 있는 학생이 더 많으면 \"security!\"를, 같으면 \"bigdata? security!\"를 따옴표 없이 출력한다.\n",
        "memory_median": 3680.0,
        "time_median": 8.0,
        "length_median": 480.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "265": {
        "problem_text": "Adam has just started learning how to walk (with some help from his brother Omar), and he falls down a lot. In order to balance himself, he raises his hands up in the air (that’s a true story), and once he puts his hands down, he falls.\nYou are given a string, each character represents a step he walks, if that character is ‘U’ that means his hands are up in this step, if this character is ‘D’ that means his hands are down and he fell down in this step. Your task is to count how many steps he will walk before falling down for the first time.\n",
        "input_text": "Your program will be tested on one or more test cases. The first line of the input will be a single integer T (1 ≤ T ≤ 100) representing the number of test cases. Followed by T test cases.\nEach test case will consist of a single line, containing a non-empty string of at most 100 characters, and each character is either ‘U’ or ‘D’. The characters from left to right represent Adam’s steps in the order he walks them.\n",
        "output_text": "For each test case print a single line containing the number of steps that Adam will walk before falling down, or the length of the string if he won’t fall down.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 369.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "266": {
        "problem_text": "만약 어떤 단어A를 숌스럽게 바꿔서 또다른 단어 B로 만든다면, 그 단어는 비슷한 단어라고 한다.\n어떤 단어를 숌스럽게 바꾼다는 말은 단어 A에 등장하는 모든 알파벳을 다른 알파벳으로 바꾼다는 소리다. 그리고, 단어에 등장하는 알파벳의 순서는 바뀌지 않는다. 두 개의 다른 알파벳을 하나의 알파벳으로 바꿀 수 없고, 임의의 알파벳을 자기 자신으로 바꾸는 것은 가능하다.\n예를 들어, 단어 abca와 zbxz는 비슷하다. 그 이유는 a를 z로 바꾸고, b는 그대로 b, c를 x로 바꾸면, abca가 zbxz가된다.\n단어가 여러 개 주어졌을 때, 몇 개의 쌍이 비슷한지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 단어의 개수 N이 주어진다. 둘째 줄부터 N개의 줄에 한 줄에 하나씩 단어가 주어진다. 단어의 길이는 최대 50이고, N은 100보다 작거나 같은 자연수이다. 모든 단어의 길이는 같고, 중복되지 않는다. 또, 알파벳 소문자로만 이루어져 있다.\n",
        "output_text": "첫째 줄에 총 몇 개의 쌍이 비슷한지 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 907.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "267": {
        "problem_text": "오른쪽 그림과 같은 핸드폰 자판이 있다. 이 자판을 이용하여 어떤 영어 메시지를 치려고 할 때, 걸리는 최소 시간을 구하는 프로그램을 작성하시오.\n단, 1번은 누를 경우에는 공백이 찍힌다고 하자. 그리고 만약에 AC라는 문자를 치려 한다면 A를 치고 난 후 일정 시간을 기다린 후 C를 치면 된다.\n하나의 문자를 입력하려면, 버튼을 눌러야 한다. 버튼을 누르면 버튼에 쓰여 있는 문자가 입력되며, 버튼을 누를 때 마다 다음 문자로 바뀌게 된다. 예를 들어, 2를 누르면 A, 2번 누르면 B, 3번 누르면 C이다. 공백을 연속으로 누를 때는 기다릴 필요가 없다.\n",
        "input_text": "첫째 줄에 p와 w가 주어진다. (1 ≤ p, w ≤ 1,000) p는 버튼을 한번 누르는데 걸리는 시간이고, w는 AC와 같은, 같은 숫자인 문자를 연속으로 찍기 위해 기다리는 시간을 의미한다. 그리고 둘째 줄에는 적을 문자열이 주어진다. 단, 이 문자열의 길이는 1000보다 작고, 맨 앞과 맨 뒤에 공백이 들어오는 경우는 없다. 문자열은 알파벳 대문자와 띄어쓰기만으로 이루어져 있다.\n",
        "output_text": "첫째 줄에 메시지를 적는데 걸리는 시간을 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 887.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "268": {
        "problem_text": "\n가끔, 그러나 때때로, 우리들은 키보드에서 양손을 오른쪽으로 한 칸씩 이동한 상태로 두고 타자를 치는 경우가 있다. 즉, \"ACMICPC.NET\"을 위와 같은 방법으로 치게 되면 \"SV,OV[V/MRY\"이라는 이상한 문장을 보게 된다.\n교준이는 장문을 쓰는데, 너무 급한 나머지 위와 같은 오류를 범한 채로 글을 완성해 버렸다. 이 글을 다시 쓰는 것은 교준이에게는 너무 힘든 일이다. 교준이를 대신해서 오류를 고쳐주자.\n",
        "input_text": "입력은 여러 줄로 이루어진다. 각 줄은 숫자나 공백, 알파벳 대문자, 위의 키보드에 표시되어 있는 문장 부호로 이루어져 있다. Q, A, Z나 `(back-quote), 단어로 이루어진 키(Tab, BackSp, Control 등)는 입력의 각 줄에 포함되지 않는다. 예외적으로 공백(' ', SpaceBar)은 입력으로 들어올 수 있는데, 스페이스 바는 너무 길어서 교준이가 위의 오류를 범하지 않는다.\n",
        "output_text": "각 줄마다 오류를 고쳐 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 756.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "269": {
        "problem_text": "토카는 문자열을 출력하는 파이썬 코드를 작성하는 것에 자신감이 있었다. 어느 날 Hello, World!를 출력해달라는 요청을 받은 토카는 자신있게 코드를 작성했지만, 큰따옴표를 찍지 않는 치명적인 실수로 인해 컴파일 에러를 받고 말았다!!\n\n컴파일 에러를 받은 토카의 코드\n토카는 이로 인해 자신감을 잃어버려 문자열 출력을 멀리하고 있다. 당신은 토카의 자신감을 회복시켜 주기 위해 문자열을 입력받았을 때 정확한 문자열인지 판독하는 프로그램을 작성하고자 한다. 정확한 문자열은 문자열의 시작과 끝이 큰따옴표로 이루어져 있으며 큰따옴표를 제외한 문자가 포함되어 있는 문자열을 뜻하는 말로, 대표적으로는 \"Hello, World!\"가 있다. 즉, 큰따옴표로 시작하지 않거나 끝나지 않은 Dijkstra나 A\"b등의 문자열은 정확한 문자열이 아니다. 이제 토카의 문자열이 정확한 문자열인지 판독하는 코드를 작성하여 보자!\n",
        "input_text": "첫 번째 줄에 토카의 문자열을 뜻하는 문자열 $S$가 주어진다. $S$는 $50$글자를 넘지 않으며, 영어 대소문자와 큰따옴표, 그리고 공백으로 이루어져 있다. 큰따옴표는 전체 문자열에서 $2$개 이하로 들어옴이 보장된다. 큰따옴표란 \"를 의미한다. 또한, 큰따옴표 안에 있는 문자열 앞뒤에 공백이 주어지는 경우나 문자열의 시작과 끝에 공백이 주어지는 경우는 주어지지 않는다.\n",
        "output_text": "토카의 문자열이 정확한 문자열이라면 큰따옴표 내부 문자열을, 만약 토카의 문자열이 정확한 문자열이 아니거나, 큰따옴표 내부가 빈 문자열이라면 CE를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 394.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "270": {
        "problem_text": "문자열 S의 부분 문자열 중에서 팰린드롬인 것 중 가장 긴 것의 길이를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 문자열 S가 주어진다. S는 알파벳 소문자로만 이루어져 있으며 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.\n",
        "output_text": "가장 긴 팰린드롬 부분 문자열의 길이를 출력한다.\n",
        "memory_median": 3488.0,
        "time_median": 4.0,
        "length_median": 869.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "271": {
        "problem_text": "마야 문자를 해독하는 일은 예상 외로 어려운 일이다. 현재에도 뜻이 완전히 밝혀진 마야 문자는 거의 없는 실정이며, 그나마 해독에 진척이 시작된 지는 30여 년도 되지 않았다.\n마야 문자는 소리를 나타내는 여러 종류의 그림글자로 구성되는데, 이 글자들이 여러 위치에서 결합함으로써 단어를 형성한다.\n마야 문자 해독을 어렵게 하는 요인 중 하나는 바로 단어를 읽는 순서이다. 마야 문자를 쓰는 고대인들은 단어를 기록할 때 특정한 규칙 대신, 그들이 보기에 좋게 보이도록 단어를 이루는 글자들을 아무렇게나 배열했다. 그렇기 때문에 고고학자들이 마야 기록에서 단어를 이루는 각 그림글자들의 발음을 알아내더라도 그 단어를 실제로 발음하는 방법은 정확히 알 수 없는 셈이다.\n고고학자들은 W라는 특정 단어를 발굴 기록으로부터 찾고 있다. 그 단어를 구성하는 각 글자들은 무엇인지 알고 있지만, 이것이 고대 기록에 어떤 형태로 숨어 있는지는 다 알지 못한다.\nW를 이루고 있는 g개의 그림문자와, 연구 대상인 벽화에 기록된 마야 문자열 S가 주어졌을 때, 단어 W가 마야 문자열 S에 들어있을 수 있는 모든 가짓수를 계산하는 프로그램을 작성하시오. 즉, 문자열  S안에서 문자열 W의 순열 중 하나가 부분 문자열로 들어있는 모든 경우의 수를 계산하라는 뜻이다.\n",
        "input_text": "첫째 줄에 고고학자들이 찾고자 하는 단어 W의 길이 g와 발굴된 벽화에서 추출한 문자열 S의 길이 |S|가 빈 칸을 사이에 두고 주어진다. (1≤g≤3000,  g≤|S|≤3,000,000) 둘째 줄에 W, 셋째 줄에 S의 실제 내용이 들어있다. 모든 문자열은 알파벳으로 이루어지며, 대소문자를 구분한다.\n",
        "output_text": "첫째 줄에 W의 순열이 S 안에 있을 수 있는 형태의 개수를 출력한다.\n",
        "memory_median": 7544.0,
        "time_median": 72.0,
        "length_median": 918.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "272": {
        "problem_text": "이환이는 4차 산업혁명 시대에 살고 있는 천재 5살 아기이다. 어느 날, 유치원 선생님은 이환이의 천재성을 알아본 후 다음과 같은 문제를 내줬다.\n$A$ 이상 $B$ 이하의 정수를 모두 더한 값은 얼마일까?\n이환이는 천재성은 있지만 아직 아기라서 덧셈이 무엇인지는 잘 모른다. 다음 날, 이환이는 공책에 $A$ 이상 $B$ 이하의 모든 정수를 크기 순서대로 띄어쓰기 없이 적어 왔다. 예를 들어 $A = 4, B = 21$ 일 경우, 이환이가 적어 온 답은 456789101112131415161718192021과 같다.\n이환이는 특출난 과제 집착력을 가진 천재지만, 이환이의 선생님은 그렇지 않다. 사실, 이환이의 선생님은 어제 본인이 부른 두 개의 수가 무엇이었는지도 잊어버렸다. 선생님이 기억하는 정보는 $A$와 $B$ 모두 $1$ 이상 $999$ 이하의 정수였고, 당연히 $A$는 $B$보다 작거나 같았다는 것뿐이다.\n이환이가 적어 온 숫자들의 나열이 주어지면, 선생님이 부른 두 수를 찾을 수 있을까?\n",
        "input_text": "첫 번째 줄에 이환이가 적어 온 답을 나타내는 문자열 $S$가 주어진다. $S$는 숫자(0123456789)로만 이루어져 있으며, 길이는 $1$ 이상 $2\\ 889$ 이하이다.\n",
        "output_text": "이환이의 선생님이 부른 두 정수 $A$와 $B$를 공백으로 구분하여 출력하라. 만약 가능한 답이 두 가지 이상이라면, 그중 $A$가 가장 작은 것을 출력하라.\n이환이는 항상 정확한 답을 쓰기 때문에, 문제의 조건을 만족하는 답이 존재하는 입력만이 주어진다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 773.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "273": {
        "problem_text": "클레어는 길이가 N인 팰린드롬 문자열을 가지고 있습니다.\n팰린드롬 문자열이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 문자열을 뜻합니다.\n예를 들어, \"rotator\", \"racecar\", \"a\"는 팰린드롬 문자열이지만 \"palindrome\", \"poq\" 는 팰린드롬 문자열이 아닙니다.\n하루는 장난기 많은 에드거가 클레어가 가지고 있는 팰린드롬 문자열의 일부를 지워버렸습니다.\n그 때문에 클레어가 많이 화가 나 있습니다. 클레어를 위해 문자열을 복구해주세요.\n",
        "input_text": "첫 번째 줄에 문자열의 길이 N (1 ≤ N ≤ 100) 이 주어집니다.\n두 번째 줄에는 일부 문자들이 지워진 길이가 N인 팰린드롬 문자열이 주어집니다. 각 문자는 알파벳 소문자이거나 '?' 이며 '?' 일 경우 해당 문자가 지워졌음을 의미합니다.\n주어지는 문자열은 적어도 한 개의 '?' 문자를 가집니다.\n",
        "output_text": "입력으로 주어진 문자열을 팰린드롬이 되도록 '?' 문자들을 적절한 알파벳 소문자들로 바꾸어 출력합니다.\n방법이 여러 가지인 경우 그 중 하나만 출력합니다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 458.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "274": {
        "problem_text": "도도는 이번 신촌캠프에서 시간복잡도의 개념에 대해 배웠다. 하지만 듣다가 졸려서 자버린 결과 오개념을 가져 버렸는데, 바로 반복문의 개수로만 시간복잡도를 판단한다는 것이다. \n시간복잡도를 판단하기 위해 도도는 같은 줄에 몇 개의 반복문이 있는지 궁금해졌다. 도도가 반복문으로 생각하는 코드는 for, while 이다. \n도도를 위해 같은 줄에 있는 반복문의 최대 개수를 구하는 프로그램을 작성해보자.\n",
        "input_text": "첫째 줄에 코드의 줄 개수 $C (1 \\leq C \\leq 100)$가 주어진다.\n둘째 줄부터 $C$개의 줄에 걸쳐 코드가 입력된다. 입력으로 주어지는 코드는 모두 알파벳 소문자이다. 각 줄은 $10\\,000$자를 넘지 않는다.\n",
        "output_text": "첫째 줄에 같은 줄에 있는 반복문의 최대 개수를 출력한다.\n",
        "memory_median": 2168.0,
        "time_median": 40.0,
        "length_median": 645.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "275": {
        "problem_text": "가톨릭대학교에 다니는 컴퓨터정보공학부 황톨릭은 코로나 때문에 슬퍼하는 친구들을 위해 게임을 하나 만들었다.\n게임이 시작되면 알파벳 대문자로만 이루어진 문자열이 주어진다. 문자열이 주어지면 각 문자의 획수로 문자를 변환한다. 획수들을 갖고 앞에서부터 두 개씩 더해가는데 만약 짝이 지어지지 않는다면 그대로 다음 단계로 내려간다. 다음 단계부터는 이전 단계에서 두 개씩 더해가며 생성된 숫자들을 가지고 같은 과정을 반복한다. 과정을 반복하다가 결국 마지막 한 개의 수가 남았을 때 그 수가 홀수라면 이기는 것이고 짝수라면 지는 게임이다!!\n예를 들어 \"ABCDE\"라는 문자열이 주어지면 ‘A’, ‘B’, ‘C’, ‘D’, ‘E’ 각 문자의 획수인 3, 2, 1, 2, 3으로 바꾸어 아래의 그림처럼 과정을 진행한다. 단, 계산할 때, 더한 값이 10을 넘는다면 10으로 나눈 나머지로 바꿔준다.\n\n‘E’의 경우는 짝을 지을 수 없으므로 3이 바로 내려오게 된다. 결국, 마지막 남은 수가 1인 홀수이므로 이 게임은 이기게 되는 것이다.\n게임의 심판역할인 톨릭이는 매번 계산하는 게 귀찮아 코드를 짜놓고 싶어한다. 톨릭이를 도와 코드를 짜주자!!\n알파벳 대문자의 획수는 아래 표와 같다.\n\n\n\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\nM\nN\nO\nP\nQ\nR\nS\nT\nU\nV\nW\nX\nY\nZ\n\n\n3\n2\n1\n2\n3\n3\n3\n3\n1\n1\n3\n1\n3\n3\n1\n2\n2\n2\n1\n2\n1\n1\n2\n2\n2\n1\n\n\n\n",
        "input_text": "첫째 줄에 알파벳 대문자로만 이루어진 길이 K(1 ≤ K ≤ 1,000,000)인 문자열 S가 주어진다.\n",
        "output_text": "첫째 줄에 정답을 출력한다.\n마지막으로 남은 수가 홀수라면 \"I'm a winner!\"를 출력하고 0이거나 짝수라면 \"You're the winner?\"를 출력한다.\n",
        "memory_median": 4908.0,
        "time_median": 16.0,
        "length_median": 552.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "276": {
        "problem_text": "시은이는 종합설계 프로젝트로 오픈월드 액션 고스톱 게임 경로당펑크 2077을 개발하고 있다. 대사를 추가하던 중, 사용자 이름에 따라 '을' 또는 '를' 중 하나를 출력해야 함을 깨달았다. 예를 들어 이름이 도현이라면 도현'을' 이라고 출력해야 하고, 인하라면 인하'를' 이라고 출력해야 한다. 그 기준은 이름 마지막 글자의 받침 존재 여부이다.\n\n사용자는 반드시 한글 음절로만 구성된 이름을 사용한다. 이름의 모든 음절은 위 표의 초성, 중성, 종성을 순서대로 하나씩만 골라 조합하여 만들 수 있다. 예를 들어 음절 인(초성 ㅇ, 중성 ㅣ, 종성 ㄴ), 하(초성 ㅎ, 중성 ㅏ, 종성 없음)는 사용자 이름에 등장할 수 있다. 반대로 짜, 계, 와, 삵은 모두 위 표에 없는 낱자가 포함되어 사용자 이름에 등장하지 않는다.\n\n위 그림과 같은 표준 두벌식 자판에서 사용자 이름을 영문 모드 소문자로 타이핑하여 얻는 문자열을 문자열 $s$라고 하자. 문자열 $s$가 주어지면 원래 사용자 이름 마지막 글자에 받침이 존재하는지 판별하는 프로그램을 작성하라.\n",
        "input_text": "첫 번째 줄에 문자열 $s$의 길이를 나타내는 정수 $N$이 주어진다.\n두 번째 줄에 문자열 $s$가 주어진다.\n",
        "output_text": "사용자 이름 마지막 글자에 받침이 있다면 1, 없다면 0을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 413.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "277": {
        "problem_text": "시험과 과제에 지친 희권이는 취미로 그림을 그리기 시작했다.\n\n하지만, 그림이 별로 마음에 들지 않아 데칼코마니로 바꾸려 한다.\n\n위에 보이는 것처럼 그림을 좌우 방향으로 반으로 포개어 접으면, 맞닿는 면에 물감이 번지면서 데칼코마니가 완성된다.\n접은 그림은 원래대로 되돌릴 수 없기 때문에 희권이는 결과를 미리 알고 싶어 한다.\n희권이에게 그림을 데칼코마니 한 결과를 알려주자.\n",
        "input_text": "첫 줄에 그림의 세로 길이 정수 N과 가로 길이 정수 M이 주어진다. (1 ≤ N, M ≤ 50, M은 짝수)\nN개 줄에 M개씩 그림에 대한 정보가 주어진다.\n물감은 26가지가 있고, 각각 알파벳 대문자 하나로 나타낸다.\n그림에서 색칠한 곳은 물감에 해당하는 알파벳으로 빈 곳은 '.'으로 표현한다. 그림의 가로 길이는 짝수이고, 그림을 접었을 때 두 물감이 겹치는 경우는 없다.\n",
        "output_text": "데칼코마니 한 그림을 N개의 줄에 걸쳐 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 543.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "278": {
        "problem_text": "Alice and Barbara played some friendly games of one-on-one basketball after work, and you agreed to help them keep score. The rules of the game were simple:\n\nEach successful shot by a player earns them either one or two points;\nThe first player to eleven points wins, with one exception;\nIf the score is tied 10–10, the previous rule is replaced by a “win by 2” rule: the first player to lead the other by at least two points wins.\n\nSo for example, 11–7, 9–11, and 14–12 are possible final scores (but not 14–13).\nWhenever Alice or Barbara scored points, you jotted down an A or B (indicating a score by Alice or by Barbara) followed by a 1 or 2 (the number of points scored). You have some records of the games Alice and Barbara played in this format, but do not remember who won each game. Can you reconstruct the winner from the game record?\n",
        "input_text": "The input consists of a single line with no more than 200 characters: the record of one game. The record consists of single letters (either A or B) alternating with single numbers (either 1 or 2), and includes no spaces or other extraneous characters. Each record will be a correct scoring history of a single completed game, played under the rules described above.\n",
        "output_text": "Print a single character, either A or B: the winner of the recorded game.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 388.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "279": {
        "problem_text": "Bessie and her cow friends are playing as their favorite cow superheroes. Of course, everyone knows that any self-respecting superhero needs a signal to call them to action. Bessie has drawn a special signal on a sheet of M×N paper (1≤M≤10,1≤N≤10), but this is too small, much too small! Bessie wants to amplify the signal so it is exactly K times bigger (1≤K≤10) in each direction.\nThe signal will consist only of the '.' and 'X' characters.\n",
        "input_text": "The first line of input contains M, N, and K, separated by spaces.\nThe next M lines each contain a length-N string, collectively describing the picture of the signal.\n",
        "output_text": "You should output KM lines, each with KN characters, giving a picture of the enlarged signal.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 498.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "280": {
        "problem_text": "단어는 알파벳(a-z, A-Z)과 하이픈(-)으로만 이루어져 있다. 단어와 다른 문자(마침표, 숫자, 심볼, 등등등...)로 이루어진 글이 주어졌을 때, 가장 긴 단어를 구하는 프로그램을 작성하시오.\nApple의 길이는 5, son-in-law는 10, ACM-ICPC는 8이다.\n",
        "input_text": "입력은 여러 줄, 문단으로 이루어져 있다. 하지만, 10,000글자를 넘지 않는다. 단어의 길이는 100을 넘지 않는다. E-N-D는 입력의 마지막을 의미한다.\n",
        "output_text": "가장 긴 단어를 소문자로 출력한다. 가장 긴 단어가 여러개인 경우에는 글에서 가장 먼저 나오는 것을 출력한다.\n",
        "memory_median": 1994.0,
        "time_median": 0.0,
        "length_median": 729.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "281": {
        "problem_text": "영어공부를 열심히 하고 있는 꿍이 대학교MT에 놀러가서 친해지고 싶은 후배들과 Simon Says 게임을 하려고 한다.\n\"Simon Says\" 게임의 룰은 간단하다. 만약 어떤 사람이 \"Simon says\"라고 말한 후 어떤 지시사항을 이야기했다면 모두 그 지시사항을 따라 하기만 하면 된다. 예를 들어 영어를 잘하는 꿍이 \"Simon says touch your nose\"라고 말한다면 모두 코를 만져야한다. 하지만 이때, 꿍이 \"Stop touching your nose\" 라고 말했을 때 누군가 코를 만지는 것을 멈춘다면 그 플레이어는 벌칙을 받아야 한다.\n즉, Simon says 라고 말한 후에 나온 지시사항만을 따라야 하는 것이다.\n하지만 똑똑한 컴공 후배들은 절대 실수할리 없는 컴퓨터 프로그램을 짜서 이 게임을 하려고 한다.\n",
        "input_text": "입력은 1 ≤ N ≤ 1 000의 N을 포함하는 줄로 시작한다.\n다음 각 N줄은 한 개의 명령이 주어지며 그 길이는 100이 넘지 않는다.\n각 명령은 대소문자가 적절히 쓰여져 있으며 각 단어는 공백으로 구분되고 문장의 끝은 마침표로 끝난다.\n일부 명령들은 \"Simon says\"라고 시작하는데 어떤 명령들은 그렇지 않을 수도 있다.\n만약 명령이 \"Simon says\"라고 시작한다면, 항상 \"says\" 뒤에 공백과 최소 한 개 이상의 추가적인 단어가 주어진다.\n어떠한 명령도 공백으로 시작하거나 끝나지 않는다.\n",
        "output_text": "정확히 \"Simon says\"가 나오는 문장에 대해서만 \"Simon says\" 이후에 나오는 나머지 부분을 각 줄에 출력한다.\n그렇지 않은 문장은 무시한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 407.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "282": {
        "problem_text": "문제 해결(Problem Solving) 능력을 기르는 데에 도움이 되는 여러 사이트가 있다. 국내 최대 규모의 Baekjoon Online Judge와 아주대학교 알고리즘 소학회 A.N.S.I.에서 관리하는 Lavida Online Judge와 같은 국내 온라인 채점 사이트를 비롯해 전 세계인이 모여 (비)정기적으로 대회를 치르는 Codeforces나 TopCoder 등 다양한 특색의 사이트가 존재한다.\n온라인 게임에서 서로를 구분하기 위해 ID를 사용하듯, 이러한 알고리즘 사이트들에서도 ID를 사용한다. 여러 알고리즘 사이트에서 동일한 ID를 사용하는 사람들도 많은데, 이 ID는 핸들(Handle)이라고도 불린다. 대화에서도 유저의 본명보다 핸들이 등장할 때가 종종 있으며, 유명한 유저의 핸들은 대명사로 사용되기도 한다.\n상민이는 알고리즘 사이트와 대회장 등에서 'qilip'라는 귀엽고 대칭성마저 완벽한 핸들을 사용한다. 하지만 상민이에게는 말 못할 고민이 있는데, 바로 남들이 자신의 핸들을 자꾸 헷갈린다는 것이다. 그중에서도 현정이는 상민이의 핸들을 'q'로 시작하고 'p'로 끝나는 것만 기억하며 'qp'라고 부른다. 'quilip'까지는 헷갈릴 수 있지만 'qp'라니, 자신의 정체성을 부정당한 상민이는 어떻게든 현정이에게 자신의 핸들을 각인시키고 싶다.\n현정이는 사람의 이름과 사람을 매칭시키는 능력은 매우 떨어지지만, 어떤 핸들이 자신이 아는 핸들 중 사전 순으로 몇 번째인지 기억하는 쓸데없는 능력을 가지고 있다. 이를 이용해 상민이는 현정이가 아는 핸들 목록 중 자신이 몇 번째인지를 알아내어 앞으로 번호를 붙여 다니려고 한다. 정체성을 지키고 싶은 상민이를 위해 현정이의 어지러운 머리속에서 임의의 순서를 가지는 핸들을 찾아보자.\n",
        "input_text": "첫 줄에 현정이가 기억하고 있는 핸들의 개수 N과 I(1 ≤ I, N ≤ 100)이 주어진다. 이후 N개의 줄에 걸쳐 현정이 기억하는 핸들이 무작위 순서로 주어진다. 모든 핸들은 영어 소문자와 숫자로만 이루어져 있으며 길이는 20보다 짧거나 같다. 입력되는 핸들 중 완전히 같은 핸들은 없음이 보장된다.\n",
        "output_text": "현정이가 기억하고 있는 핸들 중 사전 순으로 I번째인 핸들을 한 줄에 출력한다.\n이 문제에서 정의하는 사전 순이란 숫자가 알파벳보다 먼저이며, 숫자는 작을 수일수록 먼저이고, 알파벳은 순서가 빠를수록 먼저이다. 또한 'abcd'와 'abc' 같이 어떤 한 문자열이 다른 문자열의 접두사가 될 때에는 길이가 더 짧은 쪽이 먼저이다.\n",
        "memory_median": 1996.0,
        "time_median": 0.0,
        "length_median": 331.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "283": {
        "problem_text": "버그 투성이 프로그램을 잘 만드는 백준이는 버그를 찾는 프로그램을 만들었다.\n이 프로그램은 프로그램의 소스 코드를 입력으로 받은 뒤, 버그를 발견하면 해당 부분을 주석처리해준다.\n하지만, 버그를 찾는 프로그램도 백준이가 작성했기 때문에 버그가 있다. 바로, 주석처리하는 대신에 그 부분을 BUG로 바꿔버린다.\n버그 찾는 프로그램이 처리한 결과가 주어졌을 때, BUG를 모두 없애는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 줄의 소스 코드로 이루어져 있다. 이 소스 코드는 백준이가 작성한 버그를 찾는 프로그램으로 이미 처리가 되어있다. 각 줄은 100글자 이내이고, 입력은 파일이 끝날 때 끝난다. 줄의 개수는 따로 제한을 두지 않는다.\n",
        "output_text": "입력으로 주어진 소스 코드의 BUG를 모두 제거한 뒤 출력한다. 출력하는 소스 코드에는 BUG가 있으면 안 된다. 즉, ABUBUGGB와 같은 경우는 AB가 되어야 한다.\n",
        "memory_median": 1992.0,
        "time_median": 0.0,
        "length_median": 429.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "284": {
        "problem_text": "There are English words that you want to translate them into pseudo-Latin. To change an English word into pseudo-Latin word, you simply change the end of the English word like the following table.\n\n\n\nEnglish\npseudo-Latin\n\n\n\n\n-a\n-as\n\n\n-i, -y\n-ios\n\n\n-l\n-les\n\n\n-n, -ne\n-anes\n\n\n-o\n-os\n\n\n-r\n-res\n\n\n-t\n-tas\n\n\n-u\n-us\n\n\n-v\n-ves\n\n\n-w\n-was\n\n\n\nIf a word is not ended as it stated in the table, put ‘-us’ at the end of the word. For example, a word “cup” is translated into “cupus” and a word “water” is translated into “wateres”.\nWrite a program that translates English words into pseudo-Latin words.\n",
        "input_text": "Your program is to read from standard input. The input starts with a line containing an integer, n (1 ≤ n ≤ 20), where n is the number of English words. In the following n lines, each line contains an English word. Words use only lowercase alphabet letters and each word contains at least 3 and at most 30 letters.\n",
        "output_text": "Your program is to write to standard output. For an English word, print exactly one pseudo-Latin word in a line.\n",
        "memory_median": 1992.0,
        "time_median": 0.0,
        "length_median": 1108.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "285": {
        "problem_text": "사파리 투어를 나선 건덕이는 얼룩말에 관심이 많았다. 특히 얼룩말의 몸통에 검은 줄이 많을수록 얼룩말이 아름답다고 생각했다.\n건덕이는 얼룩말들의 털 상태를 0과 1로 기록한다. 0은 털이 흰 부분을, 1은 털이 검은 부분을 의미한다.\n검은 줄의 개수는 연속하는 검은 부분의 개수이다. 예를 들어, 건덕이가 한 얼룩말의 털 상태를 01101110101로 기록했다면, 이 얼룩말은 $4$개의 검은 줄을 가지고 있다.\n건덕이는 모든 얼룩말에 대한 털 상태를 기록해 두었다. 건덕이가 생각하기에 가장 아름다운 얼룩말은 몇 개의 줄을 가졌고, 그런 얼룩말이 총 몇 마리가 있을까?\n",
        "input_text": "첫째 줄에 얼룩말의 개체수 $N$, 얼룩말의 몸통 길이를 나타내는 정수 $L$이 공백으로 구분되어 주어진다. $\\left( 1\\leq N,L\\leq 1\\, 000 \\right)$\n이어지는 $N$개의 줄에 건덕이가 기록한 길이 $L$의 얼룩말의 털 상태를 나타내는 문자열이 한 줄에 하나씩 주어진다. 문자열은 0과 1로만 이루어져 있다.\n",
        "output_text": "건덕이가 생각하는 가장 아름다운 얼룩말이 가지고 있는 검은 줄의 개수와 그런 얼룩말의 개체수를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 12.0,
        "length_median": 642.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "286": {
        "problem_text": "한국인의 식단에서 생선은 매우 중요한 단백질 공급원이다. 반면, 지구 온난화로 인한 바닷물의 온도 상승, 그리고 지금까지 마구잡이로 물고기를 잡은 결과로 점점 우리나라의 바다에서 물고기의 수가 줄어들고 있다. 정부에서는 이 문제를 심각하게 생각하여, 물고기를 잡을 수 있는 곳과 여기서 고기잡이 배가 사용할 수 있는 그물의 폭에 제한을 두었다. 물고기는 바다 표면 근처에 살기 때문에, 그물의 높이는 중요하지 않다. 따라서 그물은 길이가 l인 직선으로 생각할 수 있고, 물고기를 잡을 때, 그물은 한 변의 길이가 1 이상 정수인 직사각형 모양으로 치게 된다. 예를 들어, l = 10이라면, 칠 수 있는 그물의 모양은 1×4, 2×3, 3×2, 4×1과 같이 4가지 형태의 직사각형이 된다. \n고기를 잡을 수 있는 곳은 N×N 크기의 모눈종이 모양으로 되어 있다. 각 모눈에는 좌표가 주어지며, 가장 왼쪽 위 모눈이 (1,1)이고, 가장 오른쪽 아래 모눈이 (N,N)이다. 총 M 마리의 물고기가 서로 다른 모눈 위에 한 마리씩 살고 있으며, 물고기는 움직이지 않는다. 고기잡이 배는 한 모눈 위에 위치를 잡고 자신의 오른쪽과 아래쪽으로 그물을 친다. 일단 그물을 치면, 그물 안, 그리고 그물에 걸친 물고기들을 잡을 수 있다. 예를 들면, 다음 그림은 N = 7, l = 10 이고 M = 6 마리의 물고기가 (2,2), (2,4), (3,3), (5,6), (6,2), (7,4)에 살고 있을 때, (2,2)에 놓인 고기잡이 배가 2×3 모양으로 그물을 친 예를 보이고 있다. 이때 고기잡이 배는 총 3마리의 물고기를 잡을 수 있다. 고기를 잡을 수 있는 영역 밖으로 그물을 치는 경우는 없다.\n\n고기를 잡을 수 있는 영역, 물고기의 위치, 그물의 폭이 주어졌을 때 한 번의 그물치기로 잡을 수 있는 가장 많은 물고기의 마릿수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에는 모눈종이의 크기, 그물의 길이, 물고기의 수를 나타내는 세 개의 정수 N, l, M이 하나의 공백을 두고 주어진다. 단, 2 ≤ N ≤ 10,000, 4 ≤ l ≤ 100, 1 ≤ M ≤100 이다. l은 l ≤ 4N - 4을 만족하는 짝수이다. 두 번째 줄부터 이후 M 개의 줄에는 각 물고기의 좌표가 하나의 공백을 두고 주어진다. 물고기의 좌표 순서는 무작위로 주어진다.\n",
        "output_text": "첫 줄에 주어진 입력에서 잡을 수 있는 가장 많은 물고기의 마릿수를 하나의 정수로 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 72.0,
        "length_median": 927.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "287": {
        "problem_text": "집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.\n\n2 3 5\n2 5 3\n3 2 5\n3 5 2\n5 2 3\n5 3 2\n\n각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.\n{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.\n\nb e i n\nb e n i\nb i e n\nb i n e\nb n e i\nb n i e\ne b i n\ne b n i\ne i b n\ne i n b\ne n b i \ne n i b\ni b e n\ni b n e\ni e b n\ni e n b\ni n b e\ni n e b\nn b e i\nn b i e\nn e b i\nn e i b\nn i b e\nn i e b\n\n서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.\n",
        "output_text": "각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 \"No permutation\"을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 12.0,
        "length_median": 684.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "288": {
        "problem_text": "컴퓨터공학과 학생인 영재는 이번 학기에 알고리즘 수업을 수강한다.\n평소에 자신의 실력을 맹신한 영재는 시험 전날까지 공부를 하지 않았다.\n당연하게도 문제를 하나도 풀지 못하였지만 다행히도 문제가 5지 선다의 객관식 10문제였다.\n찍기에도 자신 있던 영재는 3개의 연속된 문제의 답은 같지 않게 한다는 자신의 비법을 이용하여 모든 문제를 찍었다.\n이때 영재의 점수가 5점 이상일 경우의 수를 구하여라.\n문제의 점수는 1문제당 1점씩이다.\n",
        "input_text": "시험의 정답이 첫 줄에 주어진다.\n",
        "output_text": "영재의 점수가 5점 이상일 경우의 수를 출력하여라.\n",
        "memory_median": 2020.0,
        "time_median": 56.0,
        "length_median": 695.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "289": {
        "problem_text": "2-SAT은 N개의 불리언 변수 \\(x_1, x_2, ..., x_n\\)가 있을 때, 2-CNF 식을 true로 만들기위해 \\(x_i\\)를 어떤 값으로 정해야하는지를 구하는 문제이다.\n2-CNF식은 \\( \\left( x \\lor y \\right) \\land \\left( \\lnot y \\lor z \\right) \\land \\left( x \\lor \\lnot z \\right) \\land \\left( z \\lor y \\right) \\) 와 같은 형태이다. 여기서 괄호로 묶인 식을 절(clause)라고 하는데, 절은 2개의 변수를 \\(\\lor\\)한 것으로 이루어져 있다. \\(\\lor\\)는 OR, \\(\\land\\)는 AND, \\(\\lnot\\)은 NOT을 나타낸다.\n변수의 개수 N과 절의 개수 M, 그리고 식 \\(f\\)가 주어졌을 때, 식 \\(f\\)를 true로 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.\n예를 들어, N = 3, M = 4이고, \\(f =  \\left( \\lnot x_1 \\lor x_2 \\right) \\land \\left( \\lnot x_2 \\lor x_3 \\right) \\land \\left( x_1 \\lor x_3 \\right) \\land \\left( x_3 \\lor x_2 \\right) \\) 인 경우에 \\(x_1\\)을 false, \\(x_2\\)을 false, \\(x_3\\)를 true로 정하면 식 \\(f\\)를 true로 만들 수 있다. 하지만, N = 1, M = 2이고, \\(f = \\left( x_1 \\lor x_1 \\right) \\land \\left( \\lnot x_1 \\lor \\lnot x_1 \\right) \\)인 경우에는 \\(x_1\\)에 어떤 값을 넣어도 식 f를 true로 만들 수 없다.\n",
        "input_text": "첫째 줄에 변수의 개수 N (1 ≤ N ≤ 20)과 절의 개수 M (1 ≤ M ≤ 100)이 주어진다. 둘째 줄부터 M개의 줄에는 절이 주어진다. 절은 두 정수 i와 j (1 ≤ |i|, |j| ≤ N)로 이루어져 있으며, i와 j가 양수인 경우에는 각각 \\(x_i\\), \\(x_j\\)를 나타내고, 음수인 경우에는 \\(\\lnot x_{-i}\\), \\(\\lnot x_{-j}\\)를 나타낸다.\n",
        "output_text": "첫째 줄에 식 \\(f\\)를 true로 만들 수 있으면 1을, 없으면 0을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1331.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "290": {
        "problem_text": "숫자 9개가 오름차순이나 내림차순으로 정렬되어 있을 때, 중앙값은 다섯 번째 숫자이다. 예를 들어, 1, 3, 4, 1, 2, 6, 8, 4, 10의 중앙값은 4이다. (1 ≤ 1 ≤ 2 ≤ 3 ≤ 4 ≤ 4 ≤ 6 ≤ 8 ≤ 10)\n이미지 I는 크기가 R × C인 2차원 픽셀이다. (3 ≤ R ≤ 40, 3 ≤ C ≤ 40) 각 픽셀은 어두운 정도 V를 나타낸다. (0 ≤ V ≤ 255)\n중앙 필터는 이미지에 있는 노이즈를 제거하는 필터이다. 필터의 크기는 3 × 3이고, 이미지의 중앙값을 찾으면서 잡음을 제거한다.\n예를 들어, 아래와 같은 6 × 5 이미지가 있다.\n\n필터링된 이미지의 크기는 4 × 3이고, 아래와 같다.\n\n가장 왼쪽 윗 행에 필터를 두고, 오른쪽으로 움직이면서 중앙값을 찾는다. 한 행을 모두 이동했으면, 다음 행으로 이동해 다시 중앙값을 찾는다. 아래와 같은 순서를 가진다.\n\n위의 그림에서 각각의 중앙값은 36, 36, 21이 된다. 이 값은 필터링된 이미지 J의 첫 행과 같다. \n이미지 I가 주어졌을 때, 필터링 된 이미지 J를 구하고, 값이 T보다 크거나 같은 픽셀의 수를 구하는 프로그램을 작성하시오.\n예를 들어, T = 40일 때, 위의 예에서 정답은 7이다. \n",
        "input_text": "첫째 줄에 이미지의 크기 R과 C가 주어진다. 그 다음 R개의 각 줄에는 C개의 픽셀 값이 주어진다. 마지막 줄에는 T값이 주어진다.\n",
        "output_text": "첫째 줄에 필터링 된 이미지 J의 각 픽셀 값 중에서 T보다 크거나 같은 것의 개수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 749.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "291": {
        "problem_text": "There are n cards, each with an integer on it where two or more cards can have the same integer. From these cards, we want to select two or three cards such that the product of numbers on the selected cards is maximum. For example, assume that there are 6 cards with numbers: 5, 10, -2, 3, 5, and 2. If we select three cards with numbers, 5, 10, and 5, then the product of the three numbers is 250, which is the maximum product. Let us consider another example of four cards with numbers: 10, 0, -5, 2. In this example, if we select two cards with numbers, 10 and 2, then the product of these two numbers is 20, which is the maximum product.\nGiven n numbers on cards, write a program to compute the maximum product of numbers on two or three cards.\n",
        "input_text": "Your program is to read from standard input. The input starts with a line containing an integer, n (3 ≤ n ≤ 10,000), where n is the number of cards. In the following line, n numbers on the cards are given. These numbers are integers between -1,000 and 1,000 inclusively.\n",
        "output_text": "Your program is to write to standard output. Print exactly one line which contains the maximum product.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 652.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "292": {
        "problem_text": "준석이는 영어 단어를 외우려고 한다. 사전에는 N가지 단어가 적혀 있다. 모든 단어는 소문자이다. 단어 안에 있는 모든 알파벳을 알 때, 그 단어를 완전히 안다고 한다.\n다음과 같은 쿼리들이 주어진다.\n\n1 x : 알파벳 x를 잊는다.\n2 x : 알파벳 x를 기억해 낸다.\n\n처음에 모든 알파벳을 기억하는 상태고, 모음은 완벽하게 외웠기 때문에 절대 잊지 않는다.\n각 쿼리마다 완전히 알고 있는 단어의 개수를 출력하여라.\n",
        "input_text": "첫 번째 줄에는 정수 N (1 ≤ N ≤ 104)과 M (1 ≤ M ≤ 5×104)이 주어진다.\n다음 N개의 줄에는 문자열이 하나씩 주어진다. 문자열의 길이는 103을 넘지 않는다.\n다음 M개의 줄에는 정수 o와 문자 x가 한 줄씩 주어진다. o는 1, 2중 하나이고, x는 알파벳 소문자이다.\no가 1이면 x를 잊는다는 뜻이고, o가 2면 x를 기억해낸다는 뜻이다. o가 1일 때는 x를 기억하고 있었음이 보장되고, o가 2일 때는 x를 잊고 있었음이 보장된다.\n",
        "output_text": "각 쿼리마다 정수 하나를 출력한다.\n",
        "memory_median": 2148.0,
        "time_median": 492.0,
        "length_median": 827.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "293": {
        "problem_text": "Farmer John has opened a swimming pool for his cows, figuring it will help them relax and produce more milk.\nTo ensure safety, he hires $N$ cows as lifeguards, each of which has a shift that covers some contiguous interval of time during the day. For simplicity, the pool is open from time $t=0$ until time $t=1000$ on a daily basis, so each shift can be described by two integers, giving the time at which a cow starts and ends her shift. For example, a lifeguard starting at time $t = 4$ and ending at time $t = 7$ covers three units of time (note that the endpoints are \"points\" in time).\nUnfortunately, Farmer John hired 1 more lifeguard than he has the funds to support. Given that he must fire exactly one lifeguard, what is the maximum amount of time that can still be covered by the shifts of the remaining lifeguards? An interval of time is covered if at least one lifeguard is present.\n",
        "input_text": "The first line of input contains $N$ ($1 \\leq N \\leq 100$). Each of the next $N$ lines describes a lifeguard in terms of two integers in the range $0 \\ldots 1000$, giving the starting and ending point of a lifeguard's shift. All such endpoints are distinct. Shifts of different lifeguards might overlap.\n",
        "output_text": "Please write a single number, giving the maximum amount of time that can still be covered if Farmer John fires 1 lifeguard.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 707.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "294": {
        "problem_text": "아름이는 친구들과 사과와 바나나를 많이 가지고 있지만, 과일을 좋아하지 않아서 자신의 분량을 남겨두지 않고 친구들에게 모두 나누어 준다. 아름이는 항상 공평하게 사과와 바나나를 나누어 주며, 절대 잘라서 주지 않는다.\n예를 들어, 사과 8개와 바나나 4개를 가지고 있다면, 공평하게 나누어 주는 방법은 다음과 같이 3가지 경우 밖에 없다.\n\n한 친구가 사과 8개와 바나나 4개를 모두 받는다.\n두 친구가 각각 사과 4개와 바나나 2개씩을 받는다.\n네 친구가 각각 사과 2개와 바나나 1개씩을 받는다.\n\n아름이가 나누어 줄 수 있는 모든 경우를 출력하는 함수를 작성하시오.\n",
        "input_text": "첫째 줄에 사과의 개수 a와 바나나의 개수 b가 주어진다. (1 ≤ a, b ≤ 1,000)\n",
        "output_text": "아름이가 나누어 줄 수 있는 경우를 모두 출력해야 하며, 각 경우마다 친구의 수, 사과 개수, 바나나 개수 차례로 한 줄에 각각 빈칸으로 구분하여 출력한다. 각 경우마다 중복없이 한 번만 출력되어야 하며, 경우의 순서는 친구의 수가 증가하는 순으로 한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 322.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "295": {
        "problem_text": "혹시 마지막으로 엠티를 간 것이 언제인가? 엠티를 안간지 꽤 오래됐다면 요즘 유행하는 인싸들의 가위바위보를 모를 것이다. 요즘 인싸들은 엠티에서 평범한 가위바위보를 시시하다는 이유로 더 이상 취급하지 않는다. 대신 가위불바위총번개악마용물공기보스펀지늑대나무사람뱀을 한다. 이 게임의 명칭이 다소 긴 관계로 문제 내에서는 전체 명칭을 적는 대신 이 게임의 또 다른 이름인 인싸 가위바위보로 부르겠다. 인싸 가위바위보는 평범한 가위바위보와 같이 각 손동작간의 상성이 정해져있다. \n\n인싸 가위바위보는 평범한 가위바위보보다 흥미진진하고 재밌지만 3명 이상이 경기를 할 때 누가 이기고 누가 졌는지를 빠르게 알기 힘들다는 단점이 있다. 그렇기에 3명 이상의 사람들 사이에서 인싸 가위바위보를 할 때는 모두가 동시에 경기를 진행하는 대신 일대일 경기를 여러 번 진행해 누가 우승했는지 판단한다. 3명이서 인싸 가위바위보를 할 때의 우승자를 정하기 위한 구체적인 방식은 아래와 같다. 편의상 참가자 3명을 A, B, C라고 하자.\n\nA, B, C는 게임 시작 전 우승을 위해 필요한 승수와 경기 진행 순서를 미리 합의한다. 경기 진행 순서가 A, B, C라고 가정하자.\n먼저 A와 B가 경기를 진행해 승자를 결정한다. 만약 두 사람이 같은 손동작을 내어 무승부가 발생할 경우 경기 진행 순서상 뒤인 사람이 이긴 것으로 간주한다. 즉 A와 B가 같은 손동작을 내면 B의 승리, A와 C가 같은 손동작을 내면 C의 승리, B와 C가 같은 손동작을 내면 C의 승리이다. \n이전 경기의 승자와 이전 경기에 참여하지 않은 사람이 경기를 진행해 승자를 결정한다.\n특정 사람이 미리 합의된 승수를 달성할 때 까지 3을 반복한다.\n합의된 승수를 최초로 달성한 사람이 우승한다.\n\n밑의 표는 침, 펄, 풍 세 사람이 인싸 가위바위보를 진행하는 예시이다. 우승을 위해 필요한 승수는 3승이고 침, 펄, 풍 순서로 경기를 진행한다.\n\n인싸 가위바위보 결과 풍이 제일 먼저 3승에 도달했으므로 우승자는 풍이다. 1라운드, 3라운드에서 두 사람이 같은 손동작을 냈을 때 경기 진행 순서상 뒤인 사람이 승리하는 것을 확인할 수 있다.\n컴퓨터공학과 새내기 지우는 첫 엠티에서 친구 경희, 민호와 인싸 가위바위보를 할 생각에 굉장히 신나있다. 지우는 경희와 민호의 행동 패턴을 빅데이터로 분석해 인싸 가위바위보를 하는 중 경희와 민호의 차례가 왔을 때 이들이 낼 손동작의 순서를 정확히 알고 있다. 그래서 마음만 먹으면 전승 우승이 가능하지만 경기를 흥미진진하게 이끌기 위해 인싸 가위바위보를 할 때 모든 손동작을 다르게 내고 싶어한다. 지우의 즐거운 대학생활을 위해 인싸 가위바위보의 상성표와 경희, 민호가 낼 손동작의 순서가 주어졌을 때 지우가 모든 손동작을 다르게 내어 우승할 수 있는지 판단하는 프로그램을 만들자. 경기 진행 순서는 지우, 경희, 민호 순으로 정해져있다.\n",
        "input_text": "첫째 줄에 인싸 가위바위보의 손동작 수를 나타내는 N(1 ≤ N ≤ 9)과 우승을 위해 필요한 승수 K(1 ≤ K ≤ 6)가 한 칸의 빈칸을 사이에 두고 주어진다.\n그 다음 N개의 줄에 대해 상성에 대한 정보 Ai,j가 주어진다. i+1번째 줄에는 N개의 정수 Ai,1, Ai,2, Ai,3, ..., Ai,N이 한 칸의 빈칸을 사이에 두고 주어진다. Ai,j가 2일 경우에는 i번 손동작이 j번 손동작을 이긴다는 의미이고, 1일 경우에는 비긴다는 의미이고, 0일 경우에는 진다는 의미이다. Ai,i = 1이고, i ≠ j일 때 Ai,j ≠ 1임이 보장된다. 또한 Ai,j가 2일 경우에는 Aj,i가 0이고, Ai,j가 0일 경우에는 Aj,i가 2임이 보장된다.\n그 다음 줄에는 경희가 앞으로 자신이 참여하는 20경기에서 낼 손동작의 순서가 한 칸의 빈칸을 사이에 두고 주어진다. 손동작의 번호는 1 이상 N 이하이다.\n그 다음 줄에는 민호가 앞으로 자신이 참여하는 20경기에서 낼 손동작의 순서가 한 칸의 빈칸을 사이에 두고 주어진다. 마찬가지로 손동작의 번호는 1 이상 N 이하이다.\n",
        "output_text": "첫째 줄에 지우, 경희, 민호 순으로 경기를 진행할 때 지우가 모든 손동작을 다르게 내어 우승할 수 있으면 1을, 그렇지 않으면 0을 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 28.0,
        "length_median": 1808.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "296": {
        "problem_text": "어제, 지민이는 몰래 리조트에 갔다가 입구에 걸려있는 복권 광고를 하나 보았다.\n“1부터 N까지의 수 중에 서로 다른 M개의 수를 골라보세요. 저희도 1부터 N까지의 수 중에 서로 다른 M개의 수를 고를건데, 적어도 K개의 수가 같으면 당첨입니다.!”\n지민이는 돌아오면서 자신이 복권에 당첨될 확률이 궁금해졌다.\n지민이가 복권에 당첨될 확률을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 세 정수 N, M, K가 주어진다.\n",
        "output_text": "첫째 줄에 지민이가 복권에 당첨될 확률을 출력한다. 절대/상대 오차는 10-9까지 허용한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 558.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "297": {
        "problem_text": "N(3≤N≤999, N은 홀수)명의 학생들이 원 모양으로 둘러앉아 있다. 각 학생들은 모두 몇 개의 사탕(≤100,000)을 가지고 있는데 그 개수는 사람마다 다를 수 있고, 사탕을 아예 가지고 있지 않을 수도 있다. 물론 사탕의 개수는 음이 아닌 정수이다.\n편의상 학생들에게 번호를 매기는데, 반시계 방향으로 1번 학생, 2번 학생, …, N번 학생으로 번호를 매겼다. 1번 학생 오른쪽엔 2번 학생, 2번 학생 오른쪽엔 3번 학생이 앉아 있는 것이고, 마지막 N번 학생 오른쪽엔 1번 학생이 앉아 있게 된다.\n우리는 인접한 두 학생이 가지고 있는 사탕의 수의 합을 안다. 즉 1번 학생과 2번 학생이 가지고 있는 사탕의 수의 합, 2번 학생과 3번 학생이 가지고 있는 사탕의 수의 합, …, N-1번 학생과 N번 학생이 가지고 있는 사탕의 수의 합, 마지막으로 N번 학생과 1번 학생의 가지고 있는 사탕의 수의 합을 안다. 이때, 각 학생이 가지고 있는 사탕의 수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N(3 ≤ N ≤ 999, N은 홀수)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 1번 학생과 2번 학생이 가지고 있는 사탕의 수의 합, 2번 학생과 3번 학생이 가지고 있는 사탕의 수의 합, …, N-1번 학생과 N번 학생이 가지고 있는 사탕의 수의 합, 마지막으로 N번 학생과 1번 학생의 가지고 있는 사탕의 수의 합이 순서대로 주어진다.\n",
        "output_text": "첫째 줄부터 N개의 줄에 걸쳐 1번 학생이 가지고 있는 사탕의 수, 2번 학생이 가지고 있는 사탕의 수, …, N번 학생이 가지고 있는 사탕의 수를 순서대로 출력한다. 출력하는 수는 음이 아닌 정수들이어야 하며, 항상 답이 존재하는 경우만이 입력으로 주어진다고 가정해도 좋다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 445.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "298": {
        "problem_text": "It's Halloween! Farmer John is taking the cows to a costume party, but unfortunately he only has one costume. The costume fits precisely two cows with a length of S (1 <= S <= 1,000,000). FJ has N cows (2 <= N <= 20,000) conveniently numbered 1..N; cow i has length L_i (1 <= L_i <= 1,000,000). Two cows can fit into the costume if the sum of their lengths is no greater than the length of the costume. FJ wants to know how many pairs of two distinct cows will fit into the costume.\n",
        "input_text": "\nLine 1: Two space-separated integers: N and S\nLines 2..N+1: Line i+1 contains a single integer: L_i\n\n",
        "output_text": "\nLine 1: A single integer representing the number of pairs of cows FJ can choose. Note that the order of the two cows does not matter.\n\n",
        "memory_median": 2100.0,
        "time_median": 96.0,
        "length_median": 448.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "299": {
        "problem_text": "Given an integer n, compute the number of divisors of n.\nA divisor is an integer, d (1 <= d <= n) that evenly divides n.\nExample: If n=10, divisors are: 1, 2, 5 and 10. So the result would be 4.\nExample: If n=104717, divisors are 1 and 104717. This is a prime number so the number of divisors is 2.\n",
        "input_text": "The first line contains an integer C (1 <= C <= 10) with the amount of numbers you need to process. The next C lines will contain an integer n (1 <= n < 10000) each. You have to compute the number of divisors of these values.\n",
        "output_text": "For each integer n, print a line with the number n itself, a space and the number of divisors.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 339.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "300": {
        "problem_text": "Farmer John's cows have been holding a daily online gathering on the \"mooZ\" video meeting platform. For fun, they have invented a simple number game to play during the meeting to keep themselves entertained.\nElsie has three positive integers $A$, $B$, and $C$ ($A\\le B\\le C$). These integers are supposed to be secret, so she will not directly reveal them to her sister Bessie. Instead, she gives Bessie seven (not necessarily distinct) integers in the range $1 \\ldots 10^9$, claiming that they are $A$, $B$, $C$, $A+B$, $B+C$, $C+A$, and $A+B+C$ in some order.\nGiven a list of these seven numbers, please help Bessie determine $A$, $B$, and $C$. It can be shown that the answer is unique.\n",
        "input_text": "The only line of input consists of seven space-separated integers.\n",
        "output_text": "Print $A$, $B$, and $C$ separated by spaces.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 407.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "301": {
        "problem_text": "네모는 뿌××× 게임에 깊은 감명을 받아, 직사각형 모양의 격자판과 “넴모”라는 수수께끼의 생물을 이용하는 “넴모넴모”라는 게임을 만들었다. 이 게임의 규칙은 아주 간단하다. 격자판의 비어 있는 칸을 임의로 골라 “넴모”를 하나 올려놓거나, “넴모”가 올라간 칸 네 개가 2 × 2 사각형을 이루는 부분을 찾아 그 위에 있는 “넴모”들을 모두 없애는 것을 질릴 때까지 반복하면 된다.\n\n하지만 안타깝게도 게임은 정말 재미가 없었고, 네모는 아주 빨리 질려 버리고 말았다. 실망한 네모는 게임을 적당히 플레이하다가, “넴모”를 없애고 싶은데 격자판 위에 없앨 수 있는 “넴모”가 없으면 게임을 그만두기로 했다. 네모가 게임을 그만두었을 때 나올 수 있는 “넴모”의 배치의 가짓수를 구하여라.\n",
        "input_text": "첫 번째 줄에 격자판의 행의 개수 N, 열의 개수 M(1 ≤ N, M ≤ 25, 1 ≤ N × M ≤ 25)이 공백으로 구분되어 주어진다.\n",
        "output_text": "첫 번째 줄에 주어진 격자판에서 나올 수 있는, “넴모”들이 올라간 칸이 2 × 2 사각형을 이루지 않는 모든 배치의 가짓수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 204.0,
        "length_median": 695.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "302": {
        "problem_text": "치르보기 빌딩은 $1$층부터 $N$층까지 이용이 가능한 엘리베이터가 있다. 엘리베이터의 층수를 보여주는 디스플레이에는 $K$ 자리의 수가 보인다. 수는 $0$으로 시작할 수도 있다. $0$부터 $9$까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다. 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.\n\n예를 들어 $K=4$인 경우에 $1680$층과 $501$층은 아래와 같이 보인다.\n \n빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 $1$개, 최대 $P$개를 반전시킬 계획을 세우고 있다. 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다. 예를 들어 숫자 $1$을 $2$로 바꾸려면 총 5개의 LED를 반전시켜야 한다. 또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 $1$ 이상 $N$ 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다. 치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다. 현재 엘리베이터가 실제로는 $X$층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.\n",
        "input_text": "$N, K, P, X$ 가 공백으로 구분되어 첫째 줄에 주어진다.\n",
        "output_text": "호석 빌런이 엘리베이터 LED를 올바르게 반전시킬 수 있는 경우의 수를 계산해보자.\n",
        "memory_median": 2020.0,
        "time_median": 56.0,
        "length_median": 1230.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "303": {
        "problem_text": "Farmer John was performing his nightly bedtime reading duties for Bessie. \"Oh, this gives me a headache,\" moaned Bessie. \"But it's just simple number theory,\" replied FJ. \"Let's go over it again. The sigma function of a number is just the sum of the divisors of the number. So, for a number like 12, the divisors are 1, 2, 3, 4, 6, and 12. Summing them we get 28.\" \"That's all there is to it?\" asked Bessie. \"Yep.\" replied FJ. \"Perhaps someone will write a program to calculate the sigma function of an integer I (1 <= I <= 1,000,000).\"\n",
        "input_text": "A single integer I.\n",
        "output_text": "Output a line containing the sum of all of I's divisors.\n",
        "memory_median": 1988.0,
        "time_median": 4.0,
        "length_median": 219.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "304": {
        "problem_text": "2차원 평면에 N개의 점이 주어져 있다. 이 중에서 세 점을 골랐을 때, 직각삼각형이 몇 개나 있는지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 점의 개수 N(3 ≤ N ≤ 1,500)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 점의 x좌표와 y좌표가 빈 칸을 사이에 두고 주어진다. 좌표값은 절댓값이 1,000,000,000을 넘지 않는 정수이며, 주어지는 모든 점의 좌표는 다르다.\n",
        "output_text": "첫째 줄에 직각삼각형의 개수를 출력한다.\n",
        "memory_median": 2052.0,
        "time_median": 1194.0,
        "length_median": 1014.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "305": {
        "problem_text": "볼록 다각형이 있고, 여기서 3개의 연속된 점을 선택해서 삼각형을 만든다. 그 다음, 만든 삼각형을 다각형에서 제외한다. 원래 다각형이 N개의 점이 있었다면, 이제 N-1개의 점으로 구성된 볼록 다각형이 된다. 위의 과정은 남은 다각형이 삼각형이 될 때까지 반복한다.\n볼록 다각형의 점이 시계 방향순으로 주어진다. 마지막에 남은 삼각형은 여러 가지가 있을 수 있다. 이때, 가능한 넓이의 최댓값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 볼록 다각형 점의 수 N (3 ≤ N ≤ 35)이 주어진다. 둘째 줄부터 N개의 줄에는 볼록 다각형을 이루고 있는 점이 시계 방향 순서로 주어진다. 좌표는 10,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 문제의 정답을 출력한다. 절대/상대 오차는 10-9까지 허용한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 738.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "306": {
        "problem_text": "로마의 장군 카이사르는 로마군의 작전을 적이 모르게 하기 위하여 암호를 사용했다. 카이사르는 다음과 같이 문장에 있는 모든 알파벳 글자를 몇 칸 뒤의 알파벳으로 바꾸는 방식으로 암호를 만들었다. 아래 표는 모든 글자를 17칸 뒤의 알파벳으로 바꿨을 때 각 글자가 어떤 알파벳으로 바뀌는지 나타낸 표이다.\n\n이 방법에 따라 ‘Baekjoon Online Judge’를 암호화하면 ‘Srvbaffe Feczev Aluxv’가 된다.\n당신은 페르시아 군대의 장군으로서 카이사르의 암호를 해독해야 한다. 당신은 카이사르가 어떤 방법으로 문장을 암호화하는지는 알고 있지만 카이사르가 몇 칸 뒤의 알파벳으로 바꾸는지는 모른다. 다행히, 당신의 부하가 로마어 사전을 가져와서 이를 통해 카이사르의 암호를 해독할 수 있을 것으로 보인다. 보통 전령에는 보편적인 단어가 나오기 때문에 사전에 나오는 단어가 반드시 있을 것이다. 따라서 암호를 해독한 후, 해독한 문장에서 사전에 나오는 단어가 반드시 하나 이상 등장해야 한다.\n카이사르의 암호와 사전의 정보가 주어졌을 때, 암호를 해독하는 프로그램을 작성하여라.\n",
        "input_text": "첫 번째 줄에 암호문이 주어진다. 암호문은 소문자로만 이루어진 길이 100 이하의 문자열이다.\n두 번째 줄에는 사전에 있는 단어의 수 N이 주어진다. (1 ≤ N ≤ 20)\n세 번째 줄부터 N개의 줄에는 사전에 있는 단어가 주어진다. 모든 단어는 소문자로만 이루어진 길이 20 이하의 문자열이다.\n",
        "output_text": "암호문을 해독하여 나온 원문을 출력한다. 모든 데이터에 대해서 답이 한 가지인 경우만 들어온다고 가정한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 716.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "307": {
        "problem_text": "다솜이는 타임머신을 타고 8364년으로 갔다. 다행히 지구는 평화롭다.\n다솜이는 2008년으로 돌아가기 전에 시계를 샀다. 다솜이는 시계를 볼 줄 모르기 때문에, 디지털 시계를 샀다. 디지털 시계는 HH:MM:SS와 같은 모양으로 시간을 나타내 준다. 그리고 앞에서부터 차례대로 HH는 시, MM은 분, SS는 초를 나타낸다.\n다솜이는 8364년에는 2008년과 같은 방법으로 시간을 나타내는지 모른다. 2008년엔 시:분:초를 나타내는지만, 8364년엔 분:시:초로 나타낼지도 모른다.\n다행히 시는 01부터 12, 분은 00부터 59, 초는 00부터 59를 나타낸다.\n다솜이의 시계에 쓰여 있는 숫자가 주어졌을 때, 이 시간을 읽을 수 있는 가능한 방법의 수를 출력하는 프로그램을 작성하시오. 나타내는 시간이 같더라도, 시, 분, 초를 읽을 수 있는 위치가 다르면 다른 방법으로 센다. 또한, 방법의 수가 0일 수도 있다.\n예를 들어, 21:23:01 은 21분 23초 01시 로 읽을 수도 있지만, 21초 23분 01시로 읽을 수도 있다.\n",
        "input_text": "첫째 줄에 시간이 주어진다. 시간은 DD:DD:DD와 같은 꼴로 주어진다. 항상 8자리(:도 포함)로만 들어오며, D는 0-9 사이의 숫자이다.\n",
        "output_text": "첫째 줄에 시간을 읽을 수 있는 가능한 방법의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 600.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "308": {
        "problem_text": "게임 캐릭터의 능력치를 한 눈에 보기 좋게 나타내는 방법으로 방사형 그래프가 있다. 캐릭터는 8개의 능력치를 갖고 있고 각 능력치를 $a_1, a_2, \\cdots, a_8$이라고 하면, 그래프는 팔각형 형태이고 $k$번째 꼭짓점은 원점을 기준으로 $45\\times k$도 방향으로 $a_k$만큼 떨어져 있다.\n\n방사형 그래프를 사용하면 능력치가 얼마나 고르게 분포되어 있는지 쉽게 알 수 있다. 만약 모든 능력치가 동일하다면 정다각형 형태가 되고, 한 능력치가 다른 능력치에 비해 현저히 낮으면 오목 다각형이 된다. 많은 사람들은 방사형 그래프를 볼록 다각형, 즉 모든 내각이 $180°$ 이하인 다각형으로 만들어 자신의 약점을 없애기 위해 노력한다.\n시루는 자신의 그래프를 볼록 다각형으로 바꾸고 싶지만, 능력치를 올리는 것은 매우 귀찮기 때문에 한 가지 꼼수를 생각해냈다. 바로 능력치를 나열하는 순서를 바꾸는 것이다. 예를 들어, $\\lbrace 6,7,7,8,9,10,11,13 \\rbrace$ 순서대로 나열하면 오목 다각형이 되지만, 순서를 바꿔 $\\lbrace 7,6,7,8,9,10,11,13 \\rbrace$ 순서대로 나열하면 볼록 다각형이 된다.\n\n능력치를 나열하는 순서에 따라 오목 다각형이 될 수도, 볼록 다각형이 될 수도 있기 때문에, 시루는 능력치를 잘 배열해서 볼록 다각형이 되는 경우의 수가 궁금해졌다. 볼록 다각형을 만드는 경우의 수를 구해보자.\n",
        "input_text": "첫째 줄에 8개의 능력치를 나타내는 정수 $a_1, a_2, \\cdots , a_8$가 공백으로 구분되어 주어진다. ($1 \\leq a_i \\leq 10^4$)\n",
        "output_text": "8개의 능력치를 잘 배열해서 방사형 그래프를 볼록 다각형으로 만드는 경우의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 1033.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "309": {
        "problem_text": "창영이가 드디어 취직을 했다!! 그가 30세까지 취직을 안하던 이유는 바로 마음에 다니는 직장을 찾지 못해서였다. 이번에 창영이가 취직한 곳은 사탕 공장이다. 사탕 공장에 다니면 사탕 처럼 달콤한 직장생활을 할 줄 알았지만, 8시간동안 사탕 품질을 검사해야 하는 작업은 너무나 지루했다.\n사탕의 품질은 다음과 같이 검사한다. 가장 먼저 사탕으로 가득 찬 박스를 연다. 그 다음 사탕의 개수와 사탕이 없는 곳의 개수를 센다.\n지루함을 견디지 못한 창영이는 결국 품질을 검사하는 프로그램을 작성하기로 했다.\nr행 c열 행렬이 주어진다. 이 행렬은 박스를 위에서 바라본 것이다. 행렬에는 다음과 같은 문자만 있다.\n\n\".\": 빈 곳\n\"o\": 사탕의 먹을 수 있는 부분\n\"<>v^\": 캔디 껍질\n\n사탕은 오직 2가지 모습만 있다.\n\n\n\r\n>o<\r\n\n\n\n\r\nv\r\no\r\n^\n\n\n위와 같은 연속된 3개의 문자만 사탕이다.\n사탕은 >o.와 같이 사탕의 일부만 존재할 수 있지만, 이 것은 사탕으로 세지 않는다.\nr행 c열 행렬이 주어졌을 때, 사탕의 개수를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 t가 주어진다. 각 테스트 케이스는 빈 줄로 구분된다.\n각 테스트 케이스의 첫째 줄에는 r과 c 가 주어진다. (1 ≤ r,c ≤ 400) 그 다음 r개의 줄에는 행렬의 각 행이 순서대로 주어진다. 행렬의 각 행은 c개의 문자이며, \".o<>v^\"만 포함하고 있다. (각각의 아스키 값은 46, 111, 60, 62, 118, 94이다)\n",
        "output_text": "각각의 테스트 케이스에 대해 한 줄에 하나의 정수만 출력한다. 이 값은 박스에 들어있는 사탕의 개수이다.\n",
        "memory_median": 2162.0,
        "time_median": 12.0,
        "length_median": 739.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "310": {
        "problem_text": "2-SAT은 N개의 불리언 변수 \\(x_1, x_2, ..., x_n\\)가 있을 때, 2-CNF 식을 true로 만들기위해 \\(x_i\\)를 어떤 값으로 정해야하는지를 구하는 문제이다.\n2-CNF식은 \\( \\left( x \\lor y \\right) \\land \\left( \\lnot y \\lor z \\right) \\land \\left( x \\lor \\lnot z \\right) \\land \\left( z \\lor y \\right) \\) 와 같은 형태이다. 여기서 괄호로 묶인 식을 절(clause)라고 하는데, 절은 2개의 변수를 \\(\\lor\\)한 것으로 이루어져 있다. \\(\\lor\\)는 OR, \\(\\land\\)는 AND, \\(\\lnot\\)은 NOT을 나타낸다.\n변수의 개수 N과 절의 개수 M, 그리고 식 \\(f\\)가 주어졌을 때, 식 \\(f\\)를 true로 만들 수 있는지 없는지를 구하는 프로그램을 작성하시오.\n예를 들어, N = 3, M = 4이고, \\(f =  \\left( \\lnot x_1 \\lor x_2 \\right) \\land \\left( \\lnot x_2 \\lor x_3 \\right) \\land \\left( x_1 \\lor x_3 \\right) \\land \\left( x_3 \\lor x_2 \\right) \\) 인 경우에 \\(x_1\\)을 false, \\(x_2\\)을 false, \\(x_3\\)를 true로 정하면 식 \\(f\\)를 true로 만들 수 있다. 하지만, N = 1, M = 2이고, \\(f = \\left( x_1 \\lor x_1 \\right) \\land \\left( \\lnot x_1 \\lor \\lnot x_1 \\right) \\)인 경우에는 \\(x_1\\)에 어떤 값을 넣어도 식 f를 true로 만들 수 없다.\n",
        "input_text": "첫째 줄에 변수의 개수 N (1 ≤ N ≤ 20)과 절의 개수 M (1 ≤ M ≤ 100)이 주어진다. 둘째 줄부터 M개의 줄에는 절이 주어진다. 절은 두 정수 i와 j (1 ≤ |i|, |j| ≤ N)로 이루어져 있으며, i와 j가 양수인 경우에는 각각 \\(x_i\\), \\(x_j\\)를 나타내고, 음수인 경우에는 \\(\\lnot x_{-i}\\), \\(\\lnot x_{-j}\\)를 나타낸다.\n",
        "output_text": "첫째 줄에 식 \\(f\\)를 true로 만들 수 있으면 1을, 없으면 0을 출력한다.\n\\(f\\)를 true로 만들 수 있는 경우에는 둘째 줄에 식 \\(f\\)를 true로 만드는 \\(x_i\\)의 값을 \\(x_1\\)부터 순서대로 출력한다. true는 1, false는 0으로 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1609.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "311": {
        "problem_text": "영식이는 민식이와 함게 고속버스를 타고 캠프를 가야 하지만, 민식이는 영식이를 깨우지 않고 혼자 버스를 타고 캠프에 가버렸다.\n영식이는 혼자 고속버스터미널까지 가서 캠프에 오려고 한다. 터미널에는 캠프 장소까지 운행하는 N가지의 버스가 있다. 각각의 버스는 시작 시각, 간격, 대수의 정보를 가지고 있다. 예를 들어, 어떤 버스의 시작 시각이 특점 시점을 기준으로 10분 후이고, 간격은 10분이고, 대수가 5대이면, 이 버스는 10분, 20분, 30분, 40분, 50분에 한 대씩 출발한다.\n영식이는 버스터미널에 T분에 도착했다. 영식이가 버스를 타려면 최소 몇 분을 더 기다려야 하는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 버스의 개수 N과 영식이가 버스터미널에 도착하는 시간 T가 주어진다. 둘째 줄부터 총 N개의 줄에 각 버스의 시작 시각 Si, 간격 Ii, 대수 Ci가 공백을 사이에 두고 주어진다.\n",
        "output_text": "첫째 줄에 영식이가 기다려야 하는 시간을 출력한다. 영식이가 도착하는 동시에 버스가 출발하면 정답은 0이다. 만약 버스가 없어서 캠프에 갈 수 없으면 -1을 출력한다. 정답은 231보다 작다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 591.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "312": {
        "problem_text": "양의 정수는 많아야 4개의 제곱수로 표현할 수 있다고 한다. 이 이론을 라그랑주의 네 제곱수 정리라고 한다. 이 정리는 조제프루이 라그랑주가 1770년에 증명했다.\n우리는 이 이론을 증명하거나 새로운 이론을 발견할 필요는 없고, n이 주어졌을 때 4개 이하의 양의 제곱수의 합으로 n을 만들 수 있는 경우의 수를 구하려고 한다. 경우의 수를 구할 때 제곱수의 순서가 바뀌는 경우는 같은 경우로 본다. 따라서 32 + 42 과 42 + 32는 같은 경우이다.\nN이 25일 때 4개 이하의 제곱수의 합으로 표현 할 수 있는 경우는 12 + 22 + 22 + 42, 32 + 42, 52 이렇게 3가지이다.\n",
        "input_text": "입력은 최대 255줄이다. 각 줄에는 215보다 작은 양의 정수가 하나씩 주어진다. 마지막 줄에는 0이 하나 있고, 입력 데이터가 아니다.\n",
        "output_text": "각 테스트 케이스에 대해서 입력으로 주어진 n을 많아야 4개의 제곱수로 나타내는 경우의 수를 출력한다.\n",
        "memory_median": 2148.0,
        "time_median": 96.0,
        "length_median": 674.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "313": {
        "problem_text": "$2$차원 평면의 KOI 마을에 $N$개의 집이 있다. 각 $i$번째 집의 위치는 $(X_i , Y_i)$이다.\n$i$번째 집과 $j$번째 집 사이의 거리는 $|X_i - X_j | + |Y_i - Y_j |$이다. 즉, 두 집 사이의 거리는 $X$의 차이와 $Y$의 차이의 합이다. 예를 들어, $(1, 6)$에 위치한 집과 $(2, 4)$에 위치한 집은 $(2 - 1) + (6 - 4)$인 $3$만큼 떨어져 있다.\n\nKOI 마을은 재난 발생 시 주민들이 안전하게 대피할 수 있도록 $K$개의 집에 대피소를 설치할 계획이다. 모 든 주민의 안전을 고려하여, 집에서 가장 가까운 대피소로 이동할 때 가장 긴 거리가 최소가 되도록 대피소를 설치할 $K$개의 집을 선택하고, 그때 대피소와 가장 멀리 떨어진 집과의 거리를 구하려고 한다.\n아래는 $5$개의 집이 각각 $(1, 5)$, $(3, 0)$, $(3, 3)$, $(6, 12)$, $(8, 9)$에 위치한 마을의 예이다.\n\n이 마을에 $2$개의 대피소를 설치하려고 한다. 만약 $(3, 0)$과 $(1, 5)$에 위치한 집에 대피소를 설치한다면 설치하지 않은 나머지 세 집에서 가까운 대피소까지의 거리가 각각 $3$, $11$, $12$이고, 이 중 가장 먼 거리는 $12$이다.\n\n하지만 $(3, 3)$와 $(6, 12)$에 위치한 집에 대피소를 설치하면 가장 가까운 대피소와 가장 멀리 떨어져 있는 집은 $(8, 9)$에 위치한 집으로, $(6, 12)$와 $5$만큼 떨어져 있다. 대피소를 어떻게 설치해도 최대 거리가 $5$보다 작아지는 경우가 없으므로 $5$가 구하고자 하는 거리가 된다.\n\nKOI 마을의 집들의 위치와 설치할 대피소의 개수가 주어질 때, 대피소를 설치하는 모든 방법 중 가장 가까운 대피소와 집 사이의 거리 중 가장 큰 값이 가장 작을 때의 거리를 구해라.\n",
        "input_text": "첫 번째 줄에 $N$과 $K$가 공백을 사이에 두고 주어진다.\n다음 $N$개의 줄에는 집의 위치가 주어지는데, 이 중 $i$ ($1 ≤ i ≤ N$)번째 줄에는 $X_i$와 $Y_i$가 공백을 사이에 두고 주어진다.\n",
        "output_text": "첫 번째 줄에 답을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 8.0,
        "length_median": 1176.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "314": {
        "problem_text": "$N$개의 카드가 놓여있다. 편의상 가장 왼쪽에 있는 카드를 $1$번 카드, 그 다음에 있는 카드를 $2$번 카드 $\\dots$, 가장 오른쪽에 있는 카드가 $N$번 카드라고 하자.\n$N$개의 카드에는 각각 정수가 하나씩 적혀있다. $i$번 카드에 적혀있는 수를 $x_i$라고 하자.\n$N$개의 카드 중 일부에 적혀있는 수들을 적절히 바꾸어서, 왼쪽에서 오른쪽으로 갈수록 카드에 적혀있는 수들이 일정하게 증가하거나, 감소하거나, 또는 모든 수들이 같도록 하고 싶다.\n카드에 적혀있는 수들을 바꿀 때는 정수 값으로만 바꿀 수 있으며, 바꾸는 횟수를 최소화해야 한다.\n예를 들어, 아래의 그림과 같이 카드들이 주어졌다고 하자.\n\n이 경우 $3$번 카드에 적혀있는 수를 $3$으로 바꾸면 아래와 같이 $1$씩 증가하도록 할 수 있고, 적혀있는 수를 바꾼 카드의 수는 $1$개이다.\n\n다음과 같이 모든 카드에 적혀있는 수를 $2$가 되도록 할 수도 있다. 이때, 적혀있는 수를 바꾼 카드의 수는 $2$개이다.\n\n가장 왼쪽에 있는 카드부터 가장 오른쪽에 있는 카드까지 각 카드에 적혀있는 수들이 순서대로 주어질 때, 조건을 만족하도록 하려면 바꿔야 할 카드 수의 최솟값을 구하여라.\n",
        "input_text": "첫 번째 줄에 카드의 수 $N$이 주어진다.\n두 번째 줄에는 각 카드에 적힌 수 $x_i$가 공백을 사이에 두고 순서대로 주어진다.\n",
        "output_text": "첫 번째 줄에 답을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 52.0,
        "length_median": 717.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "315": {
        "problem_text": "In St Petersburg phone numbers are formatted as “XXX–XX–XX”, where the first three digits represent index of the Automated Telephone Exchange (ATE). Each ATE has exactly 10 000 unique phone numbers.\nPeter has just bought a new flat and now he wants to install a telephone line. He thinks that a phone number is lucky if the arithmetic expression represented by that phone number is equal to zero. For example, the phone number 102–40–62 is lucky (102 − 40 − 62 = 0), and the number 157–10–47 is not lucky (157 − 10 − 47 = 100 ≠ 0).\nPeter knows the index of the ATE that serves his house. To get an idea of his chances to get a lucky number he wants to know how many lucky numbers his ATE has.\n",
        "input_text": "The input file contains a single integer number n — the index of Peter’s ATE (100 ≤ n ≤ 999).\n",
        "output_text": "Output a single integer number — the number of lucky phone numbers Peter’s ATE has.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 270.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "316": {
        "problem_text": "지민이는 대학교에서 \"잉여역수 구하기\"라는 강의를 듣고 있는데, 지민이는 정수론을 싫어해서 수업 시간에 그냥 졸다 나왔다. 그래서 혁주에게 \"오늘 숙제 뭐야?\"라고 물었더니, 혁주가 \"서로소인 두 자연수 a와 m의 값이 주어지면 a의 법 m에 대한 잉여역수 a*를 구하는 거야.\"라고 말했다. 지민이는 수업을 듣지 않아서 잉여역수의 정의를 모른다. 지민이의 숙제를 우리가 대신해 주자.\n",
        "input_text": "첫째 줄에 서로소인 두 자연수 a와 m이 사이에 공백을 두고 주어진다. (2 ≤ a, m ≤ 10,000)\n",
        "output_text": "첫째 줄에 a의 법 m에 대한 잉여역수 a*를 출력한다. 단, 잉여역수는 무한히 많기 때문에 그 중 자연수이며, 최소인 값을 출력하도록 한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 224.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "317": {
        "problem_text": "크기가 N인 수열 A = [A1, A2, ..., AN]이 있을 때, 모든 1 ≤ i < N에 대해서, Ai+1-Ai가 모두 일치하면 등차수열이라고 한다. 예를 들어, [3], [6, 6, 6], [2, 8, 14, 20], [6, 4, 2]는 등차수열이고, [4, 5, 4], [6, 3, 1]은 등차수열이 아니다.\n수열 B = [B1, B2, ..., BN]을 등차수열로 변환하려고 한다. 각각의 수에는 연산을 최대 한 번 적용할 수 있다. 연산은 두 가지가 있는데, 1을 더하거나 1을 빼는 것이다. 수열 B를 등차수열로 변환하기 위해 필요한 연산 횟수의 최솟값을 구해보자.\n",
        "input_text": "첫째 줄에 수열 B의 크기 N(1 ≤ N ≤ 105)이 주어진다. 둘째 줄에는 B1, B2, ..., BN(1 ≤ Bi ≤ 109)이 주어진다.\n",
        "output_text": "수열 B를 등차수열로 변화시키기 위한 연산 횟수의 최솟값을 출력한다. 등차수열로 변환시킬 수 없다면 -1을 출력한다.\n",
        "memory_median": 2412.0,
        "time_median": 20.0,
        "length_median": 1061.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "318": {
        "problem_text": "오늘은 애플의 아이폰 9S가 출시되는 날이다. N(1 ≤ N ≤ 1000)명의 사람들은 새 아이폰을 누구보다 먼저 구매하기 위해서 애플 스토어 앞에 한 줄로 서있다. 아이폰 9S는 구매자가 용량을 마음대로 정할 수 있다. 즉, 지금까지 아이폰은 16/32/64GB와 같이 용량의 크기가 미리 정해져 있었다. 하지만, 9S는 자신이 원하는 용량의 크기 B(i)를 점원에게 말하면, 정확하게 그 용량을 가진 아이폰 9S를 그 자리에서 만들어 구매하는 방식이다.\n애플 스토어의 점원 상근이는 같은 용량을 원하는 사람들이 연속되어 있으면, 더 보기 좋을 것이라고 생각한다. 따라서, 특정 사람을 고르고, 그 사람이 원하는 용량을 원하는 사람을 줄에서 모두 빼버리려고 한다.\n어떤 용량을 원하는 사람을 줄에서 빼 버리면, 같은 용량을 원하는 사람들이 연속되어 있는 구간의 길이중 가장 긴 값이 최대가 되는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N이 주어진다. 둘째 줄부터 N개 줄에는 줄을 서 있는 순서대로 각 사람이 원하는 용량 B(i)가 주어진다. B(i)는 0보다 크거나 같고, 1,000,000보다 작거나 같은 정수이다. 항상 두 개 이상의 서로 다른 B(i)가 존재한다.\n",
        "output_text": "상근이가 만들 수 있는 가장 길이가 긴 같은 용량을 원하는 사람의 연속 구간의 길이를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 718.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "319": {
        "problem_text": "연세대학교 수강신청 기간이 시작되었다. 많은 친구들은 비어 있는 시간에 어떤 과목을 추가로 신청할 수 있는지를 궁금해 한다.\n이 친구들이 비어 있는 시간에 추가로 신청할 수 있는 과목의 후보 개수를 구해보자.\n후보 개수를 세는 것이므로 현재 내 시간표에서 신청할 수 있는 과목끼리 시간이 겹치더라도 모두 세어야 한다.\n즉, 월요일 1, 2, 3, 4, 5교시 시간이 비어 있고 한 과목의 시간이 월요일 1, 2, 3, 4교시이고 나머지 한 과목의 시간이 월요일 2, 3, 4, 5교시라면 2과목 모두 후보가 될 수 있다.\n",
        "input_text": "연세대학교의 총 과목의 수 N (3 ≤ N ≤ 1000)이 주어진다.\nN줄에 걸쳐서 각 과목의 수업시간의 수 k (4 ≤ k ≤ 50)가 주어지고 그 옆에 k개의 숫자 ti (1 ≤ ti ≤ 50)가 공백으로 구분되어 주어진다.\nti는 이 과목의 수업이 진행되는 교시를 의미하며 1 ~ 50의 값을 가진다.\n(월요일 1~10교시: 1~10, 화요일 1~10교시: 11~20, …)\n다음 줄에 학생수 M (1 ≤ M ≤ 10000) 이 주어진다.\nM줄에 걸쳐서 각 학생들의 비어 있는 교시 개수 p (0 ≤ p ≤ 50)가 주어지고 그 옆에 p개의 숫자 qi (1 ≤ qi ≤ 50)가 공백으로 구분되어 주어진다.\nEx) 알고리즘의 수업시간이 화요일 2, 3교시, 수요일 4, 5교시라면 다음과 같이 입력이 주어진다.\n\r\n4 12 13 24 25\n",
        "output_text": "M줄에 걸쳐서 각 학생들의 들을 수 있는 과목 개수를 출력한다.\n",
        "memory_median": 2064.0,
        "time_median": 12.0,
        "length_median": 769.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "320": {
        "problem_text": "오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 만들어 지는 트리를 너비 우선 탐색 트리라고 하자. 너비 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n너비 우선 탐색 의사 코드는 다음과 같다. \n\r\nbfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    for each v ∈ V - {R}\r\n        visited[v] <- NO;\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.\r\n    while (Q ≠ ∅) {\r\n        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.\r\n        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합\r\n            if (visited[v] = NO) then {\r\n                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.\r\n                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.\r\n            }\r\n    }\r\n}\n",
        "input_text": "첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.\n다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.\n",
        "output_text": "첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.\n",
        "memory_median": 8840.0,
        "time_median": 92.0,
        "length_median": 899.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "321": {
        "problem_text": "스타크래프트와 같은 게임을 하다 보면 어떤 유닛을 목적지까지 이동시켜야 하는 경우가 종종 발생한다. 편의상 맵을 N×M 크기의 2차원 행렬로 생각하자. 또한 각각의 유닛은 크기를 가질 수 있는데, 이를 A×B 크기의 2차원 행렬로 생각하자. 아래는 5×5 크기의 맵과 2×2 크기의 유닛에 대한 한 예이다. S는 시작점을 나타내며 E는 끝점을 나타낸다.\n\n유닛은 상하좌우의 네 방향으로만 움직일 수 있다. 단, 유닛의 일부분이 장애물이 설치된 부분(위의 예에서 색이 칠해진 부분)을 지날 경우, 위의 예에서는 시작 위치에서 위로 이동하는 경우는 허용되지 않는다. 위의 예는 유닛을 오른쪽으로 세 칸, 위쪽으로 세 칸 움직이면 목적지에 도달할 수 있고, 이 경우가 가장 적은 이동 회수를 거치는 경우이다. 이동하는 도중에 유닛이 맵 밖으로 나가는 경우는 허용되지 않는다.\n맵의 정보와 유닛의 정보가 주어졌을 때, 유닛을 목적지까지 움직이기 위해 필요한 최소의 이동 회수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 다섯 개의 정수 N, M(1 ≤ N, M ≤ 500), A, B(1 ≤ A, B ≤ 10), K(0 ≤ K ≤ 100,000)가 주어진다. 다음 K개의 줄에는 장애물이 설치된 위치(행 번호, 열 번호)가 주어진다. 그 다음 줄에는 시작점의 위치와 도착점의 위치가 주어진다. 시작점의 위치와 도착점의 위치는 제일 왼쪽 제일 위의 한 점만 주어진다. 시작점의 위치와 도착점의 위치는 같지 않다.\n유닛의 시작점에는 장애물이 존재하지 않으며, 시작점과 도착점이 행렬의 범위를 벗어나는 경우는 없다.\n",
        "output_text": "첫째 줄에 답을 출력한다. 이동이 불가능한 경우에는 -1을 출력한다.\n",
        "memory_median": 3496.0,
        "time_median": 16.0,
        "length_median": 1537.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "322": {
        "problem_text": "With plenty of free time on their hands (or rather, hooves), the cows on Farmer John's farm often pass the time by playing video games. One of their favorites is based on a popular human video game called Puyo Puyo; the cow version is of course called Mooyo Mooyo.\nThe game of Mooyo Mooyo is played on a tall narrow grid $N$ cells tall ($1 \\leq N \\leq 100$) and 10 cells wide. Here is an example with $N = 6$:\n\r\n0000000000\r\n0000000300\r\n0054000300\r\n1054502230\r\n2211122220\r\n1111111223\r\n\nEach cell is either empty (indicated by a 0), or a haybale in one of nine different colors (indicated by characters 1..9). Gravity causes haybales to fall downward, so there is never a 0 cell below a haybale.\nTwo cells belong to the same connected region if they are directly adjacent either horizontally or vertically, and they have the same nonzero color. Any time a connected region exists with at least $K$ cells, its haybales all disappear, turning into zeros. If multiple such connected regions exist at the same time, they all disappear simultaneously. Afterwards, gravity might cause haybales to fall downward to fill some of the resulting cells that became zeros. In the resulting configuration, there may again be connected regions of size at least $K$ cells. If so, they also disappear (simultaneously, if there are multiple such regions), then gravity pulls the remaining cells downward, and the process repeats until no connected regions of size at least $K$ exist.\nGiven the state of a Mooyo Mooyo board, please output a final picture of the board after these operations have occurred.\n",
        "input_text": "The first line of input contains $N$ and $K$ ($1 \\leq K \\leq 10N$). The remaining $N$ lines specify the initial state of the board.\n",
        "output_text": "\t\t\t\t\tPlease output $N$ lines, describing a picture of the final board state.\r\n\n\t\t\t\t\t",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 2011.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "323": {
        "problem_text": "닭싸움은 월드의 전통이다. 이번 캠프에서도 어김없이 닭싸움 대회가 열렸다. 그런데, 닭싸움을 하기 위해서는 반드시 누가 우리 편이고, 누가 우리 편이 아닌지를 알아야 할 것이다. 닭싸움의 팀을 정하는 원칙은, 평소 학생들의 인간관계에 따라 다음과 같이 정리할 수 있다.\n\n내 친구의 친구는 내 친구이다.\n내 원수의 원수도 내 친구이다.\n\n이 때 두 학생이 친구이면 같은 팀에 속해있어야 하며, 같은 팀에 속해 있는 사람들끼리는 전부 친구여야 한다.\n학생들의 인간관계가 주어지면, 닭싸움을 위한 팀 정하기를 할 때, 최대 얼마나 많은 팀이 만들어질 수 있는지 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 학생의 수 n이 주어진다. 각 학생들은 1부터 n까지 번호가 매겨져 있다. (2 ≤ n ≤ 1000) \n둘째 줄에 학생 간의 인간관계 중 알려진 것의 개수 m이 주어진다. (1 ≤ m ≤ 5000)\n다음 m개의 줄에는 한 줄에 한 개씩, 학생 간의 인간관계가 F p q 혹은 E p q의 형태로 공백으로 구분되어 주어진다. (1 ≤ p < q ≤ n)\n첫 번째 글자가 F인 경우에는 p와 q가 친구인 것이고, E인 경우는 p와 q가 원수인 경우이다. \n입력은 모순이 없음이 보장된다. 즉, 두 학생이 동시에 친구이면서 원수인 경우는 없다.\n",
        "output_text": "첫째 줄에, 가능한 최대 팀 개수를 출력한다.\n",
        "memory_median": 2172.0,
        "time_median": 4.0,
        "length_median": 1167.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "324": {
        "problem_text": "현민이는 트리 모양의 길 위에서 오토바이를 타고 전단지를 돌리려고 한다. 현민이의 목표는 케니소프트에서 출발하여 모든 노드에 전단지를 돌리고, 다시 케니소프트로 돌아오는 것이다. 현민이는 힘이 좋기 때문에 현재 노드에서 거리가 $D$ 이하인 모든 노드에 전단지를 돌릴 수 있다.\n날씨가 매우 덥기 때문에, 현민이는 최소한만 이동해서 목표를 달성하고 싶다! 현민이를 위해 현민이가 이동해야 하는 총 거리를 구해주자.\n",
        "input_text": "첫번째 줄에는 노드의 개수 $N$($ 1 \\leq N \\leq 100\\ 000 $)과 케니소프트의 위치 $S$($ 1 \\leq S \\leq N $), 힘 $D$($ 0 \\leq D \\leq N $)이 주어진다.\n두 번째 줄부터 $N$번째 줄까지, 트리의 간선 정보를 의미하는 두 자연수 $x$, $y$가 공백으로 구분되어 주어진다. 이는 $x$번 노드와 $y$번 노드가 연결되어 있음을 의미한다. ($1 \\leq x, y \\leq N$, $x \\neq y$)\n주어지는 연결관계는 트리를 구성하며, 모든 간선의 길이는 $1$이다.\n",
        "output_text": "현민이가 목표를 완수하기 위해 이동해야 하는 최소 거리를 출력하여라.\n",
        "memory_median": 10844.0,
        "time_median": 52.0,
        "length_median": 933.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "325": {
        "problem_text": "부유한 집안의 상속자 상근이네 집은 그림과 같이 1미터의 정육각형이 붙어있는 상태이다. 크리스마스가 다가오기 때문에, 여자친구에게 잘 보이기 위해 상근이는 건물의 벽면을 조명으로 장식하려고 한다. 외부에 보이지 않는 부분에 조명을 장식하는 것은 낭비라고 생각했기 때문에, 밖에서 보이는 부분만 장식하려고 한다.\n\n위의 그림은 상공에서 본 상근이네 집의 건물 배치이다. 정육각형 안의 숫자는 좌표를 나타낸다. 여기서 회색 정육각형은 건물의 위치이고, 흰색은 건물이 없는 곳이다. 위에서 붉은 색 선으로 표시된 부분이 밖에서 보이는 벽이고, 이 벽에 조명을 장식할 것이다. 벽의 총 길이는 64미터이다.\n상근이네 집의 건물 위치 지도가 주어졌을 때, 조명을 장식할 벽면의 길이의 합을 구하는 프로그램을 작성하시오. 지도의 바깥은 자유롭게 왕래 할 수 있는 곳이고, 인접한 건물 사이는 통과할 수 없다.\n",
        "input_text": "첫째 줄에 두 개의 정수 W와 H가 주어진다. (1 ≤ W, H ≤ 100) 다음 H줄에는 상근이네 집의 건물 배치가 주어진다. i+1줄에는 W개의 정수가 공백으로 구분되어 있다. j번째 (1 ≤ j ≤ w) 정수의 좌표는 (j, i)이며, 건물이 있을 때는 1이고, 없을 때는 0이다. 주어지는 입력에는 건물이 적어도 하나 있다.\n지도는 다음과 같은 규칙에 의해 만들어졌다.\n\n지도의 가장 왼쪽 위에 있는 정육각형의 좌표는 (1,1)이다.\n(x,y)의 오른족에 있는 정육각형의 좌표는 (x+1,y)이다.\ny가 홀수 일 때, 아래쪽에 있는 정육각형의 좌표는 (x,y+1)이다.\ny가 짝수 일 때, 오른쪽 아래에 있는 정육각형의 좌표는 (x,y+1)이다.\n\n",
        "output_text": "조명을 장식하는 벽면의 길이의 합을 출력한다.\n",
        "memory_median": 2104.0,
        "time_median": 0.0,
        "length_median": 1591.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "326": {
        "problem_text": "태균이는 지금 태권도 겨루기 중이다. 지금은 상대에게 지고 있지만 지금부터 진심으로 경기하여 빠르게 역전을 노리려 한다.\n태균이가 현재 할 수 있는 연속 발차기는 두가지가 있다.\n\nA는 현재 점수만큼 점수를 얻을 수 있는 엄청난 연속 발차기이다. 하지만 상대 역시 3점을 득점하는 위험이 있다.\nB는 1점을 얻는 연속 발차기이다.\n\n현재 태균이의 점수 S와 상대의 점수 T가 주어질 때, S와 T가 같아지는 최소 연속 발차기 횟수를 구하는 프로그램을 만드시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 수 C(1 ≤ C ≤ 100)이 주어진다. 둘째 줄부터 C줄에 걸쳐 테스트 케이스별로 현재 점수 S와 T가 공백을 사이에 두고 주어진다. (1 ≤ S < T ≤ 100)\n",
        "output_text": "각 줄마다 S와 T가 같아지는 최소 연속 발차기 횟수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 755.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "327": {
        "problem_text": "2차원 평면상에 m개의 수직선과 n개의 수평선으로 이루어진 격자 형태의 도로망이 있다. 아래 그림은 7개의 수직선과 6개의 수평선으로 이루어진 도로망의 예이다.  \n\n수직선과 수평선이 만나는 교차점들 중 가장 왼쪽 아래 점의 위치는 (1,1)이고, 가장 오른쪽 위 점의 좌표는 (m,n)이다. 이 도로망을 운행하는 버스들이 k개 있고, 각  버스는 하나의 수평선 상의 두 교차점 사이 선분이나 하나의 수직선 상의 두 교차점 사이 선분을 왕복 운행한다. 각 버스는 운행하는 선분 사이의 모든 교차점(선분의 양 끝 교차점 포함)에서 정차한다. \n출발지 교차점과 목적지 교차점 (출발지와 목적지는 다름)이 주어질 때, 출발지에서 목적지로 버스만을 이용하여 가려고 한다. 이용하는 버스의 최소 수를 구하는 프로그램을 작성하시오.  \n예를 들어,  8대의 버스가 다음과 같이 운행한다고 하자.\n\n1번 버스: (2, 1) - (2, 2)\n2번 버스: (1, 1) - (5, 1)\n3번 버스: (3, 2) - (6, 2)\n4번 버스: (5, 6) - (5, 1)\n5번 버스: (1, 5) - (7, 5)\n6번 버스: (7, 3) - (7, 6)  \n7번 버스: (2, 1) - (2, 6) \n8번 버스: (3, 5) - (6, 5)\n\n출발지가 (2, 1)이고 목적지가 (7, 4)라 하자. 한 가지 방법으로, 처음에 2번 버스를 타고 교차점 (5, 1)에서 내려, 4번 버스를 타고 (5, 5)에서 내리고, 5번 버스를 탄 후 (7, 5)에서 내려, 마지막으로 6번 버스를 타서 목적지 (7, 4)에서 내린다. 그러면 이용하는 버스 수는 4이다. 다른 방법으로, 7번 버스를 타고 (2, 5)에서 내려, 5번 버스를 타고 (7, 5)에서 내린 후, 마지막으로 6번 버스를 타서 목적지 (7, 4)에서 내린다. 그러면 이용하는 버스 수는 3이고 이것이 최소이다. \n",
        "input_text": "첫 번째 줄에 수직선의 수 m과 수평선의 수 n이 빈칸을 사이에 두고 주어진다 (1 ≤ m,n ≤ 100,000). 두 번째 줄에 버스의 수 k (1 ≤ k ≤ 5,000)가 주어진다. 세 번째 줄부터 k 줄에 걸쳐 각 줄에 버스의 운행구간을 나타내는 5개의 수 b, x1, y1, x2, y2가 빈칸을 사이에 두고 주어진다. 여기서 b (1 ≤ b ≤ k) 는 버스의 번호, (x1, y1) 과 (x2, y2)는 이 버스가 운행하는 양쪽 끝 교차점의 좌표를 나타낸다. 마지막 줄에 출발지와 목적지 좌표를 나타내는 네 개의 수 sx, sy, dx, dy가 빈칸을 사이에 두고 주어진다. 여기서 (sx, sy)는 출발지 좌표이고 (dx, dy)는 목적지 좌표이다. 1 ≤ x1, x2, sx, dx ≤ m이고, 1 ≤ y1, y2, sy, dy ≤ n이다. \n모든 입력에 대하여, 출발지와 목적지는 다르게 주어지며 출발지에서 목적지로 가는 방법은 한 가지 이상 존재한다.\n",
        "output_text": "첫째 줄에 이용하는 최소 버스 수를 출력한다. \n",
        "memory_median": 6212.0,
        "time_median": 260.0,
        "length_median": 2289.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "328": {
        "problem_text": "인하니카 공화국은 1번~ N번까지 N개의 섬으로 이루어진 나라이다. 이 나라에서는 섬 간의 왕래가 매우 어려웠지만, 위대한 다리 설계자 ‘진’이 두 섬을 연결하는 다리를 최소한의 개수로 만들어 모든 섬 간의 왕래가 가능하도록 만들었다. 1번섬에서 살고 있는 진은 어느 날 위험한 소문을 듣게 되었다. 1번섬을 제외한 다리가 하나밖에 없는 어느 섬에서 유명한 연쇄 살인마 괴도‘루팡’이 자신의 목숨을 노리고 있다는 소문이었다. 너무 불안한 나머지 진은 몇 개의 다리를 폭파하여, 루팡이 있을 가능성이 있는 모든 섬에서 자신의 섬으로의 모든 경로를 차단하려고 한다. 하지만 각 다리를 폭파하려면 다리의 크기에 따라 다이너마이트의 개수가 다르다. 다이너마이트는 매우 비싸기 때문에 진은 사용하는 다이너마이트의 개수를 최소화하고 싶어 한다. 각 섬을 연결하는 다리를 폭파하기 위한 다이너마이트의 개수가 주어졌을 때, 진을 도와 필요한 최소 다이너마이트의 개수를 구하라.\n\n예를 들어, 위의 그림과 같이 섬과 다리를 폭파하기 위한 다이너마이트의 수가 주어졌을 때, 빨간색 다리를 폭파하면 다이너마이트의 개수를 최소화하면서 루팡으로부터 안전할 수 있다.\n",
        "input_text": "입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 100)가 주어진다.\n각 테스트 케이스의 첫 번째 줄에는 섬의 수 N(1 ≤ N ≤ 1,000)과 다리의 수 M이 주어진다.\n다음으로 M개의 줄에는 각 다리를 통해 이어진 두 섬의 번호와 다리를 파괴하기 위한 다이너마이트의 수 D(1 ≤ D ≤ 20)가 주어진다.\n",
        "output_text": "각 테스트 케이스마다 필요한 최소 다이너마이트의 개수를 출력한다.\n",
        "memory_median": 2316.0,
        "time_median": 16.0,
        "length_median": 980.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "329": {
        "problem_text": "어린 토니킴은 색칠공부를 좋아한다.\n토니킴은 먼저 여러 동그라미와 동그라미 두 개를 연결하는 직선들 만으로 그림을 그리고 (모든 동그라미들 사이에 직선이 있을 필요는 없다), 연결된 두 동그라미는 서로 색이 다르게 되도록 색을 칠하고자 한다.\n이 그림을 색칠하는데 필요한 최소의 색의 개수를 구하는 문제는 어렵기 때문에 토니킴은 2 가지 색상으로 색칠이 가능한지의 여부만을 알고 싶어한다.\n동그라미들의 번호와 동그라미들이 서로 연결된 직선에 대한 정보가 주어졌을 때, 이 동그라미들이 2 가지 색상으로 색칠이 가능한지 알아내자.\n",
        "input_text": "입력의 첫 줄에는 테스트 케이스의 개수 T 가 주어진다.\n그 다음 줄부터 각 테스트 케이스에 대해 동그라미의 개수 n(1 ≤ n ≤ 1000)과 직선들의 개수 m(1 ≤ m ≤ 100,000)이 주어지고, 그 다음 줄부터 m 줄에 걸쳐 동그라미들이 연결된 직선에 대한 정보가 주어진다. (x y)로 주어지면 동그라미 x와 동그라미 y가 직선으로 서로 연결되었다는 의미이다. 동그라미들의 번호는 1 부터 n 까지이다.\n",
        "output_text": "각 테스트 케이스에 대해서 possible 이나 impossible 을 출력한다. 2 가지 색상으로 색칠이 가능하면 possible. 불가능하면 impossible 이다.\n",
        "memory_median": 3380.0,
        "time_median": 112.0,
        "length_median": 1144.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "330": {
        "problem_text": "今年も JOI 町のチーズ工場がチーズの生産を始め，ねずみが巣から顔を出した．JOI 町は東西南北に区画整理されていて，各区画は巣，チーズ工場，障害物，空き地のいずれかである．ねずみは巣から出発して全てのチーズ工場を訪れチーズを 1 個ずつ食べる．\nこの町には，N 個のチーズ工場があり，どの工場も１種類のチーズだけを生産している．チーズの硬さは工場によって異なっており，硬さ 1 から N までのチーズを生産するチーズ工場がちょうど 1 つずつある．\nねずみの最初の体力は 1 であり，チーズを 1 個食べるごとに体力が 1 増える．ただし，ねずみは自分の体力よりも硬いチーズを食べることはできない．\nねずみは，東西南北に隣り合う区画に 1 分で移動することができるが，障害物の区画には入ることができない．チーズ工場をチーズを食べずに通り過ぎることもできる．すべてのチーズを食べ終えるまでにかかる最短時間を求めるプログラムを書け．ただし，ねずみがチーズを食べるのにかかる時間は無視できる．\n",
        "input_text": "入力は H+1 行ある．1 行目には 3 つの整数 H，W，N (1 ≦ H ≦ 1000，1 ≦ W ≦ 1000，1 ≦ N ≦ 9) がこの順に空白で区切られて書かれている．2 行目から H+1 行目までの各行には，'S'，'1', '2', ..., '9'，'X'，'.' からなる W 文字の文字列が書かれており，各々が各区画の状態を表している．北から i 番目，西から j 番目の区画を (i,j) と記述することにすると (1 ≦ i ≦ H, 1 ≦ j ≦ W)，第 i+1 行目の j 番目の文字は，区画 (i,j) が巣である場合は 'S' となり，障害物である場合は 'X' となり，空き地である場合は '.' となり，硬さ 1, 2, ..., 9 のチーズを生産する工場である場合はそれぞれ '1', '2', ..., '9' となる．入力には巣と硬さ 1, 2, ..., N のチーズを生産する工場がそれぞれ 1 つずつある．他のマスは障害物または空き地であることが保証されている．ねずみは全てのチーズを食べられることが保証されている．\n",
        "output_text": "すべてのチーズを食べ終えるまでにかかる最短時間（分）を表す整数を 1 行で出力せよ．\n",
        "memory_median": 6920.0,
        "time_median": 76.0,
        "length_median": 1493.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "331": {
        "problem_text": "간단하지만 귀찮은 영상처리 과제가 주어졌다. 과제의 명세는 다음과 같다.\n세로 길이가 $N$이고 가로 길이가 $M$인 화면은 총 $N$ × $M$개의 픽셀로 구성되어 있고 $(i, j)$에 있는 픽셀은 $R_{i,j}$ (Red), $G_{i,j}$ (Green), $B_{i,j}$ (Blue) 3가지 색상의 의미를 담고 있다. 각 색상은 0이상 255이하인 값으로 표현 가능하다.\n모든 픽셀에서 세 가지 색상을 평균내어 경계값 $T$보다 크거나 같으면 픽셀의 값을 255로, 작으면 0으로 바꿔서 새로운 화면으로 저장한다.\n새로 만들어진 화면에서 값이 255인 픽셀은 물체로 인식한다. 값이 255인 픽셀들이 상하좌우로 인접해있다면 이 픽셀들은 같은 물체로 인식된다.\n화면에서 물체가 총 몇 개 있는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "화면의 세로 $N$, 가로 $M$ 값이 공백으로 구분되어 주어진다.\n두 번째 줄부터 $N + 1$줄까지 $i$번째 가로를 구성하고 있는 픽셀의 $R_{i,j}$, $G_{i,j}$, $B_{i,j}$의 값이 공백으로 구분되어 총 $M$개 주어진다.\n마지막 줄에는 경계값 $T$가 주어진다.\n",
        "output_text": "화면에 있는 물체의 개수를 출력하라. 만약 물체가 없으면 0을 출력하면 된다.\n",
        "memory_median": 14652.0,
        "time_median": 132.0,
        "length_median": 1290.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "332": {
        "problem_text": "당신에게 3x3 크기의 보드가 주어진다. 각각의 칸은 처음에 흰색 혹은 검은색이다. 만약 당신이 어떤 칸을 클릭한다면 당신이 클릭한 칸과 그 칸에 인접한 동서남북 네 칸이 (존재한다면) 검은색에서 흰색으로, 혹은 흰색에서 검은색으로 변할 것이다.\n당신은 모든 칸이 흰색인 3x3 보드를 입력으로 주어지는 보드의 형태로 바꾸려고 한다. 보드를 회전시킬수는 없다.\n\nFigure D.1: 예제 입력\n",
        "input_text": "첫 줄에는 테스트 케이스의 숫자 P(0 < P ≤ 50)이 주어진다.\n각각의 테스트 케이스에 대해서 세 줄에 걸쳐 한 줄에 세 글자씩이 입력으로 들어온다. \"*\"은 검은색을 뜻하며 \".\"은 흰색을 뜻한다.\n",
        "output_text": "각각의 테스트 케이스에 대해서 흰 보드를 입력에 주어진 보드로 바꾸는 데 필요한 최소 클릭의 횟수를 구하여라.\n",
        "memory_median": 1932.0,
        "time_median": 0.0,
        "length_median": 1345.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "333": {
        "problem_text": "카트라이더를 처음 시작하는 카린이 정범이는 어려운 조작법에 실망감이 커져가고 있다. 드리프트, 순간 부스터, 커팅, 톡톡이 등등 어려운 테크닉에 질린 정범이는 그나마 쉬운 ‘숭고한 무한부스터 모드’에 도전해보려고 한다.\n‘숭고한 무한부스터 모드’는 크기 N × M 의 직사각형 모양의 맵에서 진행되며, 맵 전체가 단위 격자로 구성되어 있다. 기존의 ‘무한부스터 모드’와는 다르게, 모든 격자 안에는 특정 개수의 부스터 아이템이 위치한다. 이 모드에서 플레이의 방식은 다음과 같다.\n처음에 플레이어의 카트바디는 출발지점인 1행 1열에 위치하며, 멈춰 있는 상태이고, 보유하고 있는 부스터 아이템의 개수는 0개이다. 목표는 도착지점인 N행 M열의 격자에 도달하는 것이며, 도달하는 즉시 게임이 종료된다. 카트바디가 격자에 멈추어 있을 때, 격자에 놓여있는 부스터 아이템을 자동으로 전부 습득하게 된다. 이 과정에서 x개를 습득했다면 한 방향을 정해 오른쪽으로 최대 x칸을 가거나, 아래쪽으로 최대 x칸을 이동할 수 있으며, 1칸 단위로 이동하게 된다. 예를 들어 부스터 아이템을 3개 습득했을 때, 오른쪽으로 2칸 이동이나 아래쪽으로 3칸 이동은 가능하지만, 오른쪽으로 1칸 이동 후 아래로 2칸 이동이나 왼쪽으로 1칸 이동이나 아래쪽으로 2.718칸 이동은 불가능하다. 이동 후 멈추면서 보유하고 있던 부스터 아이템은 모두 소진된다.\n이동중에 멈추지 않고 지나치는 격자의 부스터 아이템은 습득할 수 없으며, 카트바디는 맵을 벗어나는 방향으로는 움직일 수 없다.\n정범이는 ‘숭고한 무한부스터 모드’에서 출발지점부터 도착지점까지 주행하면서 부스터 아이템을 획득하게 되는 격자의 개수를 최소화하고 싶다. 카린이 정범이를 도와주도록 하자.\n",
        "input_text": "첫 번째 줄에 맵의 세로 길이와 가로 길이를 나타내는 양의 정수 N과 M이 공백으로 구분되어 주어진다. (1 ≤ N, M ≤ 300)\n두 번째 줄부터 N개의 줄에 걸쳐 각 격자에 있는 부스터 아이템 개수인 M개의 양의 정수 aij가 공백으로 구분되어 주어진다. (1 ≤ aij ≤ max(N, M)) aij는 i 행 j 열의 격자에 있는 부스터 아이템 개수이다.\n출발지점과 도착지점은 다르다.\n",
        "output_text": "첫 번째 줄에 정범이가 맵의 출발지점부터 도착지점까지 이동하면서 부스터 아이템을 획득하게 되는 격자의 최소 개수를 출력한다.\n",
        "memory_median": 2728.0,
        "time_median": 12.0,
        "length_median": 970.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "334": {
        "problem_text": "과외맨은 평소에 서강대학교 학생 이민혁으로 위장하고 있는 한국의 대표적인 영웅이다. 그는 슈퍼 히어로가 너무 미국에 집중되어 있는 현실을 안타까워했고, 그의 절친한 친구인 스파이더맨과 아이언맨에게 한국으로 와서 같이 영웅 활동을 하자는 제안을 했으나 거절당했다.\n얼마 전, 오랜 잠에서 깨어난 고대 마야인들이 과외맨이 수업을 듣는 동안 과외 노트를 훔쳐갔다. 과외맨은 빼앗긴 노트를 찾아오기 위해 인천 공항으로 가서 과테말라로 가는 비행기를 탔다.\n일단 언어가 통하지 않기 때문에, 과외맨은 자신의 특기를 살려서 일주일간 과테말라에서 스페인어를 과외 받았다.\n오랜 고서에 의하면, 고대 마야인은 하늘을 날아다니는 재주가 있었다고 한다. 과외맨은 매일 밤 하늘을 바라보며 마야인들의 흔적을 찾으려고 애를 썼다.\n그렇게 한 달이 지났을까... 한국에선 이민혁 실종 사건이 연일 대서특필 되고 있고, 사람들은 사라진 과외맨을 찾으며 시청 광장에서 촛불 집회를 했다. 과외맨도 이런 사실에 안타까움을 느꼈다. 하지만, 과외 노트 없는 과외맨은 평범한 대학생과 같기 때문에 아직 돌아갈 수 없었다.\n과외 노트의 단서는 뜻하지 않게 스페인어 과외를 받던 중에 알게 되었다. 과외맨의 과외 선생님이 주말을 이용해서 등산을 하던 사이에 고대 마야의 사원으로 보이는 것을 발견했고, 민혁이에게 과외 노트가 거기에 있는 것 같다고 알려주었다.\n과외맨은 즉시 과외 노트를 찾으러 고대 마야의 사원으로 여행을 떠났다.\n고대 마야의 사원의 입구로 들어간 과외맨은 매우 놀랐다. 바로 과외 노트가 자신의 눈 앞에 있는 것 이었다. 과외맨은 이적의 다행이다를 부르면서 과외 노트를 집으려고 했지만, 그것은 노트의 홀로그램이었다. 이어서 고대 마야인의 목소리가 사원을 가득 채우기 시작했다. 하지만, 고대 마야인은 스페인어를 사용하지 않았다. 과외맨은 닥터후에게 전화를 걸어서 자신에게 타디스의 번역 프로토콜을 제공해 줄 수 있는지를 물어 보았다. 닥터는 흔쾌히 요청을 받아들였고, 민혁이는 마야인의 메시지를 듣기 위해 밖으로 나갔다가 다시 들어왔다.\n\"하하하. 과외 노트를 돌려 받고 싶나? 그럼 여기로 와서 가져가 보시지. 하하하하\"\n과외맨의 과외 노트는 입구의 반대편에 있고, 그 사이에는 절벽이 있었다. 갑자기 하늘에서 거대한 도미노 타일이 떨어졌고, 그 사이를 연결하는 다리를 만들었다.\n도미노 타일은 두 조각으로 나누어져 있었고, 각 조각은 정사각형이다. 조각에는 1과 6사이의 숫자가 써져 있다.\n타일은 N줄로 놓여져 있고, 홀수 줄에는 N개의 타일이, 짝수 줄에는 N-1개의 타일이 놓여져 있다. 아래 그림은 (N=5)일 때 타일이 놓여져 있는 형태이다.\n\n한 타일에서 다른 타일로 넘어가려면, 두 타일이 인접해야 한다. 또, 같은 변을 공유하는 조각에 쓰여 있는 숫자가 같아야 한다.\n과외맨은 반대편으로 넘어가기 위해서 첫 줄의 가장 첫 타일에서 마지막 줄의 가장 마지막 타일로 이동하는 가장 짧은 경로를 찾으려고 한다.\n타일은 row-major order에 의해서 번호가 매겨져 있으며, 첫 번째 줄의 첫 타일의 번호는 1, 마지막 타일의 번호는 N이다. 두 번째 줄에서 첫 타일의 번호는 N+1이고, 마지막 타일의 번호는 2*N-1이다.\n첫 줄의 첫 타일로만 과외맨이 들어갈 수 있고, 마지막 줄의 마지막 타일위에 과외 노트가 놓여져 있다.\n마지막 줄의 마지막 타일로 이동할 수 없는 경우가 존재할 수 있다. 이 경우에는 번호가 가장 큰 타일로 이동하면 된다.\n",
        "input_text": "첫째 줄에 N이 주어진다. (1 ≤ N ≤ 500) 다음 줄부터 N*N-N/2줄(/는 정수 나눗셈이다)에는 두 양의 Ai와 Bi가 주어진다. (1 ≤ Ai, Bi ≤ 6, 1 ≤ i ≤ N * N - N / 2) 타일 i의 왼쪽에 쓰여 있는 숫자는 Ai, 오른쪽에 쓰여 있는 숫자는 Bi이다.\n",
        "output_text": "첫째 줄에 가장 짧은 경로의 길이 (타일의 개수)를 출력한다.\n둘째 줄에는 경로 상의 타일의 번호를 공백으로 구분하여 순서대로 출력한다. 만약, 가장 짧은 경로가 여러 가지라면, 아무거나 출력하면 된다.\n",
        "memory_median": 9068.0,
        "time_median": 94.0,
        "length_median": 2601.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "335": {
        "problem_text": "최대 5개의 조각이 있는 5×5 크기의 보드가 있다. 김지민은 조각을 적절히 움직여서 모든 조각이 연결 요소를 이루게 하려고 한다. 즉 상하좌우로 인접한 조각을 모두 연결했을 때, 모든 쌍의 조각이 적어도 하나의 경로로 연결되어 있어야 한다.\n한 번의 이동으로 하나의 조각을 상하좌우로 인접한 칸으로 옮길 수 있다. 보드의 상태가 주어질 때, 최소 몇 번 이동해야 모든 조각이 연결 요소를 이루게 되는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄부터 다섯째 줄까지 보드의 상태가 주어진다. 빈 곳은 '.'이고, 조각은 '*'이다. 조각은 1개 이상 5개 이하이다.\n",
        "output_text": "첫째 줄에 문제의 정답을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 44.0,
        "length_median": 1940.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "336": {
        "problem_text": "꽉꽉나라에 사는 주예와 방주는 점 S에서 만나 저녁을 먹기로 했다. 주예는 점 S에 도착했지만 길치인 방주가 약속시간이 30분이 지나도 나타나지 않자 방주에게 연락을 하여 방주가 점 E에 있다는 사실을 알아냈다. 주예는 방주에게 그 위치에 가만히 있으라고 했고, 직접 점 E로 가려고 한다.\n꽉꽉나라에는 1부터 N까지의 각 점에 하나의 텔레포트 정거장이 위치해 있고 텔레포트를 통하여 연결되어 있는 다른 텔레포트의 정거장으로 이동할 수 있다. 주예는 현재 위치가 점 X라면 X+1이나 X-1로 이동하거나 X에 위치한 텔레포트와 연결된 지점으로 이동할 수 있으며 각 행동에는 1초가 소요된다. 배가 고픈 주예는 최대한 빨리 방주와 만나고 싶어 한다.\nN과 텔레포트 연결 정보가 주어질 때 점 S에 있는 주예가 점 E까지 가는 최소 시간을 구해보자.\n",
        "input_text": "첫 번째 줄에 정수 N, M이 공백으로 구분되어 주어진다. (2 ≤ N ≤ 300,000, 0 ≤ M ≤ min(N×(N-1)/2, 300,000))\n두 번째 줄에 정수 S, E가 공백으로 구분되어 주어진다. (1 ≤ S, E ≤ N, S ≠ E)\n그 다음 줄부터 M개의 줄에 걸쳐 텔레포트 연결 정보를 의미하는 정수 x, y가 주어진다. (1 ≤ x, y ≤ N, x ≠ y)\nx y는 점 x의 텔레포트와 점 y의 텔레포트가 연결되어 있다는 뜻이다. M개의 연결정보는 중복되는 x y쌍이 없도록 주어진다.\n",
        "output_text": "첫 번째 줄에 주예와 방주가 만날 수 있는 최소 시간을 출력한다.\n",
        "memory_median": 19204.0,
        "time_median": 210.0,
        "length_median": 1041.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "337": {
        "problem_text": "세준이는 위험한 지역에서 탈출하는 게임을 하고 있다. 이 게임에는 세준이가 들어갈 수 없는 죽음의 구역이 있고, 들어가서 한 번 움직일 때 마다 생명이 1씩 소모되는 위험한 구역이 있다. 그리고, 자유롭게 생명의 위협없이 움직일 수 있는 안전한 구역이 있다. (안전한 구역은 죽음의 구역과 위험한 구역을 제외한 나머지 이다.)\n세준이는 (0, 0)에서 출발해서 (500, 500)으로 가야 한다. 세준이는 위, 아래, 오른쪽, 왼쪽으로만 이동할 수 있다. 현재 세준이는 (0, 0)에 있다. 그리고, 게임 판을 벗어날 수는 없다.\n세준이가 (0, 0)에서 (500, 500)으로 갈 때 잃는 생명의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 위험한 구역의 수 N이 주어진다. 다음 줄부터 N개의 줄에는 X1 Y1 X2 Y2와 같은 형식으로 위험한 구역의 정보가 주어진다. (X1, Y1)은 위험한 구역의 한 모서리이고, (X2, Y2)는 위험한 구역의 반대 모서리이다. 그 다음 줄에는 죽음의 구역의 수 M이 주어진다. 다음 줄부터 M개의 줄에는 죽음의 구역의 정보가 위험한 구역의 정보와 같이 주어진다. 주어지는 구역은 모두 겹칠 수 있으며, 서로 다른 구역이 겹칠 때는, 더 심한 구역이 해당된다. 예를 들어, 죽음+위험 = 죽음, 위험+안전 = 위험, 위험+위험 = 위험, 죽음+안전 = 죽음이다. 위험한 구역이 아무리 겹쳐도 생명은 1씩 감소된다. 생명의 감소는 구역에 들어갈 때만, 영향을 미친다. 예를 들어, (500, 500)이 위험한 구역일 때는, (500, 500)에 들어갈 때, 생명이 1 감소되지만, (0, 0)이 위험한 구역이더라도 생명은 감소되지 않는다. 마찬가지로, (0, 0)이 죽음의 구역이더라도 세준이는 이미 그 곳에 있으므로 세준이에게 영향을 미치지 않는다. N과 M은 50보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 정답을 출력한다. 만약 (500, 500)으로 갈 수 없을 때는 -1을 출력한다.\n",
        "memory_median": 4884.0,
        "time_median": 12.0,
        "length_median": 1828.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "338": {
        "problem_text": "2007년 1월 9일(화)는 원장선생님의 말씀대로 어제와 같이 하루 일과를 팀플레이를 통해 하려고 한다. 이 날은 특별히 청팀과 백팀으로 두 팀을 나누어 팀전을 하려 한다. 하지만 어제 하루 팀플레이를 하면서, 서로 같은 팀을 하기 싫어하는 사람들이 생겼다.\n이제 우리가 할 일은 다음과 같다. 사람들이 각각 싫어하는 사람들의 정보가 주어져 있을 때, 그 사람들의 요구를 수용하여 서로 싫어하는 사람은 같은 팀에 넣지 않으려 한다. 이 조건을 만족하여 n명의 사람들 두 팀으로 나누는 프로그램을 작성하여라.\n",
        "input_text": "첫 줄에는 학생들의 수 n (1 ≤ n ≤ 100)이 주어진다. 그리고 둘째 줄부터 n+1번째 줄까지 서로가 싫어하는 사람들의 정보가 주어진다. i+1번째 줄에는 i번째 사람이 싫어하는 사람의 수와 싫어하는 사람들이 나온다.\n모든 사람이 싫어하는 사람이 단 한 명도 없는 경우는 없다.\n",
        "output_text": "첫줄에는 청팀의 사람의 수를 출력하고, 그리고 둘째 줄에는 청팀에 속한 사람들을 오름차순으로 나열한다. 그리고 셋째 줄과 넷째 줄은 위와 같은 방법으로 백팀에 속한 인원의 수, 백팀에 속한 사람들을 출력한다. 단 답이 여러 가지 일 경우에는 한 가지만 출력하여도 좋다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1198.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "339": {
        "problem_text": "One of the most important data structures in computer science is the tree. You already dealt with binary trees in the qualification round. This problem is about general trees.\nTrees are the subset of graphs that have the following 3 properties:\n\nIt is connected: for every node you can reach every other node following edges.\nIf an edge is removed, the graph is no longer connected. That is, some nodes cannot be reached anymore.\nWhen an edge is added between two existing nodes A and B, a cycle is created. There is a cycle if there is more than one way to go from A to B.\n\nYour task is to decide if a given graph is a tree or not.\n",
        "input_text": "The first line will contain an integer T representing the number of graphs to check. There will be at most 10 graphs in each test case.\nEach of the graph will be represented as follows:\nThe first line will contain an integer N with the number of nodes in the graph. The number of nodes will be between 1 and 1,000. The identifier of each node will be an integer from 1 to N. \nThe next line will contain an integer M with the number of edges in the graph. There will be at most 106 edges.\nThe next M lines will contain 2 integers A and B each. These are the two nodes connected by an edge.\nThe total sum of M in all test cases is at most 106.\n",
        "output_text": "For each graph, a single line with “tree” if the graph represents a tree or “graph“ otherwise.\n",
        "memory_median": 2052.0,
        "time_median": 0.0,
        "length_median": 893.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "340": {
        "problem_text": "민상이는 자신이 해야할 작업 $N$개를 아래와 같이 작업 순서도로 그려보았다.\n\n위 그림에서 5번 작업을 하기 위해 제일 먼저 2번 작업을 끝내야 하고 그 다음으로 4번 작업을 끝내야 5번 작업을 할 수 있다. 3번 작업은 먼저 해야하는 작업이 없으므로 3번 작업을 바로 시작 할 수 있다.\n작업 순서를 정할때 위배되는 작업 순서는 없다. 예를 들어, A 작업을 하려면 B 작업을 먼저 해야하고, B 작업을 해야하기 전에 A 작업을 해야하는 상황은 없다.\n민상이는 오늘 반드시 끝낼 작업 $X$가 있다. 민상이가 작업 $X$ 을 끝내기 위해서 먼저 해야하는 작업의 개수를 구해주자!\n",
        "input_text": "민상이가 작업할 개수 $N$와 작업 순서 정보의 개수 $M$이 공백으로 구분되어 주어진다.\n두 번째줄부터 $M + 1$ 줄까지 작업 $A_i$와 작업 $B_i$가 공백으로 구분되어 주어진다. 이때 두 값의 의미는 작업 $B_i$를 하기 위해서 바로 이전에 작업 $A_i$를 먼저 해야한다는 의미이다. 중복된 정보는 주어지지 않는다.\n마지막 줄에는 민상이가 오늘 반드시 끝내야하는 작업 $X$가 주어진다.\n",
        "output_text": "민상이가 작업 $X$를 하기 위해 먼저 해야하는 일의 개수를 출력한다.\n",
        "memory_median": 9534.0,
        "time_median": 60.0,
        "length_median": 635.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "341": {
        "problem_text": "오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 i번 노드의 깊이(depth)를 di라고 하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 i번 노드의 방문 순서를 ti라고 하자. 시작 정점의 방문 순서는 1이고 시작 정점에서 방문할 수 없는 노드는 0이다. 모든 노드에 대한 di × ti 값의 합을 구해보자.\n깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.\n\r\ndfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점\r\n    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.\r\n    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)\r\n        if (visited[x] = NO) then dfs(V, E, x);\r\n}\n",
        "input_text": "첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.\n다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.\n",
        "output_text": "첫째 줄에 모든 노드에 대한 di × ti 값의 합을 출력한다.\n",
        "memory_median": 12976.0,
        "time_median": 92.0,
        "length_median": 884.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "342": {
        "problem_text": "H-ALGO 회원인 한동이는 공부하는것을 좋아하지 않는다. 하지만 약삭빠르게도 한동이는 공부도 하지 않으면서 어려운 시험을 통과하고 싶어한다.\n그러던 와중 어느 날, 한동이의 동기가 한동이에게 선배들 중 누군가가 시험의 답을 알고있다는 꿀정보를 알려주었다. 하지만 안타깝게도 그 정보는 사실이 아니어서 선배들조차도 정답은 알지 못하고 다른 누군가가 알고 있을거 같다는 정보만 알고 있는 것이었다.\n한동이는 택민이에게 시험 정답을 물어보았다. 택민이는 답을 모른다고 했지만 택민이는 상준이가 답을 알고 있을 것 같다고 하였다. 그 후, 한동이는 상준이에게 물어보고 그리고...\n어느 순간 한동이는 아무리 이걸 해도 자신에게 도움이 되지 않는것을 깨닫고 굉장히 슬퍼졌다. 하지만 그는 이걸 함으로써 많은 선배들과 인맥을 쌓을 수 있고, 이게 언젠가 큰 도움이 될 것이라는 것을 깨달았다!\n당신의 목표는 한동이가 한 사람에게만 시험문제를 물어볼 수 있다고 할 때, 최대한 많은 선배들을 만날 수 있게 하기 위해서 누구에게 시험문제를 물어 볼 것인지를 알려주는 것이다.\n",
        "input_text": "입력의 첫 줄에는 정수 N이 주어진다. N은 2이상 1000 이하의 자연수이다. 선배들은 1부터 N까지 번호지어져 있다.\n다음 N줄에 하나의 숫자가 주어진다. 첫 번째 줄은 첫 번째 선배의 대답이고 두 번째 줄은 두 번째 선배의 대답이다. 이렇게 N번째 선배의 대답까지 입력이 주어진다.\n",
        "output_text": "첫째 줄에 한동이가 물어봐야 할 선배의 번호를 출력한다. 하나 이상의 정답이 있다면 번호가 작은 선배를 출력한다. \n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 695.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "343": {
        "problem_text": "일차원 좌표상의 점 N개와 선분 M개가 주어진다. 이때, 각각의 선분 위에 입력으로 주어진 점이 몇 개 있는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 점의 개수 N과 선분의 개수 M이 주어진다. (1 ≤ N, M ≤ 100,000) 둘째 줄에는 점의 좌표가 주어진다. 두 점이 같은 좌표를 가지는 경우는 없다. 셋째 줄부터 M개의 줄에는 선분의 시작점과 끝점이 주어진다. 입력으로 주어지는 모든 좌표는 1,000,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "입력으로 주어진 각각의 선분 마다, 선분 위에 입력으로 주어진 점이 몇 개 있는지 출력한다.\n",
        "memory_median": 2412.0,
        "time_median": 76.0,
        "length_median": 642.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "344": {
        "problem_text": "개미 N마리가 막대 위에 올라가 있다. 일부 개미는 왼쪽을 바라보고 있고, 나머지 개미는 오른쪽을 바라보고 있다. 모든 개미는 매우 작아서 크기가 없는 점으로 나타낼 수 있다. 시작 신호가 주어지면, 개미는 바라보고 있는 방향으로 행진을 시작한다. 모든 개미는 동일한 속도 초속 1mm로 이동한다. 두 개미가 한 점에서 충돌하는 경우가 발생할 수 있다. 이 경우에 두 개미는 행진하는 방향을 반대 방향으로 바꾸고, 행진을 계속하게 된다. 개미가 방향을 바꾸는데 걸리는 시간은 없다. 개미가 막대의 끝에 도착하는 경우에는, 막대에서 떨어지게 된다. 막대는 땅 위에 떠있다고 가정한다.\n처음에 모든 개미의 위치는 서로 다르다. 즉, 두 개미가 막대 위의 한 점에 같이 있는 경우는 없다. 개미는 부호 있는 정수로 나타낼 수 있다. 이 정수를 개미의 ID라고 한다. 개미의 ID의 부호는 개미가 처음에 바라보고 있는 방향이다. -는 왼쪽을 바라보고 있는 것이고, +는 오른쪽을 바라보고 있는 것이다. 개미의 ID의 절댓값은 1부터 109까지의 정수 중 하나이다. 또, 모든 개미의 ID의 절댓값은 서로 다르다. 아래 그림에는 개미가 총 6마리가 있고, ID는 {+4, +5, -1, -3, -2, +6}이다. 각 개미의 초기 위치는 {5, 8, 19, 22, 24, 25}이며, 막대의 길이 L = 30이다. 화살표는 처음에 개미가 바라보고 있는 방향을 나타낸다. 왼쪽 끝의 좌표는 0이고, 오른쪽 끝의 좌표는 30이다. ID가 +6인 개미는 시간 t = 5일 때, 막대의 오른쪽 끝에 도착하며, t = 6에 막대에서 떨어지게 된다.\n\n개미가 행진을 시작하기 전의 상태 (ID와 막대 상의 위치)가 주어진다. 두 개미가 동시에 막대의 양 끝에서 떨어지는 경우에는, ID가 작은 개미가 조금 더 먼저 떨어진다고 한다. 아래 그림은 이와 같은 경우를 나타낸 그림이다. 두 개미 {-1, +2}는 끝에 동시에 도착하게 된다. -1 < +2 이기 때문에, ID가 -1인 개미가 +2인 개미보다 조금 더 먼저 떨어지게 된다. 따라서, 아래 그림의 네 개미가 떨어지는 순서는 {-1, 2, 4, 3}이 된다.\n\n양의 정수 1 ≤ k ≤ n이 주어졌을 때, k번째로 떨어지는 개미를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 N, L, k가 주어진다. 다음 N개 줄에는 pi와 ai가 주어진다. ai는 개미의 ID이고, pi는 그 개미의 초기 위치이다. 항상 pi가 증가하는 순서로 (pi<pi+1) 주어진다. (1 ≤ pi ≤ L-1, 3 ≤ N ≤ 100,000, 10 ≤ L ≤ 5,000,000, 1 ≤ k ≤ N)\n",
        "output_text": "각 테스트 케이스마다, N마리 개미 중에서 k번째로 떨어지는 개미의 ID를 출력한다. 개미의 ID가 양수인 경우에 +를 출력하면 안 된다.\n",
        "memory_median": 3940.0,
        "time_median": 436.0,
        "length_median": 1173.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "345": {
        "problem_text": "M개의 우주가 있고, 각 우주에는 1부터 N까지 번호가 매겨진 행성이 N개 있다. 행성의 크기를 알고 있을때, 균등한 우주의 쌍이 몇 개인지 구해보려고 한다. 구성이 같은데 순서만 다른 우주의 쌍은 한 번만 센다.\n두 우주 A와 B가 있고, 우주 A에 있는 행성의 크기는 A1, A2, ..., AN, 우주 B에 있는 행성의 크기는 B1, B2, ..., BN라고 하자. 두 우주의 행성 크기가 모든 1 ≤ i, j ≤ N에 대해서 아래와 같은 조건을 만족한다면, 두 우주를 균등하다고 한다.\n\nAi < Aj → Bi < Bj\nAi = Aj → Bi = Bj\nAi > Aj → Bi > Bj\n\n",
        "input_text": "첫째 줄에 우주의 개수 M과 각 우주에 있는 행성의 개수 N이 주어진다. 둘째 줄부터 M개의 줄에 공백으로 구분된 행성의 크기가 한 줄에 하나씩 1번 우주부터 차례대로 주어진다.\n",
        "output_text": "첫째 줄에 균등한 우주의 쌍의 개수를 출력한다.\n",
        "memory_median": 8616.0,
        "time_median": 240.0,
        "length_median": 978.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "346": {
        "problem_text": "평면 위의 점의 집합이 주어졌을 때, 다각형을 만드는 프로그램을 작성하시오. 집합의 모든 점은 다각형의 꼭짓점이어야 하고, 집합에 없는 점을 다각형의 꼭짓점으로 가질 수 없다. 다각형의 두 선분은 연속하는 두 선분의 교점을 제외하고는 교차할 수 없다.\n예를 들어, 왼쪽 그림의 점으로 만든 다각형은 오른쪽과 같다.\n\n항상 문제의 조건을 만족하는 다각형만 입력으로 주어지며, 가능한 다각형이 여러 가지인 경우에는 아무거나 출력해도 된다. 두 점이 같은 위치에 있는 경우는 없으며, 모든 점이 한 직선위에 있는 경우는 없다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 c (1 ≤ c ≤ 200)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있다. 테스트 케이스의 첫 번째 숫자는 점의 개수 n (3 ≤ n ≤ 2000) 이다. 다음 숫자는 점의 좌표 x와 y이며, 좌표는 -10,000보다 크거나 같고, 10,000보다 작거나 같은 정수이다.\n",
        "output_text": "각 테스트 케이스마다 0부터 n-1까지 순열중 하나를 출력해야 한다. 출력하는 순열은 입력으로 주어지는 점의 번호를 나타내며, 출력하는 순서대로 점을 이었을 때, 올바른 다각형을 만들어야 한다.\n",
        "memory_median": 2156.0,
        "time_median": 12.0,
        "length_median": 1470.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "347": {
        "problem_text": "다각형의 두 선분이 연속하는 선분의 꼭짓점을 제외하고는 만나지 않는 다각형을 단순다각형이라고 부른다. 다각형의 각 변이 x축과 y축에 평행한 다각형을 직각다각형이라 부른다. 단순다각형이면서 직각다각형을 단순직각다각형이라 부른다. 아래 두 그림은 단순직각다각형의 예를 보여준다. \n\n단순직각다각형이 주어질 때, 수평선 H가 다각형의 수직선분과 몇 번 교차하는지 또는 수직선 V가 다각형의 수평선분과 몇 번 교차하는지 알고자 한다. 첫 번째 그림에서 수평선 H는 4개의 수직선분과 교차하고 수직선 V는 2개의 수평선분과 교차한다. 두 번째 그림은 첫 번째 그림에서 수평선 H의 위치를 조금 위로 옮긴 것으로 8개의 수직선분과 교차하게 된다. \n이때, 단순직각다각형과 가장 많이 교차하는 수평선 H와 수직선 V의 위치를 찾아 그때의 교차 횟수를 구하고자 한다. 단, 수평선 H는 다각형의 어떤 수평선분과도 겹처 놓여서는 안 되고, 유사하게 수직선 V는 다각형의 어떤 수직선분과도 겹쳐 놓여서는 안 된다.\n수평선 H의 위치를 잘 정해서 주어진 단순직각다각형의 수직선분과 가장 많이 교차하는 지점을 찾을 때, 그 때의 교차 횟수를 h라 하고, 유사하게 수직선 V와 주어진 단순직각다각형의 수평선분과 가장 많이 교차하는 횟수를 v라 할 때, max(h, v)를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "입력의 첫 줄에는 단순직각다각형의 꼭지점의 개수를 나타내는 정수 n(4 ≤ n ≤ 100,000)이 주어지고, 이어지는 n개 줄 각각에 단순직각다각형 꼭지점의 좌표 (xi, yi)가 차례대로 주어진다. 주어지는 꼭지점들의 순서는 시계방향이다. 다각형의 꼭지점을 나타내는 각 좌표값은 정수이며, -500,000 ≤ xi, yi ≤ 500,000이다.\n",
        "output_text": "max(h, v)를 출력한다.\n",
        "memory_median": 9964.0,
        "time_median": 8.0,
        "length_median": 1111.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "348": {
        "problem_text": "여러 개의 서로 다른 정수 S = {a1, a2, …, an} 와 또 다른 정수 K 가 주어졌을 때, S 에 속하는 서로 다른 두 개의 정수의 합이 K 에 가장 가까운 두 정수를 구하시오. 예를 들어, 10 개의 정수\nS = { -7, 9, 2, -4, 12, 1, 5, -3, -2, 0}\n가 주어졌을 때, K = 8 에 그 합이 가장 가까운 두 정수는 {12, -4} 이다. 또한 K = 4 에 그 합이 가장 가까운 두 정수는 {-7, 12}, {9, -4}, {5, -2}, {5, 0}, {1, 2} 등의 다섯 종류가 있다.\n여러 개의 서로 다른 정수가 주어졌을 때, 주어진 정수들 중에서 서로 다른 두 정수의 합이 주어진 또 다른 정수에 가장 가까운 두 정수의 조합의 수를 계산하는 프로그램을 작성하시오.\n",
        "input_text": "프로그램은 표준입력으로 입력을 받는다. 프로그램 입력은 t 개의 테스트 케이스로 구성된다. 입력의 첫 번째 줄에 테스트 케이스의 개수를 나타내는 정수 t 가 주어진다. 두 번째 줄부터 두 줄에 한 개의 테스트 케이스에 해당하는 데이터가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 두 개의 정수 n 과 K (2 ≤ n ≤ 1,000,000, -108 ≤ K ≤ 108 )가 한 개의 공백을 사이에 두고 입력된다. 두 번째 줄에는 n 개의 정수가 하나의 공백을 사이에 두고 주어지며, 각 정수의 최댓값은 108 이고, 최솟값은 -108 이다. 잘못된 데이터가 입력되는 경우는 없다.\n",
        "output_text": "출력은 표준출력(standard output)을 사용한다. 입력되는 테스트 케이스의 순서대로 다음 줄에 이어서 각 테스트 케이스의 결과를 출력한다. 각 테스트 케이스의 출력되는 첫 줄에 입력으로 주어진 n 개의 정수들 중에서 서로 다른 두 정수의 합이 주어진 또 다른 정수 K 에 가장 가까운 두 정수의 조합의 수를 출력한다.\n",
        "memory_median": 6048.0,
        "time_median": 416.0,
        "length_median": 914.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "349": {
        "problem_text": "민우는 학창시절 승부욕이 강해서 달리기를 할 때에도 누가 가장 빠른지를 중요하게 생각하고, 시험을 볼 때에도 누가 가장 성적이 높은지를 중요하게 생각한다. 이번에 반에서 키를 측정하였는데, 민우는 마찬가지로 누구의 키가 가장 큰지 궁금해한다. 민우를 도와 가장 키가 큰 사람을 찾아보자.\n",
        "input_text": "입력은 여러개의 테스트케이스로 구성되어있다. 각 테스트케이스는 첫 번째 줄에 학생의 수 N (0 < N ≤ 50)이 주어지고, 이어서 N개의 줄에 각 학생의 이름과 키가 공백으로 구별되어 주어진다. 학생의 이름은 알파벳 대/소문자로만 이루어져 있고, 길이는 10을 넘지 않는다. 학생의 키는 소숫점 이하 2자리까지 주어진다. N이 0으로 주어지는 경우 프로그램을 종료한다.\n",
        "output_text": "각 테스트케이스에 대해, 가장 키가 큰 학생의 이름을 한 줄에 출력한다. 같은 키의 사람이 여러명 일 경우 모두 출력해야 하며, 순서는 입력으로 들어온 순서를 유지해야 한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 655.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "350": {
        "problem_text": "제주 올레길 코스로 유명한 산책로가 있다. 산책로의 입구는 산책로에서 가장 서쪽에 위치하고 있다. 이 산책로는 단순 경로이며 수평 구간과 수직 구간으로만 구성되어 있어 모든 코너에서 90도 각도로 왼쪽 또는 오른쪽으로 회전만 할 수 있다. 또한 입구에서 출구 방향으로 걸어갈 때 동쪽에서 서쪽으로 이동을 전혀 하지 않아도, 즉, 보행자의 현재 위치를 나타내는 좌표의 x축 값이 작아지는 경우가 없이도 출구까지 도달할 수 있다. 그래서 이 산책로를 모노톤길이라고 부른다. 그림 1은 모노톤길의 예를 보여준다.\n\n그림 1. 모노톤길의 예\n이 산책로에는 n개의 카페가 곳곳에 들어서 있다. 특히 입구와 출구, 그리고 모든 코너에는 카페가 들어서 있다. 올레길 코스 관리자인 김씨는 이 산책로에 들어서 있는 모든 카페들의 위치 좌표를 가지고 있다. 입구 좌표는 항상 원점 (0,0) 이다. 그는 이들 카페에 1부터 n까지의 일렬 번호를 붙이려고 한다. 입구의 카페는 1번, 그 다음부터는 길을 따라가면서 만나는 순서대로 번호를 배정한다. 입구에서 출구로 갈 때, 카페 A를 카페 B보다 먼저 만나게 된다면, A에는 B보다 더 작은 번호를 배정한다. 따라서 그림 1의 산책로에서 좌표 (3,1)에 위치한 카페의 번호는 5이고, 좌표 (9,0)에 위치한 카페는 14번이고, 출구의 카페는 17번이다. 그는 산책로를 직접 걷지 않고 카페의 좌표들만으로 이 작업을 수행하고 싶어 한다. 그를 도와서 카페에 번호를 붙이는 작업을 수행하는 프로그램을 작성하시오.\n",
        "input_text": "입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 테스트 데이터의 개수 T가 정수로 주어진다. 각 테스트 데이터의 첫 번째 줄에는 카페의 수를 나타내는 정수 n (2 ≤ n ≤ 100,000)이 주어진다. 그 다음 n개의 줄에는 각 줄마다 각 카페의 좌표 (x,y)를 나타내는 두 개의 정수 x와 y가 주어진다. (0 ≤ x ≤ 100,000, -100,000 ≤ y ≤ 100,000). 입구 좌표는 항상 (0,0)이다. 어떤 두 카페도 동일한 좌표를 가지는 경우는 없다. 마지막 줄에는 정수 m (1 ≤ m ≤ 10)과 m개의 정수가 주어진다. m개의 각 정수는 1 이상 n 이하로서 카페의 번호를 나타낸다.\n",
        "output_text": "출력은 표준출력을 사용한다. 각 테스트 데이터에 대해, 카페 번호로서 주어진 m개의 정수에 대한 답을 순서대로 한 줄에 하나씩 출력한다. 정수 k에 대한 답은 번호가 k인 카페의 좌표 (x,y)를 나타내는 두 개의 정수 x와 y이다.\n",
        "memory_median": 4156.0,
        "time_median": 1924.0,
        "length_median": 1285.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "351": {
        "problem_text": "세계적인 석유 재벌 \"규현 조 압둘 티크리티 안드레스 후세인 리오넬 솔레르 살라 마리우 두스 산투스 펠리스 빈 자이드 술탄 친나왓 뱅거 7세\"는 1등 상품으로 페라리를 걸고 프로그래밍 대회를 개최했다. 이 대회의 참석자는 총 N명이고 각각 솔루션 파일 1개를 제출했다. 이 솔루션 파일을 F1, F2, ..., Fn이라고 한다.\n채점 결과를 발표하기 전에, 남의 것을 배낀 사람이 있는지 찾아내려고 한다. 이 대회의 주최측은 두 파일을 비교해서 너무 비슷한지 아닌지 판별하는 프로그램이 있다.\n하지만, 제출한 파일의 개수가 너무 많아서, 모든 쌍을 검사한다면, 2012년 지구가 멸망할 때 까지도 검사를 해야할 판이다. 따라서, 파일 크기가 너무 다른 경우에는 그러한 쌍을 검사하지 않고 넘어가기로 했다.\n좀더 정확하게 하기 위해서, 대회의 심판들은 두 파일이 있을 때, 작은 파일의 크기가 큰 파일 크기의 90%보다도 작을 때는, 이러한 쌍은 검사하지 않고 넘어가기로 했다. 따라서, (Fi, Fj) 쌍을 검사해야 하는데, 이때, i≠j이고, size(Fi) ≤ size(Fj)이면서, size(Fi) ≥ 0.9 × size(Fj)인 쌍만 검사하려고 한다.\n몇 개의 쌍을 검사해야 하는 지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 제출한 솔루션의 개수 N이 주어진다. 둘째 줄에는 각 솔루션 파일의 크기 size(F1), size(F2), ..., size(FN)이 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ size(Fi) ≤ 100,000,000) 솔루션 파일의 크기는 정수이다.\n",
        "output_text": "첫째 줄에 검사해야 하는 파일의 개수를 출력한다.\n",
        "memory_median": 2412.0,
        "time_median": 28.0,
        "length_median": 564.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "352": {
        "problem_text": "동혁이는 크로스워드 퍼즐을 좋아한다. R×C 크기의 크로스워드 퍼즐을 생각해 보자. 이 퍼즐은 R×C 크기의 표로 이루어지는데, 퍼즐을 다 풀면 금지된 칸을 제외하고는 각 칸에 알파벳이 하나씩 적혀 있게 된다. 아래는 R = 5, C = 5 인 경우 다 푼 퍼즐의 한 예이다. 검은 칸은 금지된 칸이다.\n\n세로 또는 가로로 연속되어 있고, 더 이상 확장될 수 없는 낱말이 퍼즐 내에 존재하는 단어가 된다. 위의 퍼즐과 같은 경우, 가로 낱말은 good, an, messy, it, late의 5개가 있고, 세로 낱말은 game, one, sit, byte의 4개가 있다. 이 중 사전식 순으로 가장 앞서 있는 낱말은 an이다.\n다 푼 퍼즐이 주어졌을 때, 퍼즐 내에 존재하는 모든 낱말 중 사전식 순으로 가장 앞서 있는 낱말을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 퍼즐의 R과 C가 빈 칸을 사이에 두고 주어진다. (2 ≤ R, C ≤ 20) 이어서 R개의 줄에 걸쳐 다 푼 퍼즐이 주어진다. 각 줄은 C개의 알파벳 소문자 또는 금지된 칸을 나타내는 #로 이루어진다. 낱말이 하나 이상 있는 입력만 주어진다.\n",
        "output_text": "첫째 줄에 사전식 순으로 가장 앞서 있는 낱말을 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1118.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "353": {
        "problem_text": "국제 카누 경주 챔피언십 (International Canoe Sprint Championship : ICSC)가 머지 않아 개막된다. ICSC에서 인증하는 공식 보트는 C1, C2 그리고 C4로 구성되며, \"C\"는 카누를 그리고 숫자는 노를 젓는 사람의 수를 의미한다. 카누 경주는 잔잔한 물 위의 여러개로 구획된 직선 코스에서 이루어진다. ICSC에서는 국제 경기를 200m, 500m 그리고 1000m로 구분하고 있다.\n\n한국 스포츠 학교(Korea Sports School : KSS)는 ICSC 의 C4 1000m 경기에 참가할 예정이다. KSS에는 같은 수의 학생으로 구성된 4개의 반을 가지며, 각 반에서 1명씩을 선출하여 경기에 참가한다. KSS에는 다수의 C4 보트를 가지고 있으며 각 보트는 선수들의 몸무게 합이 특정 값에 근사할 때 최대의 성과를 낼 수 있다. 예를 들어 특정 값이 300이고 각 반의 학생들의 몸무게가 아래와 같다고 하자.\n\nClass-1: 60, 52, 80, 40\nClass-2: 75, 68, 88, 63\nClass-3: 48, 93, 48, 54\nClass-4: 56, 73, 49, 75\n\n각 반에서 차례로 60,75,93 그리고 73 학생을 선택하게 되면 몸무게 합이 301으로 300에 가장 근사하게 된다. 몇몇의 경우에는 두개의 근사값이 나올 수 있다. 예를 들어 특정 값이 200일 때, 몸무게의 합이 198과 202가 나올 수 있으며 이러한 경우에는 더 작은 값이 카누 게임 진행에 더 적합하다. 따라서 몸무게의 합이 198인 학생들이 선택받게 된다.\n보트의 특정값과 학생들의 몸무게가 주어졌을때, 위의 조건을 만족하는 4명의 학생을 선택하시오.\n",
        "input_text": "이 문제에서는 입력은 표준 입력을 사용한다. 입력의 첫 줄에는 T개의 테스트 케이스가 주어진다. 각 테스트 케이스에는 두 개의 정수 k와 n이 주어지며, k( 1 ≤ k ≤ 40,000,000)는 보트의 특정 값 그리고 n( 1 ≤ n ≤ 1,000 )은 KSS 각 반의 학생수이다.\n이어지는 4개의 줄에 차례로 각 반의 학생들의 몸무게가 n개씩 주어진다. 이때 몸무게는 1에서 10,000,000까지이다.\n",
        "output_text": "출력은 표준 출력을 이용한다. 각 테스트 케이스에 해당하는 값을 한 줄에 출력한다. 해당 줄에는 카누 선수로 지목된 학생들의 몸무게의 총합이 포함되어 있어야 한다.\n",
        "memory_median": 14292.0,
        "time_median": 1580.0,
        "length_median": 1443.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "354": {
        "problem_text": "국렬이는 모르고리즘 차기 회장을 빠르게 구해야 한다. 안 그러면 대학원 가서도 회장을 해야 하기 때문이다.\n그래서 국렬이는 어떻게든 2020년 연세대학교 프로그래밍 경진대회를 열어서 차기 회장을 선택하려고 했으나, 코로나19 때문에 미루고 결국 11월에 개최하게 되었다.\n국렬이는 대회를 치른 사람 중에서 점수가 가장 높은 사람을 억지로 차기 회장으로 지목하려고 한다. 만약에 가장 높은 사람이 2명 이상 있는 경우, 이름이 사전 순으로 가장 앞선 사람을 차기 회장으로 뽑을 것이다.\n차기 회장으로 누가 지목될지 알아내라.\n",
        "input_text": "다음과 같이 입력이 주어진다.\nN\nA1 B1\r\n. . . . . .\nAN BN\n",
        "output_text": "첫째 줄에 차기 회장으로 뽑힐 사람의 이름을 출력하여라.\n",
        "memory_median": 5936.0,
        "time_median": 84.0,
        "length_median": 507.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "355": {
        "problem_text": "경인지역 6개대학 연합 프로그래밍 경시대회 shake! 는 아주대학교, 경희대학교, 성균관대학교, 인하대학교, 한국항공대학교, 한양대학교ERICA가 함께하는 대학교 자체 연합 대회이다. shake! 는 매년 1등 학생에게 사과북 프로 레티나를 비롯하여 5등까지 상장과 상품을 수여하고 있다.\n2018년 올해는 특별히 세계 최고 에듀테크 기업인 ST Unitas와 함께한다. 스텔라(STELLA)는 ST Unitas의 인공지능 사원이다. 인간을 동경하는 스텔라는 최대한 많은 학생에게 혜택이 돌아가지 못하는 점을 늘 안타까워하였다. 혜택을 주기위해 많은 고민을 거듭하던 스텔라는 ST Unitas의 전설적인 “스카이에듀 치킨 기프티콘“ 전략을 읽어보고 감명을 받아 이를 따라하기로 결심하였다. 너무 많은 치킨으로 회사에 큰 피해를 주면 안 되기에, 스텔라는 대회의 5등과 푼 문제 수는 같지만 패널티 차이로 수상하지 못한 학생들에게만 치킨 기프티콘을 보내주고자 한다.\n아쉽게도 2018년의 최신기술로도 인공지능 사원이 직접 프로그래밍을 할 수는 없어서, 여러분들이 스텔라를 도와주어야 한다. shake! 순위는 아래와 같은 방식으로 정해진다고 할 때, 스텔라가 몇 개의 기프티콘을 구매해야 하는지 알아보자.\n\n각 참가자는 해결한 문제 개수와 패널티 총합을 가진다.\n해결한 문제의 개수가 더 많은 참가자가 더 높은 순위를 가진다.\n해결한 문제의 수가 같을 때, 패널티 총합이 더 작은 참가자가 더 높은 순위를 가진다.\n\n",
        "input_text": "첫 줄에 참가자의 수 N(5 ≤ N ≤ 66)이 주어진다. 이후 N개의 줄에 걸쳐 각 참가자가 해결한 문제 개수와 패널티 총합이 주어진다. 각 참가자가 해결한 문제의 개수는 8개보다 작거나 같은 음이 아닌 정수이며 패널티 총합은 100,000보다 작거나 같은 음이 아닌 정수이다. 5등 학생은 적어도 한 문제 이상을 해결하였음이 보장되며, 한 문제 이상을 푼 학생 중 문제 수와 패널티가 모두 같은 학생은 존재하지 않는다.\n",
        "output_text": "한 줄에 5등과 해결한 문제 개수가 같지만 수상하지 못하는 학생의 수를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 584.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "356": {
        "problem_text": "평면에 n개의 점이 있다. 그중 두 개 이상의 점을 지나면서 x축 또는 y축에 평행한 직선이 몇 개인지 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 각 점의 좌표가 주어진다. 같은 좌표가 여러 번 주어질 수 있으며, 그런 경우 서로 다른 점으로 간주한다. 좌표는 절댓값이 231보다 작은 정수이다.\n",
        "output_text": "첫째 줄에 답을 출력한다.\n",
        "memory_median": 5180.0,
        "time_median": 80.0,
        "length_median": 602.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "357": {
        "problem_text": "화학 제국의 왕 성준이는 계속되는 이웃나라의 침범으로부터 자유로워지기 위해 자국의 자랑 화학 방벽을 건설하기로 마음먹었다. 이 방벽은 근처에 다가오는 생명체에게 해로운 독성을 내뿜어서 더이상 다른 나라들이 얼씬도 못하게 만들 것이다!\n그러나 이 방벽은 만들기 까다롭기에 가능한 한 적게 지어야 하며, 자국민들에게도 악영향을 끼칠 수 있으므로 자국의 모든 건물들로부터 L 이상의 거리를 유지해야만 한다.\n자국의 건물들의 좌표가 주어졌을 때, 모든 건물들로부터 L 이상의 거리를 두면서 모든 건물을 한번에 두르는 방벽의 최소 길이를 구하시오.\n",
        "input_text": "첫 번째 줄에 건물의 수 N과 거리 L이 주어진다. (3 ≤ N ≤ 1000, 1 ≤ L ≤ 1000, N과 L은 정수)\n다음 N개의 줄에 거쳐 건물의 좌표 Xi와 Yi가 정수로 주어진다. (-10000 ≤ Xi, Yi ≤ 10000) 모든 건물의 좌표는 다르며, 건물은 충분히 작아서 점과 같다고 생각해도 좋다. 방벽은 자신들끼리 교차해서는 안 되며 끊어져서도 안 된다.\n",
        "output_text": "첫째 줄에 답을 정수 단위로 반올림하여 출력한다.\n",
        "memory_median": 2170.0,
        "time_median": 0.0,
        "length_median": 1780.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "358": {
        "problem_text": "\n택시 거리는 바둑판 모양의 도로망을 가진 도시에서 점 A에서 B까지의 최단 거리를 구할 경우 도로를 따라서만 가는 가장 짧은 거리를 뜻한다.\n위의 사진에서는 빨간색 선이 택시거리이다. 즉, 점 A의 좌표가 (x1, y1)이고 점 B의 좌표를 (x2, y2)라고 했을 때, 두 장소 사이의 택시 거리 D는 다음과 같다.\n\\(D = |x_2 - x_1| + |y_2 - y_1|\\)\n인접한 0과 0, 0과 1, 1과 1 사이의 거리를 1이라고 할 때, 두 1 사이의 거리를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 줄엔 문자열의 높이 N과 가로 M이 주어진다. (2 ≤ N, M ≤ 1,000) 이다.\n두 번째 줄부터 M개의 숫자 0또는 1이 예제 입력과 같이 N개의 줄에 걸쳐 입력된다.\n1는 항상 두 개만 입력된다.\n",
        "output_text": "주어진 숫자들에서 1과 1사이의 택시 거리를 구하시오.\n",
        "memory_median": 2020.0,
        "time_median": 60.0,
        "length_median": 489.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "359": {
        "problem_text": "작도왕인 재원이는 밖에 신나게 뛰어놀다 집에 들어왔는데, 할 일이 없어서 작도를 하기로 했다. 재원이는 먼저 종이에 삼각형 ABC를 그렸다. 그리고, 각 BAC의 이등분선과 변 BC의 교점을 M이라고 했다.\n변 AB의 길이 c와 변 AC의 길이 b가 주어질 때, (선분 BM의 길이)÷(선분 CM의 길이)의 값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 c, b의 값이 사이에 공백을 한 개 두고 차례대로 주어진다. (c와 b의 값은 1,000,000,000 이하의 양의 정수이다.)\n",
        "output_text": "첫째 줄에 문제에서 요구한 답을 출력한다. 절대/상대 오차는 10-6 까지 허용한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 167.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "360": {
        "problem_text": "민호와 강호가 2차원 좌표 평면 위에 있다. 민호는 점 A(Ax, Ay)에서 점 B(Bx, By)를 향해 걸어가고 있고, 강호는 점 C(Cx, Cy)에서 점 D(Dx, Dy)를 향해 걸어가고 있다. 민호와 강호는 동시에 출발하고, 민호가 점 B에 도착하는 순간 강호도 점 D에 도착한다. 또, 두 사람은 항상 일정한 속도로 걸어간다. 두 사람의 거리가 가장 가까울 때, 거리를 구하는 프로그램을 작성하시오.\n두 점 (x1, y1), (x2, y2)사이의 거리는 \\(\\sqrt{(x2-x1)^2 + (y2-y1)^2}\\) 이다.\n",
        "input_text": "첫째 줄에 Ax, Ay, Bx, By, Cx, Cy, Dx, Dy가 주어진다. 입력으로 주어지는 모든 좌표는 0보다 크거나 같고, 10000보다 작거나 같은 정수이다.\n",
        "output_text": "민호와 강호가 가장 가까웠을 때의 거리를 출력한다. 절대/상대 오차는 10-6까지 허용한다.\n",
        "memory_median": 2032.0,
        "time_median": 0.0,
        "length_median": 1091.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "361": {
        "problem_text": "입력으로 주어진 선분과 직사각형이 교차하는지 아닌지를 구하는 프로그램을 작성하시오.\n\n위의 그림에서 선분의 시작점은 (4,9), 끝점은 (11,2) 이며, 직사각형의 왼쪽 위 좌표는 (1,5), 오른쪽 아래 좌표는 (7, 1)이다. 또, 선분과 직사각형은 교차하지 않는다.\n선분과 직사각형이 교차하려면 적어도 한 점을 공유해야한다. 입력으로 주어지는 좌표는 모두 절댓값이 50보다 작거나 같은 정수이지만, 교점은 정수 좌표가 아닐 수도 있다. 직사각형의 넓이는 0일 수도 있다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, xstart ystart xend yend xleft ytop xright ybottom로 이루어져 있다. (xstart, ystart)는 선분의 시작점, (xend, yend)는 선분의 끝점이고, (xleft, ytop)는 직사각형의 한 쪽 모서리 좌표, (xright, ybottom)는 직사각형 반대쪽 모서리 좌표이다.\nxleft ytop xright ybottom 은 직사각형의 왼쪽, 오른쪽, 위, 아래 좌표를 의미하는 것은 아니며, 변수명은 우연의 일치이다.\n",
        "output_text": "각 테스트 케이스마다 선분과 직사각형이 교차하면 'T'를, 교차하지 않으면 'F'를 한 줄에 하나씩 출력한다. 선분의 두 점이 사각형 내부에 있을 때도 'T'이다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 2003.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "362": {
        "problem_text": "승현이는 방학을 맞아 심심하지만, 공부는 하기 싫습니다. 이렇게 방 안에서 하루하루 시간을 낭비하던 중, 승현이는 자신의 직육면체 모양의 지우개에 개미 한 마리가 붙어 있다는 것을 알게 됩니다. 사실 이 개미는 우리가 문제를 어떻게 낼 지 잘 몰라서 방에 넣은 로봇입니다.\n\n이 개미 로봇은 말도 안 되지만 어떠한 시련이 닥쳐도 서로 반대편에 위치한 점 A에서 점 B까지 최단 거리로 이동하며 그 경로를 지우개에 그립니다. 누군가 자신의 지우개에 흔적을 남기는 것을 너무나 싫어하는 승현이는 개미 로봇이 자신의 지우개에 남긴 흔적의 양, 즉 로봇이 이동한 거리를 구하여 우리에게 손해 배상 청구를 하려고 합니다. 개미 로봇은 부피가 존재하지만, 승현이는 정확한 양을 측정하기 귀찮기 때문에 그냥 부피가 없다고 처리하기로 했습니다.\n우리에게 복수하고 싶어하는 승현이를 도와줍시다.\n",
        "input_text": "첫 줄에 테스트 케이스의 수 T가 주어집니다. (1 ≤ T ≤ 100,000)\n각 테스트 케이스마다 한 줄에 하나씩 음이 아닌 정수 a, b, c가 공백을 사이로 두고 주어집니다. 여기서 a는 지우개의 가로의 길이, b는 지우개의 세로의 길이, c는 지우개의 높이를 나타냅니다. (1 ≤ a, b, c ≤ 105)\n",
        "output_text": "각 테스트 케이스마다 한 줄에 하나씩 개미 로봇이 이동한 거리를 출력합니다. 단 꼼꼼한 승현이는 오차가 생기는 것을 원하지 않으므로, 이 거리의 제곱을 출력해야 합니다.\n",
        "memory_median": 2016.0,
        "time_median": 56.0,
        "length_median": 390.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "363": {
        "problem_text": "3차원 좌표 평면 위에 선분 하나와 점 하나가 있다. 선분의 양 끝점은 A(Ax, Ay, Az)와 B(Bx, By, Bz)로 나타낼 수 있다. 점의 좌표는 C(Cx, Cy, Cz) 이다.\n선분과 점 사이의 거리의 최솟값을 구하는 프로그램을 작성하시오.\n두 점 (x1, y1, z1)과 (x2, y2, z2) 사이의 거리는 \\(\\sqrt{(x2-x1)^2+(y2-y1)^2+(z2-z1)^2}\\) 이다.\n",
        "input_text": "첫째 줄에 선분과 점의 좌표 Ax, Ay, Az, Bx, By, Bz, Cx, Cy, Cz가 주어진다. 좌표는 0보다 크거나 같고, 10,000보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 선분과 점 사이의 거리의 최솟값을 출력한다. 절대/상대 오차는 10-6까지 허용한다.\n",
        "memory_median": 2032.0,
        "time_median": 0.0,
        "length_median": 1141.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "364": {
        "problem_text": "한때 굉장히 유행하고 유명했던 게임, PLAYERJINAH’S BOTTLEGROUNDS는 FPS(First-Person Shooter) 장르의 게임이다. 전 세계적으로 많은 사람을 열광시킨 이 게임은 영화 Bottle Royale 을 모티브로 만들어졌다. 영화 Bottle Royale 에서는 한 학급의 학생들을 한 섬에 가두고, 그들에게 각자 병을 지급한 뒤, 단 한 명의 승자가 남을 때까지 서로 병 던지기를 시키는 내용이 나온다. 이 게임은 그와 비슷하게 100명의 플레이어가 각자 거대한 수송기에서 낙하산으로 낙하하여 한 명의 승자가 남을 때까지 진행된다.\n이 게임을 즐기는 진아는 굉장한 실력의 게이머로서, 그녀의 실력은 화면 속의 적을 동시에 3명까지 맞춰 쓰러뜨릴 정도로 잘한다. 대신에 그녀가 제 실력을 발휘하기 위해선 한 가지 조건이 있다. 그건 적들이 진아의 화면 속에서 직선으로 있을 때만 동시에 쓰러뜨릴 수 있다는 것인데, 몇 번의 승부로 이를 알아챈 준서는 BOTTLEGROUNDS 대회에서 진아를 쓰러뜨리고 우승하기 위해 같은 스쿼드의 팀원들과 특훈을 시작했다. 특훈 내용은 상대방의 화면 속에서 각자의 위치가 직선이 안 되도록 포지션을 잡는 것이다. 준서는 이 연습을 위해서 당신에게 현재 팀원들의 상대방 화면 속 위치들이 직선이 되는지를 판별하는 기계를 만들어 달라고 요청했다. 당신에게 의뢰비로 대회 상금의 30%를 약속했기 때문에 당신은 흔쾌히 제안을 수락했다. 이제 그들에게 전달할 기계의 프로그램을 만들어 보도록 하자.\n\n화면 속 아군 위치의 예시. 이 경우 팀원들은 직선상에 위치한다.\n",
        "input_text": "프로그램의 입력은 표준 입력으로 받는다. 스쿼드는 총 4명으로 구성되며 준서는 멀리서 저격을 하기 때문에 좌표가 주어지지 않는다. 따라서 첫 번째 줄부터 세 번째 줄까지 x, y (1 ≤ x, y ≤ 1000) 두 개의 자연수가 각각 주어진다. 각 줄의 x, y는 한 명의 팀원이 상대방 화면에서 어떤 위치인지 나타낸다. 그리고 팀원들은 항상 서로 다른 위치에 있다.\n",
        "output_text": "프로그램의 출력은 표준 출력으로 한다. 팀원의 위치가 직선이 될 때 ‘WHERE IS MY CHICKEN?’ 을, 아닌 경우 ‘WINNER WINNER CHICKEN DINNER!’ 를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 503.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "365": {
        "problem_text": "평면상에 n개의 점 (P1, .... ,  Pn) 이 놓여져있다고 했을 때, 거리가 최소인 두 개의 점을 구하고 그 거리를 알고 싶다.\n",
        "input_text": "입력은 첫 번째 줄에 정수로 된 점의 개수 n이 주어진다.\n두 번째 줄부터 n+1번째 줄까지 2개의 정수 x,y가 공백을 사이에 두고 주어진다. \ni+1번째 줄은 Pi 의 x,y 좌표를 의미하고 n개의 점에 대해서 주어지게 된다.\n점의 개수는 2 ≦ n ≦ 500000 , 좌표의 범위는 -10000 ≦ x,y ≦10000로 주어진다.\n또한, 모든 점의 좌표는 같은 것이 없이 다른 것으로 한다.\n",
        "output_text": "가장 가까운 두 점 사이의 거리의 제곱을 출력하시오.\n",
        "memory_median": 8180.0,
        "time_median": 308.0,
        "length_median": 1472.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "366": {
        "problem_text": "평면 위에 여러 개의 검정 점과 흰 점이 있다. 이때, 길이가 무한대인 직선을 그어 흰 점과 검은 점을 분리하려고 한다. 직선은 어떤 점과도 만나면 안 된다. 직선으로 인해서 나누어지는 두 그룹 중 한 그룹에는 흰 점만 있어야 하고, 다른 그룹에는 검은 점만 있어야 한다.\n아래 그림에서 제일 왼쪽 예제는 점선으로 표시된 직선으로 두 점을 나눌 수 있다. 하지만 나머지 예제는 직선으로 점을 분리할 수 없다.\n\n흰 점과 검은 점의 좌표가 주어졌을 때, 직선으로 점을 분리할 수 있는지 없는지를 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에 검정 점의 개수 n과 흰 점의 개수 m이 공백으로 구분되어 주어진다. n과 m은 100보다 작거나 같다. 다음 줄부터 n개의 줄에는 검정 점의 좌표가 공백으로 구분되어 주어진다. 그 다음 m개의 줄에는 흰 점의 좌표가 주어진다.\n모든 점의 x, y좌표는 0보다 크거나 같고, 10000보다 작거나 같은 정수이다. 또한, 같은 위치에 점이 2개 이상 있는 경우는 없다.\n",
        "output_text": "각각의 테스트 케이스에 대해서, 점을 문제의 설명대로 분리할 수 있으면 YES를, 아니면 NO를 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 8.0,
        "length_median": 3655.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "367": {
        "problem_text": "Alex is fond of origami — Japanese art of paper folding. Most origami designs start with a square sheet of paper. Alex is going to make a present for his mother. Present’s design requires three equal square sheets of paper, but Alex has only one rectangular sheet. He is able to cut out squares of this sheet, but their sides should be parallel to the sides of the sheet. Help Alex to determine the maximum possible size of the paper squares he is able to cut out.\n",
        "input_text": "The single line of the input file contains two integers h and w — the height and the width of the sheet of paper (1 ≤ h, w ≤ 1000).\n",
        "output_text": "Output a single real number — the maximum possible length of the square side. It should be possible to cut out three such squares of h × w sheet of paper, so that their sides are parallel to the sides of the sheet.\nYour answer should be precise up to three digits after the decimal point.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 343.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "368": {
        "problem_text": "2차원 평면 위에 N개의 도시가 있다. 일부 도시는 특별한 도시이다. (r1, c1)에 있는 도시에서 (r2, c2)에 있는 도시로 가는 이동 시간은 |r1 - r2| + |c1 - c2|와 같다. 만약, 두 도시가 특별한 도시라면, 텔레포트를 이용해서 이동할 수도 있다. 텔레포트에 걸리는 시간은 T이다.\n두 도시의 쌍 M개가 주어졌을 때, 최소 이동 시간을 구해보자.\n",
        "input_text": "첫째 줄에 도시의 수 N, 텔레포트하는데 걸리는 시간 T가 주어진다.\n둘째 줄부터 N개의 줄에 도시의 정보를 의미하는 세 정수 s, x, y가 1번 도시부터 N번 도시까지 순서대로 주어진다. s가 1인 경우에는 특별한 도시라는 의미이고, 0인 경우는 특별한 도시가 아니라는 의미이다. (x, y)는 도시의 좌표이다.\n다음 줄에는 M이 주어지고, 다음 M개의 줄에는 두 도시 A와 B가 주어진다. \n",
        "output_text": "총 M개의 줄에 걸쳐서 A에서 B에 가는 최소 이동 시간을 출력한다.\n",
        "memory_median": 5916.0,
        "time_median": 700.0,
        "length_median": 1281.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "369": {
        "problem_text": "오버워치에 빠진지도 어언 6개월. 50점에서 시작한 경쟁전 점수는 어느새 35점까지 내려와 버렸다. 알고리즘을 공부하느라 게임 실력이 떨어졌다고 생각한 규현이는 오버워치 경쟁전 점수를 올리기 위해 새로운 캐릭터 파라를 선택하여 연습을 시작하였다. 포화 개시! 처음 사격을 시작한 규현이의 파라는 형편없는 명중률을 보여주었지만, 곧이어 모든 미사일이 적의 로봇을 명중시키는 놀라운 결과를 얻어내었다. 파라를 계속 연습하던 규현이는 파라가 미사일을 쏘는 순간, 알고리즘 능력이 발휘되어 그 장면이 머릿속에서 좌표평면으로 그려졌다. \n\n규현이의 파라는 (0,0) 의 위치에 있으며, 궁극기를 사용할 시 미사일을 적의 모든 로봇에게 동시에 직선으로 발사하여 맞춘다. 미사일의 날아가는 속도가 미사일마다 모두 달라 더 멀리 있는 적을 가까이 있는 적보다 더 빨리 맞출 수도 있게 된다. 알고리즘의 늪에서 빠져나올 수 없었던 걸까? 규현이는 적이 미사일에 격추되는 순서를 구하는 프로그램을 만들려고 한다. 규현이를 도와 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N이 주어진다. N은 100,000보다 작거나 같은 수이다.\n둘째 줄부터 총 N개의 줄에는 Xi, Yi, Vi 가 주어진다. 이는 i번째 로봇의 x, y 좌표와 미사일이 이 로봇을 향해 날아가는 속도를 의미한다. (|Xi, Yi|≤10,000, 0＜Vi ≤1,000)\n입력값이 주어지는 대로 로봇이 나타난 순서를 의미하며, 맨 처음 나타난 로봇부터 1, 2, 3, ..., N번째 로봇으로 지정한다. x좌표와 y좌표가 같은 곳에 로봇이 2개 이상 존재하는 경우는 없다.\n",
        "output_text": "로봇이 격추되는 순서를 한 줄에 하나씩 출력한다. 동시에 격추되는 경우 더 작은 로봇의 번호를 먼저 출력한다.\n",
        "memory_median": 5108.0,
        "time_median": 60.0,
        "length_median": 566.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "370": {
        "problem_text": "선영이는 쓰레기를 편하게 버리기 위해서 빌딩에 쓰레기 슈트를 만들었다. 쓰레기 슈트는 빌딩에 설치할 수 있는 속이 빈 튜브다. 튜브로 쓰레기를 떨어뜨리면, 쓰레기는 지하실까지 떨어지게 된다.\n쓰레기 슈트를 만드는 일은 매우 어려운 일이다. 사람들이 무엇을 버릴지 알 수 없기 때문에, 쓰레기 슈트에 들어가지 않는 쓰레기를 버린다면, 슈트가 막혀버릴 수 있기 때문이다. 쓰레기 슈트를 만드는데 드는 비용은 그 크기에 비례한다. 따라서, 최대한 작게 만드는 것이 효율적이다.\n먼저, 쓰레기 슈트를 만드는 문제를 2차원으로 단순화 시켜보자. 슈트는 일정한 너비를 가지고 있고, 다각형으로 모델링된 물체를 이 곳의 상단에 넣을 수 있다.\n물체를 넣기 전에, 슈트에 들어갈 수 있게 돌려야 할 수도 있다. 슈트에 던진 이후에는 일직선으로 아래로 떨어지고, 그 동안 물체는 회전하지 않는다.\n아래 그림은 물체를 쓰레기 슈트에 들어갈 수 있게 회전시킨 다음 버리는 그림이다.\n\n어떤 물체가 주어진다. 이 물체가 통과할 수 있는 가장 작은 슈트의 너비를 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 물체(다각형)의 꼭짓점의 개수 n이 주어진다. (3 ≤ n ≤ 100)\n다음 n개 줄에는 꼭짓점의 좌표 xi와 yi가 주어진다. (0 ≤ xi, yi ≤ 104) 꼭짓점은 다각형을 이루는 순서대로 주어진다. \n입력으로 주어지는 다각형의 좌표는 모두 서로 다르며, 다각형의 변은 교차하지 않는다. 엄밀히 따지면, 인접한 변은 한 꼭짓점을 공유한다는 예외가 하나 있다. 물론, 이 경우는 교차하는 것으로 생각하지 않는다.\n마지막 테스트 케이스의 다음 줄에는 0이 하나 주어진다.\n",
        "output_text": "각 테스트 케이스마다 케이스 번호와 가장 작은 쓰레기 슈트의 너비를 출력한다. 너비는 가장 가까운 0.01의 배수로 올림하여 소수점 둘째 자리까지 출력한다.\n",
        "memory_median": 2036.0,
        "time_median": 4.0,
        "length_median": 2354.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "371": {
        "problem_text": "소들의 반란이 있은 뒤, 이 소들은 포로로 잡은 인간들을 감시해야 했다. 소들은 (Px, Py)의 위치에 감옥을 짓고, 감옥 둘레에 가능한 한 여러 겹으로 담을 쌓아 포로들이 도망가기 힘들도록 하려 한다. 감옥은 하나의 점으로 표현된다.\n이러한 목적을 달성하기 위해, 소들은 감옥 주변에 N개의 담 기둥을 세웠다. 각각의 담은 감옥을 완전히 감싸야 하고, 담 안에 (부분적으로라도) 포함되는 담이 있다면 이러한 담도 완전히 감싸야 한다. 즉, 담벼락이 교차하거나 한 점에서 만나서는 안 된다. 감옥과 담 기둥 중 어느 세 점도 일직선상에 있지 않다.\n이러한 담 기둥들이 주어졌을 때, 겹치지 않는 최대의 중첩된 담의 겹 수를 구하는 프로그램을 작성하시오.\n담은 여러 개의 담벼락이 연결된, 닫힌 다각형을 의미하고, 각각의 담벼락의 두 끝 점은 담 기둥 이어야 한다. 이러한 담 사이에는 반드시 약간이라도 공간이 있어야 한다. 즉, 서로 다른 두 담이 하나의 담벼락이나 담 기둥을 공유해서는 안 된다.\n",
        "input_text": "첫째 줄에 N(1 ≤ N ≤ 1,000), Px, Py (-100,000 ≤ Px, Py ≤ 100,000)이 주어진다. 다음 N개의 줄에는 차례로 담 기둥의 좌표가 주어진다. 각각의 좌표는 절댓값이 100,000을 넘지 않는 정수이다.\n",
        "output_text": "첫째 줄에 최대 겹 수를 출력한다.\n",
        "memory_median": 2126.0,
        "time_median": 4.0,
        "length_median": 2226.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "372": {
        "problem_text": "정수좌표를 갖는 점을 격자점이라고 한다. 격자 다각형은 모든 꼭짓점이 격자점으로 이루어진 다각형이다.\n만약, 다각형의 두 꼭짓점을 잇는 모든 선분이 다각형 내부(또는 경계)에 있다면, 이 다각형을 볼록 다각형이라고 한다. 즉, 다각형의 내부각이 모두 180도 보다 작은 것이다.\n격자점으로 이루어진 집합 S가 주어졌을 때, S의 모든 격자점을 포함하는 가장 작은 볼록 (격자) 다각형을 컨벡스 헐이라고 한다. 컨벡스 헐의 꼭짓점은 모두 S에 포함된 격자점이어야 한다. 만약, 모든 점이 같은 일직선 상에 있다면, 컨벡스 헐은 선분이 될 것이다. (오른쪽 그림)\n아래 그림에서 집합에 포함된 점은 굵은 점으로, 컨벡스 헐의 꼭짓점은 X로, 변은 선분으로 나타낸 그림이다.\n\n격자 다각형의 꼭짓점의 일반적인 순서는 다음과 같다.\n\n첫 번째 꼭짓점은 y좌표가 가장 큰 점이다. 만약, 그러한 점이 2개라면, x가 작은 점이 첫 번째 점이다.\n그 다음 점부터는 시계방향 순서이다.\n\n격자점의 집합이 주어졌을 때, 컨벡스 헐을 일반적인 순서로 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 P(1 ≤ P ≤ 1000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 집합에 포함된 격자점의 수 N(3 ≤ N ≤ 50)이 주어진다. 나머지 줄은 집합에 포함되어 있는 격자점의 좌표가 한 줄에 5개씩 주어진다. (마지막 줄은 이보다 적을 수 있다) 모든 점은 x와 y좌표가 순서대로 주어지며, 공백으로 구분되어 있다. 좌표는 절댓값이 20보다 작거나 같은 정수이다.\n",
        "output_text": "각 테스트 케이스에 대해서, 첫째 줄에는 컨벡스 헐에 포함된 점의 수를 출력한다. 그 다음 줄부터 컨벡스헐에 포함된 격자점을 한 줄에 하나씩 일반적인 순서대로 출한다. x와 y를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1791.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "373": {
        "problem_text": "원 이동하기 2 문제를 만들고 만든 데이터가 문제의 조건에 맞는지 확인하는 코드를 작성해야한다.\n해당 문제의 데이터는 아래 조건들을 만족해야한다.\n\n모든 원의 중심 좌표는 $x$축 위에 존재해야 한다.\n$N$개의 원 중 임의의 두 원을 선택했을 때, 교점이 존재하지 않아야 한다. 즉, 하나의 원이 다른 원 안에 존재하거나 외부에 존재한다.\n\n데이터 형식은 원의 개수 $N$이랑 각 원의 중심 $x$좌표, 원의 반지름 $r$만 주어진다. 따라서, 2번 조건을 만족하는지만 확인하면 된다.\n주어진 데이터가 해당 조건을 만족하는지 확인해보자.\n",
        "input_text": "첫 번째 줄에는 원의 개수 $N$이 주어진다.\n두 번째 줄부터 $N+1$번째 줄까지 원의 중심 $x$좌표, 원의 반지름 $r$이 공백으로 구분되어 주어진다.\n",
        "output_text": "데이터가 조건에 맞는다면 YES, 조건에 만족하지 않는다면 NO를 출력한다.\n",
        "memory_median": 11252.0,
        "time_median": 68.0,
        "length_median": 912.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "374": {
        "problem_text": "수진이는 외심과 내심 없이는 살 수 없다고 말할 정도로 외심과 내심을 사랑한다. 하지만, 갑자기 수진에게 어려운 일이 닥쳤다. 바로 평면에 있는 삼각형 ABC에서 외접원의 반지름의 길이 R이고, 내접원의 반지름의 길이 r일 때, (외심과 내심 사이의 직선 거리)2의 값을 구하는 것이다. 수진이가 포기를 하면, 외심과 내심을 더 이상 사랑하지 않을 수도 있기 때문에, 우리가 수진이를 도와주는 프로그램을 작성하자!\n",
        "input_text": "첫째 줄에 R과 r의 값이 사이에 공백을 한 개 두고 차례대로 주어진다. (단, R과 r의 값은 100,000 이하의 양의 정수이고, 2×r ≤ R을 만족한다.)\n",
        "output_text": "첫째 줄에 (외심과 내심 사이의 직선 거리)2의 값의 정수 부분을 출력한다. (단, 어떤 수의 정수 부분은 그 수를 넘지 않는 최대의 정수를 말한다.)\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 147.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "375": {
        "problem_text": "직사각형의 정보를 저장할 클래스 Rectangle을 구현하시오.\n\nC++14, C++17\r\n\t\n클래스 이름: Rectangle\n생성자\n\nRectangle(width, height): 직사각형의 가로 길이를 width, 세로 길이를 height 설정한다. width는 1,000보다 작거나 같은 자연수, height는 2,000보다 작거나 같은 자연수이다.\n\n\n멤버 변수\r\n\t\t\nint width: 직사각형의 가로 길이\nint height: 직사각형의 세로 길이\n\n\n멤버 함수\r\n\t\t\nint get_width() const: 직사각형의 가로 길이를 리턴한다.\nint get_height() const: 직사각형의 세로 길이를 리턴한다.\nvoid set_width(int width): 직사각형의 가로 길이를 width로 변경한다. 만약, width가 0보다 작거나 같거나, 1,000보다 크면 변경하지 않는다.\nvoid set_height(int height): 직사각형의 세로 길이를 height로 변경한다. 만약, height가 0보다 작거나 같거나, 2,000보다 크면 변경하지 않는다.\nint area() const: 직사각형의 넓이를 리턴한다.\nint perimeter() const: 직사각형의 둘레 길이를 리턴한다.\nbool is_square() const: 정사각형이면 true, 아니면 false를 리턴한다.\n\n\n\n\n\n",
        "input_text": "",
        "output_text": "",
        "memory_median": 4452.0,
        "time_median": 8.0,
        "length_median": 794.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "376": {
        "problem_text": "\n때때로 주어진 점들 사이에서 볼록 껍질(Convex Hull)을 찾아내는 기술은 요긴하게 쓰인다. ACM 월드파이널에서 볼록 껍질을 응용해야 하는 문제가 출제되다 보니, 이걸 할 줄 아는 것은 참가자의 소양이 되었다.\n이 작업은 크게 두 단계의 과정으로 이루어진다. 첫 번째 단계는 볼록 껍질을 이루는 점들을 찾아내는 것이고, 두 번째 단계는 이 점들을 반시계 방향으로 순서를 매기는 것이다. 첫 번째 단계는 이미 완료되었다고 할 때, 두 번째 단계를 수행하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에는 점의 개수 n이 주어진다. (3 <= n <= 100,000)\n두 번째 줄부터 n개의 줄에 걸쳐 각 점에 대한 정보 x, y, c가 주어진다. x, y는 정수이며 절댓값이 1,000,000,000을 넘지 않고, c는 Y 또는 N인 문자이다. Y는 이 점이 볼록 껍질에 속해있음을, N이면 아님을 의미한다.\n중복되는 점은 없으며, 모든 점이 한 직선 위에 있는 경우도 없다.\n",
        "output_text": "첫 번째 줄에 볼록 껍질을 이루는 점의 개수를 출력한다.\n이어서 한 줄에 하나씩 그 점들의 좌표를 x y 형태로 출력하는데, 이 점들은 반시계 방향으로 순서를 이루어야 한다. 첫 번째 좌표는 x좌표가 가장 작은 점이어야 하며, 만약 그런 좌표가 여러 개라면 그 중에서 y좌표가 가장 작은 점을 선택한다.\n",
        "memory_median": 5724.0,
        "time_median": 52.0,
        "length_median": 1532.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "377": {
        "problem_text": "장난꾸러기 혁주는 어렸을 때부터 가위를 아주 잘 다루었다. 그래서 그는 색종이를 가위로 아무렇게나 자르는 것을 좋아한다. 혁주는 오늘 친구에게 원 모양의 색종이를 생일 선물로 받았다. 그가 색종이를 자르려는 순간, 어떤 친구가 \"가위로 자를 때는 정확한 직선으로 자르면 더 깔끔해!\"라고 했다. 그래서 혁주는 가위로 정확히 직선으로 두 번을 자르기로 했다. 예를 들어, 혁주는 아래와 같이 색종이를 자른다. (단, 한 번 자른 뒤, 색종이를 움직이지 않고 다시 한 번 자른다.)\n\n이때, 영역 a와 b를 구분하는 선분의 길이를 pab, b와 c를 구분하는 선분의 길이를 pbc, c와 d를 구분하는 선분의 길이를 pcd라고 한다. pab, pbc, pcd의 값이 주어지면, 영역 d와 a를 구분하는 선분의 길이를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 pab, pbc, pcd의 값이 사이에 공백을 한 개씩 두고 차례대로 주어진다. 주어지는 모든 값들은 10,000 이하의 양의 정수이다.\n",
        "output_text": "첫째 줄에 영역 d와 a를 구분하는 선분의 길이를 출력한다. 절대/상대 오차는 10-6 까지 허용한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 190.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "378": {
        "problem_text": "Your friend to the south is interested in building fences and turning plowshares into swords. In order to help with his overseas adventure, they are forced to save money on buying fence posts by using trees as fence posts wherever possible. Given the locations of some trees, you are to help farmers try to create the largest pasture that is possible. Not all the trees will need to be used.\nHowever, because you will oversee the construction of the pasture yourself, all the farmers want to know is how many cows they can put in the pasture. It is well known that a cow needs at least 50 square metres of pasture to survive.\n",
        "input_text": "The first line of input contains a single integer, n (1 ≤ n ≤ 10000), containing the number of trees that grow on the available land. The next n lines contain the integer coordinates of each tree given as two integers x and y separated by one space (where −1000 ≤ x, y ≤ 1000). The integer coordinates correlate exactly to distance in metres (e.g., the distance between coordinate (10, 11) and (11, 11) is one metre).\n",
        "output_text": "You are to output a single integer value, the number of cows that can survive on the largest field you can construct using the available trees.\n",
        "memory_median": 2224.0,
        "time_median": 4.0,
        "length_median": 1620.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "379": {
        "problem_text": "All the cool kids in town want to become a member of the Bots and Androids Programmer Club (BAPC). To become a member of the club, applicants must show a feat of their skills with a home-made robot that is programmed to perform some tricks. Just like your older brother, you want to become a member of the BAPC, so it's time to lock yourself in the hobby basement and start building some robots!\nSince your older brother has used up almost all of the parts for his own projects at the BAPC, you will have to get creative with whatever is still left. You find a robotic arm that has only a single purpose: fitting circle-shaped objects into square-shaped holes. Not exactly what you had in mind, but it will have to do. After all, you only have five hours left to apply for your BAPC membership.\nThe memory chip of the robotic arm seems to be wiped, but luckily you do know the programming interface of its ARM processor. Firstly, the robotic arm only supports integer coordinates. Secondly, when the arm picks up a circle-shaped object, you need to calculate the smallest possible square that it could fit the object in, after which it will autonomically find a suitable square-shaped hole.\nGiven the location of a circle-shaped object, calculate the smallest possible square which encloses the object.\n",
        "input_text": "The input consists of:\n\nOne line containing two integers $x$ and $y$ ($-10^9\\leq x,y\\leq 10^9$), the coordinates of the center of the circle.\nOne line containing one integer $r$ ($1\\leq r\\leq 10^9$), the radius of the circle.\n\n",
        "output_text": "Output four lines, each line containing two integers, representing the $x$- and $y$-coordinates of one of the corners of the square. The coordinates should be printed in either clockwise or counter-clockwise order.\nIf there are multiple valid solutions, you may output any one of them.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 318.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "380": {
        "problem_text": "Фермер Джон прокопал прямолинейную канаву длиной $2 \\cdot n$ метров. Затем от середины канавы прокопал под углом $\\alpha$ к предыдущей короткую канаву длиной $n$ метров, после чего соединил концы канав изгородями. \nНайдите величину угла между изгородями у конца короткой канавы.\n\n",
        "input_text": "Первая строка содержит одно целое число $n$ ($1 \\le n \\le 1000$). Вторая строка содержит целое число $\\alpha$ --- величину угла между канавами в градусах ($0 < \\alpha < 180$).\n",
        "output_text": "Выведите одно целое число --- величину угла у конца короткой канавы в градусах, округлённую до ближайшего целого числа.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 150.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "381": {
        "problem_text": "성규는 학점이 높고 알고리즘도 잘 다루는 편이라 매년 알고리즘 대회에 나가 수상을 해오곤 한다. 성규의 꿈은 대학교 4학년 칼졸업을 하고 나서 좋은 대기업에 취직하여 빨리 돈을 버는 것이다.\n어느 날, 성규는 전공 수업을 들으러 강의실에 가서 책을 펴고 앉았다. 이 때 교수님이 수업을 시작하시기 전에 한 말씀 하셨다.\n교수님: \"음... 여기서 내가 눈 여겨 봐온 학생이 있는데... 그래, 성규야. 너 내 랩실에 들어올 생각 없니? 나와 함께 알고리즘에 대한 논문이나 써보자꾸나.\"\n성규는 큰일이다 싶었다. 성규는 졸업하고 싶었다. 대답을 할 생각이 떠오르기 전에 먼저 도망가야겠다는 생각이 들어버렸다!\n강의실에는 가로로 N 행, 세로로 N 열, 총 N × N 개의 책상이 있으며, 위쪽에서부터 R 번째 행, 왼쪽에서부터 C 번째 열에 있는 책상의 위치를 (R, C)로 표현한다. 각 책상 자리는 비어있거나, 성규가 아닌 학생 혹은 성규가 앉아있거나, 교수님이 위치해 있다.\n도망가는 데 성공하려면, 성규와 교수님의 거리가 5 이상이면서, 교수님과 성규를 꼭짓점으로 하는 축에 평행한 직사각형 안에, 교수님을 제지해줄 성규가 아닌 학생이 세 명 이상 있어야 한다.\r\n단, 교수님과 성규가 같은 행 혹은 같은 열의 책상에 앉아있다면 교수님과 성규를 잇는 선분 상에 성규가 아닌 학생이 세 명 이상 있어야 한다.\n이때, 책상 (a, b)와 책상 (c, d) 간의 거리는 $\\sqrt{(a-c)^2 + (b-d)^2}$로 정의한다.\n성규는 도망가다가 잡히는 것이 최악이라 판단되어, 도망갈 수가 없는 환경이면 순순히 대학원생의 길로 들어서려고 한다. 이런 성규를 위해 확실히 도망갈 수 있는지 알려주는 프로그램을 작성하자.\n",
        "input_text": "입력의 첫 번째 줄에 자연수 N(7 ≤ N ≤ 1,000) 이 주어진다.\n두 번째 줄부터 N개의 각 줄에 0, 1, 2, 5 중 하나의 숫자가 공백으로 구분되어 N개씩 주어진다.\nN개의 줄 중 R번째 줄의 C번째 숫자가 d라는 것은 다음과 같은 의미를 가진다:\n\nd = 0: 책상 (R, C)는 빈 자리이다.\nd = 1: 책상 (R, C)는 성규가 아닌 학생이 앉아있다.\nd = 2: 책상 (R, C)는 성규가 앉아있다.\nd = 5: 책상 (R, C)는 교수님이 앉아있다.\n\n성규와 교수님은 겹치지 않으며, 각각 정확히 한 자리에만 앉아있다.\n",
        "output_text": "첫 번째 줄에 성규가 교수님에게서 도망칠 수 있으면 1, 그렇지 못하면 0을 출력한다.\n",
        "memory_median": 5936.0,
        "time_median": 92.0,
        "length_median": 967.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "382": {
        "problem_text": "영선이는 이번에 편의점으로 창업을 하려고 계획 중이다. 이번 창업을 위해 많은 준비를 하고 있는데, 아직 편의점을 세울 위치를 결정을 하지 못했다. 영선이는 미리 시장조사를 하여, 주요 고객들이 어느 위치에 존재하는지 파악을 하였고, 모든 고객들의 거리의 합을 최소로 하려한다. 두 위치의 거리는 |x1-x2|+|y1-y2|로 정의한다.\nn명의 주요 고객들의 위치 (xi,yi)이 주어질 때, 모든 고객들의 거리 합을 최소로 하는 위치에 편의점을 세울 때, 그 최소 거리 합을 출력하시오.\n",
        "input_text": "첫째 줄에는 주요 고객들의 수n이 주어진다.(1≤n≤100,000)\n다음 n줄에는 고객들의 위치 (x,y)가 주어진다.(-1,000,000≤x,y≤1,000,000)\n",
        "output_text": "모든 고객들의 거리 합을 최소로 하는 위치에 편의점을 세울 때, 그 최소 거리 합을 출력하시오.\n",
        "memory_median": 2804.0,
        "time_median": 40.0,
        "length_median": 608.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "383": {
        "problem_text": "N(1 ≤ N ≤ 100)마리의 들쥐들과 M(1 ≤ M ≤ 100)개의 땅굴이 있다. 각각의 들쥐는 2차원 평면상의 한 위치에 있고, 각각의 땅굴들도 2차원 평면상의 한 점에 위치한다.\n들쥐들을 잡아먹는 매가 들쥐들을 습격했을 때, 쥐들은 매를 피하기 위해서 땅굴 속으로 숨을 수 있다. 모든 쥐들이 땅굴에 숨을 수 있다면 매에 잡아먹히는 쥐가 한 마리도 없겠지만, 각각의 땅굴에는 한 마리의 쥐만 들어갈 수 있을뿐더러 매가 도착하는 시간과 쥐들이 땅굴로 도망치는 속도가 있기 때문에 항상 모든 쥐들이 도망갈 수 있는 것은 아니다.\n매는 현재를 기준으로 S(1 ≤ S ≤ 100)초가 지난 후에 지상에 도착한다. 각각의 들쥐들은 매 초당 V(1 ≤ V ≤ 100)만큼의 거리를 움직인다(즉 V가 쥐들의 초속이다). 만약 S초가 되기 전에 들쥐가 땅굴에 도착하게 되면 그 들쥐는 땅굴로 숨을 수 있다. 단, 들쥐가 도착하는 시간이 정확히 S인 경우에도 그 들쥐는 도망칠 수 있는 것으로 간주한다.\n들쥐들은 종족 전체의 번영을 위해, 매에 잡아먹히게 되는 들쥐의 수가 최소가 되도록 도망치기로 하였다. 들쥐와 땅굴의 위치, 그리고 들쥐의 속도와 매가 도착하는 시간이 주어졌을 때, 잡아먹히게 되는 들쥐의 최소수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 네 정수 N, M, S, V가 주어진다. 다음 N개의 줄에는 들쥐의 x, y좌표가 주어지고, 그 다음 M개의 줄에는 땅굴의 x, y좌표가 주어진다. 모든 좌표는 절댓값이 1,000을 넘지 않는 실수이며 소숫점 셋째자리까지 주어질 수 있다.\n",
        "output_text": "첫째 줄에 잡아먹히게 되는 들쥐의 최솟값을 출력한다.\n",
        "memory_median": 2080.0,
        "time_median": 0.0,
        "length_median": 1294.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "384": {
        "problem_text": "There’s a pizza store which serves pizza in two sizes: either a pizza slice, with area A1 and price P1, or a circular pizza, with radius R1 and price P2. You want to maximize the amount of pizza you get per dollar. Should you pick the pizza slice or the whole pizza?\n",
        "input_text": "The first line of input will contain a single integer n that indicates the number datasets to follow. Each dataset is comprised of two lines. The first line contains two space-separated integers A1 and P1. Similarly, the second line contains two space-separated integers R1 and P2. It is guaranteed that all values are positive integers at most 103. We furthermore guarantee that the two will not be worth the same amount of pizza per dollar.\n",
        "output_text": "For each data set, print on a single line, either “Whole pizza” or “Slice of pizza” depending on which is the better deal.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 402.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "385": {
        "problem_text": "x축 위에 원이 N개 있다. 원은 서로 교차하지 않는다. 하지만, 접할 수는 있다.\n원으로 만들어지는 영역이 몇 개인지 구하는 프로그램을 작성하시오.\n영역은 점의 집합으로 모든 두 점은 원을 교차하지 않는 연속되는 곡선으로 연결될 수 있어야 한다.\n\n",
        "input_text": "첫째 줄에 원의 개수 N(1 ≤ N ≤ 300,000)이 주어진다.\n다음 N개 줄에는 각 원의 정보 xi와 ri가 정수로 주어진다. xi는 원의 중심 좌표이며, ri는 반지름이다. (-109 ≤ xi ≤ 109, 1 ≤ ri ≤ 109)\n입력으로 주어지는 원은 항상 유일하다.\n",
        "output_text": "첫째 줄에 원으로 인해서 만들어지는 영역의 개수를 출력한다.\n",
        "memory_median": 14960.0,
        "time_median": 120.0,
        "length_median": 1253.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "386": {
        "problem_text": "이제 사각형의 경계선과 선분의 교차점에 관한 간단한 기하 문제를 풀어볼 것이다.\n매우 다행히도 사각형은 항상 축에 평행한 형태로만 놓여 있다.\n어떤 사각형과 어떤 선분의 교차점은 항상 0개이거나, 1개이거나, 2개이거나, 무한하다.\n각각의 경우에 대한 몇 가지 예제는 아래와 같다.\n\n(a) 교점이 0개인 경우\n\n(b) 교점이 1개인 경우\n\n(c) 교점이 2개인 경우\n\n(d) 교점이 무한히 많은 경우\n",
        "input_text": "첫 줄에 테스트 케이스의 수 T가 주어진다.\n각 테스트 케이스는 4개의 정수로 시작한다. 각 정수는 xmin, ymin, xmax, ymax이며, 이것은 사각형의 왼쪽 아래 꼭짓점이 (xmin, ymin)이고 오른쪽 위 꼭짓점이 (xmax, ymax)임을 의미한다. (-10,000 ≤ xmin < xmax ≤ 10,000, -10,000 ≤ ymin < ymax ≤ 10,000) 그 다음 줄에도 4개의 정수 x1, y1, x2, y2가 주어진다. 이는 선분의 한쪽 끝점이 (x1,y1)이며 다른쪽 끝점이 (x2,y2)임을 의미한다. (-10,000 ≤ x1, y1, x2, y2 ≤ 10,000)\n선분의 길이는 항상 0보다 크다.\n",
        "output_text": "테스트 케이스마다 하나의 정수를 출력한다.\n만일 주어진 사각형과 선분의 교차점의 개수가 유한하다면 교차점의 개수를 출력하고, 교차점이 무한히 많다면 4를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 2512.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "387": {
        "problem_text": "\r\n\t창영이는 메모장에 '.', '\\', '/'을 이용해서 도형을 그렸다. 각 문자는 그림에서 1*1크기의 단위 정사각형을 나타낸다.\n\r\n\t'.'은 빈 칸을 나타내며, '/'는 정사각형의 왼쪽 아래 꼭짓점과 오른쪽 위 꼭짓점이 연결된 선분을, '\\'은 왼쪽 위 꼭짓점과 오른쪽 아래 꼭짓점이 연결된 선분을 나타낸다.\n\r\n\t창영이가 그린 도형의 넓이를 출력하는 프로그램을 작성하시오.\n\n\n",
        "input_text": "\r\n\t첫째 줄에 h와 w가 주어진다. h는 그림의 높이, w는 너비이다. (2 ≤ h,w ≤ 100)\n\r\n\t다음 h개 줄에는 창영이가 메모장에 그린 다각형이 주어진다. \n\r\n\t창영이가 그린 다각형은 1개이고, 변과 변이 서로 교차하는 경우는 없고, 자기 자신과 접하는 경우도 없다.\n",
        "output_text": "\r\n\t첫째 줄에 다각형의 넓이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 557.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "388": {
        "problem_text": "네 사람이서 2차원 평면상의 N개의 점을 이용해서 할 수 있는 놀이가 있다. 바로 각 사람이 1개씩의 점을 적절히 선택해서 변이 x축 혹은 y축에 평행한 직사각형을 만드는 일이다. 물론 그냥 만들면 재미가 없기 때문에 가로의 길이가 A 세로의 길이가 B인 직사각형을 몇 가지나 만들 수 있는지 알아보기로 했다.\n예를 들어 점이 A(0, 0), B(2, 0), C(0, 3), D(2, 3), E(4, 0), F(4, 3)의 6개가 있고, 만들고 싶은 직사각형이 가로가 2, 세로가 3인 직사각형이라면 (A, B, C, D), (B, D, E, F)의 두 가지 경우가 가능하다. 모든 경우의 수를 구해보자.\n",
        "input_text": "첫 줄에 점들의 개수 N(5 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에 만들고 싶은 직사각형의 가로 길이 A(1 ≤ A ≤ 1,000)와 세로 길이 B(1 ≤ B ≤ 1,000)가 주어진다. 다음 N줄에 걸쳐서 점들의 좌표가 정수로 주어진다. 이 값의 범위는 -1,000,000,000이상 1,000,000,000이하이다. N개 점들의 좌표는 각각 다르다.\n",
        "output_text": "첫 줄에 가능한 모든 경우의 수를 출력한다. 경우의 수는 231-1보다 작거나 같다.\n",
        "memory_median": 25520.0,
        "time_median": 548.0,
        "length_median": 722.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "389": {
        "problem_text": "Young Sean threw matches all over the floor of his room.\nHis mum did not like that and ordered him to put all the matches in a box. Sean soon noticed that not all of the matches on the floor fit in the box, so he decided to take the matches that don't fit and throw them in the neighbour's garbage, where his mum (hopefully) won't find them.\nHelp Sean determine which of the matches fit in the box his mom gave him. A match fits in the box if its entire length can lie on the bottom of the box. Sean examines the matches one by one.\n",
        "input_text": "The first line of input contains an integer N (1 ≤ N ≤ 50), the number of matches on the floor, and two integers W and H, the dimensions of the box (1 ≤ W ≤ 100, 1 ≤ H ≤ 100).\nEach of the following N lines contains a single integer between 1 and 1000 (inclusive), the length of one match.\n",
        "output_text": "For each match, in the order they were given in the input, output on a separate line \"YES\" if the match fits in the box or \"NO\" if it does not.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 299.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "390": {
        "problem_text": "평면 위에 N개의 점이 주어졌을 때, 가장 큰 정사각형의 넓이를 구하여라.\n\n",
        "input_text": "첫째 줄에 테스트케이스의 개수 T가 주어진다.\n각 테스트케이스의 첫째 줄에는 점의 개수 N(4 ≤ n ≤ 3,000)이 주어지고, 이어서 N개의 줄에는 점의 x좌표와 y좌표가 주어진다. 모든 좌표는 -10000 이상 +10000이하의 정수이다. 같은 위치의 점이 여러 번 주어지는 경우는 없다.\n",
        "output_text": "각 테스트 케이스마다 가장 큰 정사각형의 넓이를 한 줄에 하나씩 출력한다. 단, 정사각형이 없는 경우 0을 출력한다.\n",
        "memory_median": 2176.0,
        "time_median": 5468.0,
        "length_median": 1278.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "391": {
        "problem_text": "매달리기를 좋아하는 고양이 유미와 세 사람은 이차원 좌표평면 위에 있다. 좌표평면 상의 좌표는 (x, y)로 나타낼 수 있다. 유미는 세 사람 모두에게 안기려고 한다. 유미가 사람에게 안기려면 사람이 있는 위치로 이동해야 한다. 사람은 이동하지 않는다. 귀찮은 유미는 최단 거리로 세 사람에게 이동하려고 한다.\n예를 들어, 유미의 위치가 (0, 0) 세 사람의 위치가 각각 (1, 0), (2, 0), (4, 0)인 경우에, (0, 0) → (1, 0) → (2, 0) → (4, 0)으로 이동하면 최단 거리로 이동할 수 있다. 이때, 거리는 1 + 1 + 2 = 4이다.\n유미와 세 사람의 위치가 주어진다. 세 사람 모두에게 안기는 최단 거리를 구하시오.\n",
        "input_text": "첫째 줄에 유미의 위치, 둘째 줄부터 세 개의 줄에 사람의 위치가 한 줄에 하나씩 주어진다. 위치는 x, y좌표의 순서로 주어지며, 공백으로 구분되어져 있다. (-10 ≤ x, y ≤ 10)\n한 위치에 둘 이상의 사람이 있는 경우는 없고, 유미와 사람의 위치가 같은 경우도 없다.\n",
        "output_text": "첫째 줄에 유미의 최단 거리를 출력한다. 소수점 이하는 버리고 정수만 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 864.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "392": {
        "problem_text": "A right triangle or right-angled triangle is a triangle in which one angle is a\r\nright angle (that is, at 90 degrees angle). The largest side of such a triangle is called hypotenuse. The relation between the sides of the triangle is\nc2=a2+b2, Where c is the hypotenuse\nGiven 3 sides of a triangle, your task is to determine whether the given triangle is a right triangle or not. \n",
        "input_text": "The first line has a positive integer T, T <= 100000, denoting the number of test cases. This is followed by each test case per line. \nEach test case consists of a line containing 3 integers a,b and c denoting the sides of a triangle. All of these sides will be between 1 and 100, inclusive. The sides a,b and c can be given in any order. \n",
        "output_text": "For each test case, the output contains a line in the format Case #x: M, where x is the case number (starting from 1) and M is “YES” when the given triangle is a right triangle or “NO” otherwise. Note that the quotes are not required to be outputted. \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 439.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "393": {
        "problem_text": "KSA의 1학년 학생들은 매일 아침 졸업을 하기 위해 아침 태권도를 해야 한다.\n태권도장은 2차원 좌표평면으로 표현할 수 있고, 이때 사범님은 원점에 앉아있다. $N$명의 1학년 학생들은 $1$번부터 $N$번까지의 번호로 구분되며, $i$번 학생의 위치는 $(X_i, Y_i)$이다. 태권도 사범님은 $i$번 학생이 다른 학생에게 가려지지 않는 경우에만 볼 수 있다. 즉, 원점과 $(X_i, Y_i)$를 이어 선분을 만들었을 때, 선분 위에 위치한 다른 학생이 아무도 없을 때 사범님은 $i$번 학생을 볼 수 있다.\n1학년 학생들은 너무 공부를 많이 하여 매우 졸리기 때문에, 사범님에게 보이는 학생들만 태권도를 열심히 한다. 학생들의 위치 정보가 주어졌을 때, 태권도를 열심히 하는 학생들은 몇 명인지 구하시오.\n",
        "input_text": "첫 번째 줄에 정수 $N$이 주어진다.\n$i + 1$번째 줄에 두 정수 $X_i, Y_i$가 공백으로 구분되어 주어진다. $(1 \\leq i \\leq N)$\n",
        "output_text": "태권도를 열심히 하는 학생들은 몇 명인지 출력한다.\n",
        "memory_median": 11396.0,
        "time_median": 160.0,
        "length_median": 772.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "394": {
        "problem_text": "\n",
        "input_text": "입력은 없다.\n",
        "output_text": "주식회사 구대기의 위도 $\\phi$와 경도 $\\lambda$를 공백으로 구분해 출력한다.\n\n$\\phi$는 $-90$ 이상 $90$ 이하의 실수여야 하며, $\\phi<0$인 경우 남위 $\\left|\\phi\\right|$도를, $\\phi>0$인 경우 북위 $\\left|\\phi\\right|$도를 의미한다.\n$\\lambda$는 $-180$ 초과 $180$ 이하의 실수여야 하며, $\\lambda<0$인 경우 서경 $\\left|\\lambda\\right|$도를, $\\lambda>0$인 경우 동경 $\\left|\\lambda\\right|$도를 의미한다.\n출력하는 실수의 형식은 소수점 아래 $15$자리 이하의 자릿수를 갖는 십진수여야 한다.\n\n",
        "memory_median": 0.0,
        "time_median": 0.0,
        "length_median": 0.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "395": {
        "problem_text": "Farmer John would like to create a triangular pasture for his cows.\nThere are $N$ fence posts ($3\\le N\\le 100$) at distinct points $(X_1, Y_1) \\ldots (X_N, Y_N)$ on the 2D map of his farm. He can choose three of them to form the vertices of the triangular pasture as long as one of the sides of the triangle is parallel to the $x$-axis and another side is parallel to the $y$-axis.\nWhat is the maximum area of a pasture that Farmer John can form? It is guaranteed that at least one valid triangular pasture exists.\n",
        "input_text": "The first line of the input contains the integer $N$. Each of the next $N$ lines contains two integers $X_i$ and $Y_i$, each in the range $-10^4 \\ldots 10^4$ inclusive, describing the location of a fence post.\n",
        "output_text": "As the area itself is not necessarily an integer, output two times the maximum area of a valid triangle formed by the fence posts.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 775.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "396": {
        "problem_text": "2차원 평면상에 n개의 점이 주어졌을 때, 이 점들 중 가장 먼 두 점을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 자연수 n(2 ≤ n ≤ 100,000)이 주어진다. 다음 n개의 줄에는 차례로 각 점의 x, y좌표가 주어진다. 각각의 좌표는 절댓값이 10,000을 넘지 않는 정수이다. 여러 점이 같은 좌표를 가질 수도 있다.\n",
        "output_text": "첫째 줄에 가장 먼 두 점의 거리의 제곱을 출력한다.\n",
        "memory_median": 4376.0,
        "time_median": 40.0,
        "length_median": 2045.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "397": {
        "problem_text": "맨날 학교 칠판에 이등변삼각형을 그리고 노는 피카츄가 어느 날, 칠판에 변 AB와 변 AC의 길이가 모두 N인 이등변 삼각형을 그린 다음, 친구들에게 아래와 같은 문제를 냈다.\n\n이등변삼각형 ABC에서 변 BC 위에 점 P1, P2, ··· , PK을 잡는다. (B ≠ Pi ≠ C (i = 1, 2, ··· , K))\ni = 1, 2, ··· , K에 대하여 함수 F(i)를 (선분 APi의 길이)²+(선분 BPi의 길이)×(선분 CPi의 길이)로 정의한다.\n이때, F(1)+F(2)+···+F(K)의 값은 얼마인지 구하시오.\n\n피카츄의 친구들은 문제 조차도 이해를 못하고 있다! 우리가 대신해서 피카츄가 낸 문제를 해결해 보자.\n",
        "input_text": "첫째 줄에 N과 K의 값이 사이에 공백을 한 개 두고 차례대로 주어진다. 단, N과 K는 100,000 이하의 양의 정수이다.\n",
        "output_text": "첫째 줄에 문제에서 요구하는 정답을 x라고 할 때, x보다 크지 않은 최대의 정수를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 167.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "398": {
        "problem_text": "캠프가 시작된 지도 벌써 12일이 지났다. 이제 캠프의 반이 지났을 뿐인데, 학생들은 벌써 운동부족을 호소하고 있다.\n선생님은 학생들에게 달리기 시합을 시키기로 결정하고, 달리기 시합에서 1등을 한 사람은 훼밀리마트에 데려가기로 했다. 적절한 운동장을 찾고 있던 중, 숙소 근처에서 널찍한 운동장을 발견했다. 그 곳에는 가느다란 기둥이 N개 꽂혀 있었다.\n달리기 코스는 한 기둥에서 시작하여 다른 기둥까지 직선코스이고 코스 내에 다른 기둥이 포함되어도 상관하지 않는다. 학생들을 운동시키는 것이 이 시합의 목적이므로, 최대한 멀리 떨어져 있는 두 기둥으로 지표를 잡으려고 한다.\n이 숙소에서 나가 달리기를 하고 싶다면 이 문제를 풀어야 한다. N개의 기둥의 좌표가 주어졌을 때, 가장 멀리 떨어진 두 기둥 사이의 거리의 제곱을 출력하는 프로그램을 작성하라.\n",
        "input_text": "첫째 줄에 기둥의 개수 N(1 ≤ N ≤ 100,000)이 주어지고, 이어서 N줄에 걸쳐 각 기둥의 좌표를 나타내는 정수 두 개가 주어진다. 좌표의 절댓값의 범위는 50,000을 넘을 수 없다.\n",
        "output_text": "첫째 줄에 가장 먼 기둥 사이의 거리를 제곱하여 출력한다.\n",
        "memory_median": 5108.0,
        "time_median": 40.0,
        "length_median": 1998.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "399": {
        "problem_text": "양의 정수 n의 각 자리수의 제곱의 합을 계산한다. 그렇게 해서 나온 합도 각 자리수의 제곱의 합을 계산한다. 이렇게 반복해서 1이 나온다면, n을 상근수라고 한다.\n700은 상근수이다.\n\n72 + 02 + 02 = 49\n42 + 92 = 97\n92 + 72 = 130\n12 + 32 + 02 = 10\n12 + 02 = 1\n\n2는 상근수가 아니다.\n\n22 = 4\n42 = 16\n12 + 62 = 37\n32 + 72 = 58\n52 + 82 = 89\n82 + 92 = 145\n12 + 42 + 52 = 42\n42 + 22 = 20\n22 + 02 = 4\n42 = 16\n... 끝나지 않는다\n\n소수는 1과 자기자신을 제외하고 약수가 없는 수이다. 2, 3, 5, 7, 11, 13, 17, 19, ... 는 소수이다.\n소수상근수는 소수이면서 상근수인 숫자이다. 7, 13, 19, ... 는 소수 상근수이다.\nn이 주어졌을 때, n보다 작거나 같은 모든 소수상근수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 n (10 ≤ n ≤ 1000000)이 주어진다.\n",
        "output_text": "n보다 작거나 같은 소수상근수를 한 줄에 하나씩 오름차순으로 출력한다.\n",
        "memory_median": 4956.0,
        "time_median": 48.0,
        "length_median": 967.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "400": {
        "problem_text": "양의 정수 N과, N보다 큰 소수 P가 주어질 때, N!을 P로 나눈 나머지를 구하여라.\n",
        "input_text": "첫째 줄에 N과 P가 공백으로 구분되어 주어진다.\n",
        "output_text": "N!을 P로 나눈 나머지를 구하여라.\n",
        "memory_median": 2020.0,
        "time_median": 1472.0,
        "length_median": 261.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "401": {
        "problem_text": "창영이는 심심해서 혼자 재미 없는 게임을 하나 생각해냈다. 숫자 N을 먼저 정하고, 이 숫자를 2진법, 3진법, 4진법, ..., 100만진법, 100만 1진법 등등으로 바꾸어 보면서, 마지막자리에 연속된 0의 개수를 모두 더하는 것이다.\n예를 들어 N=5라면, 2진법 101, 3진법 12, 4진법 11, 5진법 10, 6진법 5, 7진법 5, ... 등과 같으므로 답은 1이 된다. 여러분이 할 일은 주어진 N에 대해서 창영이가 구한 답을 찾는 것이다. 정확히 설명하기 위해 수학식으로 쓰자면, f(N, b)를 N을 b진법으로 나타냈을 때 마지막에 따르는 연속된 0의 개수로 정의 할 때\n\\[\\sum_{b=2}^{\\infty}{f(N, b)}\\]\n를 구하는 것이다.\n",
        "input_text": "첫 줄에 테스트 케이스의 수 T가 주어진다. 다음 T줄에 걸쳐서 N이 주어진다.\n",
        "output_text": "각 줄에 위 수식에 대한 답을 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 184.0,
        "length_median": 428.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "402": {
        "problem_text": "성원이는 오늘 이산수학 수업 시간에 에라토스테네스의 체에 대해 배웠다. 에라토스테네스의 체는 고대 그리스 수학자 에라토스테네스가 발견한 소수를 찾는 방법이다. 성원이는 이 방법에 너무나 큰 감명을 받았고, 당장 실습실에 가서 C++로 구현해보기로 했다. 그런데 성원이는 교재도 없고 필기를 하는 성격도 아니기 때문에 수업내용이 정확히 기억나지 않았다. 성원이는 기억을 열심히 더듬어 마침내 아래와 같은 코드를 작성했다.\n\n옆에 앉아있던 킹갓제너럴엠페러충무공마제스티알고리즘마스터 형석이는 성원이의 이 코드를 보고 실소를 금할 수 없었다. 아니 대체 세상에 어떤 사람이 이딴 코드를 짠단 말이지? 형석이는 신이 나서 성원이에게 이 코드의 문제점을 마구 지적했다.\n\n형석 : 야 성원! 이거 알고리즘이 완전히 틀렸잖아! 여긴 이렇게저렇게 고쳐야지!\r\n성원 : 아 그렇구나... 알려줘서 정말 고마워.\r\n형석 : 게다가 이 코드는 수행시간도 더럽게 오래 걸리겠네.\r\n성원 : 그래? 내가 관심법으로 보면 왠지 $O(n)$에 돌아갈 것처럼 생겼는데?\r\n형석 : $O(n)$은 무슨 말도 안되는 소리야? 자 이거 봐. 수식을 이렇게저렇게 쓰면...\r\n형석 : 어라? 시간복잡도 증명이 잘 안 되네. 수학 공부를 너무 오랫동안 안 해서 그런가?\r\n성원 : IOI 금메달 킹갓제너럴알고리즘마스터도 이럴 때가 있구나.\r\n형석 : 시끄러! 그렇다면 내가 직접 연산횟수를 측정해서 $O(n)$이 아님을 보여주지.\n\n형석이는 위 코드의 연산횟수를 직접 측정해서 위 코드의 시간복잡도가 $O(n)$이 아님을 증명하려고 한다. 구체적으로 위 코드의 6번 줄이 몇 번 실행될지를 측정하고 그 데이터로 그래프를 그려 보여주려고 한다. 그런데 막상 직접 측정하려고 보니 이것은 매우 귀찮은 일이었다. 허접인 성원이때문에 내가 이 고생을 해야 한다니! 귀찮아진 형석이는 이 작업을 당신에게 떠넘겼다. 위 코드에서 n에 해당하는 값이 주어졌을 때, 위 코드의 6번 줄이 몇 번 실행될지를 계산하는 프로그램을 작성해서 형석이를 도와주자.\n",
        "input_text": "첫 번째 줄에 위 프로그램의 입력 n의 값이 자연수로 주어진다. (1 ≤ n ≤ 109)\n",
        "output_text": "첫 번째 줄에 위 프로그램의 6번 줄의 실행횟수를 출력한다.\n",
        "memory_median": 1996.0,
        "time_median": 0.0,
        "length_median": 414.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "403": {
        "problem_text": "A1, A2, …, AN으로 표시된 N 개의 카드를 정해진 방법으로 섞고자 한다. 그 섞는 방법은 1에서 N까지의 숫자로 이루어진 수열로 표시된다. 이 수열을 섞기 수열이라 하자. 섞기는 현재 가지고 있는 카드에서 섞기 수열의 각 숫자가 나타내는 위치에 있는 카드를 순서대로 뽑아서 나열하는 것이다. 예를 들어, N = 6이고 섞기 수열이 [3, 2, 5, 6, 1, 4]라고 하자. 카드의 처음 상태가 [A1, A2, A3, A4, A5, A6]일 때, 섞기를 한 번 실행하면 카드의 순서가 다음과 같이 된다.\n[A3, A2, A5, A6, A1, A4]\n이 상태에서 다시 한 번 섞기를 실행하면 카드의 순서가 [A5, A2, A1, A4, A3, A6]이 되고, 다시 한 번 더 섞기를 실행하면 카드의 순서가 [A1, A2, A3, A6, A5, A4]가 된다. 이렇게 섞기를 반복하면 카드의 순서가 처음 상태인 [A1, A2, A3, A4, A5, A6]이 된다. 처음 상태로 돌아 올 때까지 반복한 섞기의 최소 횟수를 주어진 섞기 수열의 궤적이라 한다. 임의의 섞기 수열이 주어졌을 때, 그 섞기 수열의 궤적을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 카드의 수 N이 주어진다. N은 1 이상 20,000 이하의 수이다. 두 번째 줄에 섞기 수열을 나타내는 N 개의 자연수가 빈칸을 사이에 두고 주어진다.\n",
        "output_text": "첫 번째 줄에 입력으로 주어진 섞기 수열의 궤적을 출력한다. 단, 궤적이 1 이상 2,000,000,000 이하인 입력만 주어진다.\n",
        "memory_median": 2144.0,
        "time_median": 4.0,
        "length_median": 746.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "404": {
        "problem_text": "가장 끝의 0의 개수가 M개인 N! 중에서 가장 작은 N을 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 M (1 ≤ M ≤ 100,000,000)이 주어진다.\n",
        "output_text": "가장 끝의 0의 개수가 M개인 N! 중에서 가장 작은 N을 출력한다. 그러한 N이 없는 경우에는 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 535.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "405": {
        "problem_text": "자연수 n이 주어졌을 때, gcd(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n 의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 자연수 n (1 ≤ n ≤ 1018)이 주어진다.\n",
        "output_text": "gcd(n, k) = 1을 만족하는 자연수 1 ≤ k ≤ n 의 개수를 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 20.0,
        "length_median": 2134.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "406": {
        "problem_text": "창영이는 방 청소를 하다가 자와 각도기를 발견했다. 다음날 창영이는 학교에 자와 각도기를 들고 갔고, 현우와 \"작도 대결\"을 하려고 한다.\n창영이는 각도기와 자를 이용해서 만들 수 있는 각을 알고 있고, 두 각을 합하거나 빼서 새로운 각을 만드는 방법을 알고 있다. 현우가 어떤 각도를 외치면, 창영이는 자와 각도기를 이용해서 현우가 외친 각도를 작도해야 한다. 작도할 때는 새로운 각을 이용해서 또다른 새로운 각을 만드는 것도 가능하다.\n현우가 외치는 각도를 창영이가 만들 수 있는지 없는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 창영이가 만드는 방법을 알고 있는 각의 수 N과 현우가 외친 각의 개수 K가 주어진다. (1 ≤ N, K ≤ 10)\n둘째 줄에는 창영이가 만들 수 있는 각이 주어진다. 모든 각도는 360보다 작다.\n셋째 줄에는 현우가 외친 각이 주어진다. 이 각도 360보다 작다.\n",
        "output_text": "현우가 외친 각도를 창영이가 만들 수 있다면 YES를, 없다면 NO를 입력으로 주어진 순서대로 한 줄에 하나씩 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 679.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "407": {
        "problem_text": "소수를 매우 좋아하는 수학자가 있다. 이 수학자는 매번 전화번호를 받을 때 마다, 그 전화번호가 소수인지 아닌지를 검사한다. 수학자는 자신의 모든 친구의 전화번호가 소수인지 아닌지를 기억하고 있다.\n계속해서 늘어나는 휴대전화 인구의 급증에 따라 정부는 한 자리를 기존 번호 앞에 붙이는 정책을 시행하기로 했다.\n수학자는 큰 고민에 빠졌다. 소수 전화번호를 가지고 있는 친구의 전화번호가 이제 평범한 숫자가 될 수도 있기 때문이다.\n수학자의 친구 중 한 사람의 원래 전화번호와 새로이 앞에 붙는 번호 한 자리가 주어졌을 때, 원래 전화번호와 새로운 전화번호가 모두 소수인지 아닌지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 여섯 자리의 기존 전화번호와 새로 추가되는 한 자리 번호가 주어진다. 기존 전화번호는 0으로 시작하지 않으며, 새로 추가되는 한 자리 번호는 0이 아니다.\n",
        "output_text": "원래 전화번호와 새로운 전화번호가 소수이면 Yes를, 아니면 No를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 444.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "408": {
        "problem_text": "In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn−1 + Fn−2 for n ≥ 2. For example, the first ten terms of the Fibonacci sequence are:\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . .\nAn alternative formula for the Fibonacci sequence is\n\\[\\begin{bmatrix} F_{ n+1 } & F_{ n } \\\\ F_{ n } & F_{ n-1 } \\end{bmatrix}=\\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^n\\]\nGiven an integer n, your goal is to compute the last 4 digits of Fn.\n",
        "input_text": "The input test file will contain multiple test cases. Each test case consists of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file is denoted by a single line containing the number -1.\n",
        "output_text": "For each test case, print the last four digits of Fn. If the last four digits of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print Fn mod 10000).\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 996.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "409": {
        "problem_text": "Good Bye BOJ, 2021!이 열리는 오늘, 12월 31일은 종서의 생일이다. $N$ 명의 친구들은 종서에게 생일 선물로 예쁜 케이크를 만들어주려 한다.\n여기에서, 예쁜 케이크는 다음과 같은 조건을 만족하는 케이크를 의미한다.\n\n케이크는 높이가 $1$이고, 부피가 $N$인 직육면체 모양이다.\n케이크를 적절히 칼질해서 한 변의 길이가 $1$인 정육면체 모양 조각 $N$ 개로 나눌 수 있어야 한다.\n케이크의 옆면에 가로 너비가 $1$인 직사각형을 이어 붙여 만든 띠를 딱 맞게 두를 수 있어야 한다.\n장식용 띠는 가로 폭이 $1$인 빨간색, 초록색, 하얀색 직사각형이 순서대로 번갈아 가면서 같은 개수만큼 나와야 한다.\n\n예를 들어, 아래 그림은 $N = 8$인 경우의 예쁜 케이크 중 하나와 그에 사용된 띠를 나타낸다.\n\n\n아쉽게도 $N$이 얼마인지에 따라 예쁜 케이크를 만들지 못 할 수도 있다. 종서의 친구들을 위해 부피가 $N$인 예쁜 케이크를 만들 수 있는지 알려주자.\n",
        "input_text": "첫 번째 줄에 전체 테스트 케이스의 개수를 나타내는 정수 $T$가 주어진다.\n이후 $T$ 개의 줄에 각각 문제에서 언급한 정수 $N$이 한 줄에 하나씩 주어진다.\n",
        "output_text": "$T$ 개의 줄에 걸쳐 한 줄에 하나씩 문제의 답을 출력해야 한다.\n부피가 $N$인 예쁜 케이크를 만들 수 있으면 TAK, 아니면 NIE를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 374.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "410": {
        "problem_text": "지난 번 헛간 청약의 당첨우(牛)가 발표됐다. 청약에 당첨된 소들은 날아갈 듯이 기뻐하다가 진짜로 하늘을 날았다. 하지만 이후로 소들은 날 수 없었다. 그러던 어느 날, 꿀벌에게 쏘이면 잠깐 하늘을 날 수 있다는 사실을 깨달았다. 이 사실이 퍼지자 소들은 다시 자유롭게 하늘을 날기 시작했다.\n소들이 하늘을 날며 우(牛)통사고가 빈번해지자, 농부 존은 소들이 하늘을 나는 것에 제한을 두었다. 소들은 항의했지만 소들의 항의는 받아들여지지 않았다.\n농장에는 $N$마리의 소가 있다. 농부 존은 소들의 몸무게의 합이 소수(prime)가 되도록 $M$마리의 소를 선별할 계획이다. 농부 존의 계획에 맞게 소를 선별했을 때 나올 수 있는 몸무게의 합을 모두 출력하시오.\n",
        "input_text": "첫째 줄에 농장에 있는 소들의 수 $N$, 선별할 소의 수 $M$이 주어진다.\n둘째 줄에 소들의 몸무게 $H_i$가 주어진다.\n",
        "output_text": "$M$마리 소들의 몸무게 합으로 만들 수 있는 모든 소수를 오름차순으로 출력한다. 만약 그러한 경우가 없다면 $-1$을 출력한다.\n",
        "memory_median": 2032.0,
        "time_median": 0.0,
        "length_median": 1007.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "411": {
        "problem_text": "안녕하세요. 저는 산업 스파이입니다. 저의 정체를 절대 다른 사람에게 말하지 말아주세요.\n저의 가장 최근 일은 유명한 수학 연구소의 최신 연구 결과를 훔쳐오는 것이었습니다. 저는 매우 유능한 산업 스파이이기 때문에, 연구 결과를 어렵지 않게 얻을 수 있었습니다. 하지만, 제가 올 것을 미리 알았는지 연구소에서는 연구 결과를 모두 서류 절단기에 넣어버렸습니다. 어쩔수 없이 저는 눈물을 머금고 종이 조각을 모두 훔쳐왔습니다.\n저를 고용한 사람은 매우 무서운 사람입니다. 또, 저는 프로이기 때문에 실수를 용납하지 않습니다. 어떻게든 이 종이를 모두 복구해가야합니다. 이 연구소의 연구 주제는 빠른 소인수 분해입니다. 제가 가진 종이 조각에는 숫자가 한 자리씩만 적혀져 있습니다. 원래 숫자가 뭐였는지를 잘 모르겠습니다. 종이 조각에 쓰여 있는 숫자를 보내드릴테니, 종이 조각을 적절히 배치해서 소수가 되는 경우가 몇 개이지 알려주실 수 있나요?\n감사합니다.\n스파이 드림.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 c가 주어진다. (1 ≤ c ≤ 200) 각 테스트 케이스는 한 줄로 이루어져 있고, 종이조각에 쓰여 있는 수가 공백없이 주어진다. 종이조각의 수는 적어도 1개, 많아야 7개이다.\n",
        "output_text": "각 테스트 케이스에 대해 종이조각을 적절히 배치해서 만들 수 있는 서로 다른 소수의 개수를 출력한다. 이때, 모든 종이 조각을 사용하지 않아도 된다. (7과 1이 있을 때, 만들 수 있는 소수는 7, 17, 71이다) 종이 조각을 적절히 배치해서 만든 숫자가 0으로 시작할 때, 앞에있는 0을 지운 수가 같으면 같은 숫자이다.\n",
        "memory_median": 20648.0,
        "time_median": 156.0,
        "length_median": 1164.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "412": {
        "problem_text": "양의 정수 n이 주어졌을 때, n보다 작은 양의 정수 중에서 n과 서로소인 수 개수를 구하는 프로그램을 작성하시오.\n두 정수 a와 b가 서로소가 되려면 x > 1, y > 0, z > 0이면서, a = xy, b= xz를 만족하는 정수가 없어야 한다.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 테스트 케이스는 n ≤ 1,000,000,000으로 이루어져 있다.\n입력의 마지막 줄에는 0이 주어진다.\n",
        "output_text": "입력으로 주어진 n마다 n보다 작으면서 서로소인 양의 정수의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 652.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "413": {
        "problem_text": "모태 솔로인 세진이는 이번에는 꼭 여자친구를 사귀어야겠다는 마음으로 형진이가 주최한 미팅에 참석하게 된다. 하지만 안타깝게도 컴퓨터공학과는 남초학과이기 때문에 항상 남자의 수가 여자의 수보다 많거나 같다. 마음이 급해진 세진이는 항상 모든 여자들이 남자들과 짝을 이루어진다고 가정하였을 때 남자들이 미팅에서 여자들에게 선택되는 모든 경우를 시뮬레이션 해보려고 한다. 예를들어 남자 3명 여자 2명이 있을 때, 남자 1 남자2 가 선택되는 경우, 남자 2 남자 3이 선택되는 경우, 남자1 남자3 이 선택되는 경우로 경우의 수는 3가지가 존재한다. 세진이를 도와 미팅에서 선택될 수 있는 남자들의 모든 상태의 경우의 수를 구해보자.\n단, 수가 너무 커질 수 있으니 1000000007로 나눈 나머지를 구해보자.\n",
        "input_text": "입력의 첫째 줄에 남학생의 수 N(2 ≤ N ≤ 1000000)명 여학생의 수 M(1 ≤ M ≤ N)명이 주어진다.\n",
        "output_text": "경우의 수를 1000000007로 나눈 나머지를 출력하라. \n",
        "memory_median": 2020.0,
        "time_median": 8.0,
        "length_median": 664.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "414": {
        "problem_text": "Farmer John has scattered treats for Bessie at special places in the pasture.  Since everyone knows that smart cows make tasty milk, FJ has placed the treats at locations that require Bessie to think. He has given her two numbers, P and Q (1 <= P <= 6,000; 1 <= Q <= 6,000), and she has to check every point in the pasture whose x-coordinate is a factor of P and whose y-coordinate is a factor of Q to find her treat.\nSuppose FJ gives Bessie P = 24 and Q = 2. Here are all of their respective factors:\n\nP = 24 => 1, 2, 3, 4, 6, 8, 12, 24\nQ = 2 => 1, 2\n\nBessie would thus check grid locations: (1, 1), (1, 2), (2, 1), (2, 2), (3, 1)...\nHelp Bessie by printing all of the points she ought to check.\n",
        "input_text": "\nLine 1: Two space separated integers: P and Q\n\n \n",
        "output_text": "\nLines 1..?: A complete list of unique pairs of space-separated integers sorted by the first number and, if tied, the second number: a factor of P followed by a factor of Q\n\n \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 386.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "415": {
        "problem_text": "효성이는 길이가 $N$인 수열 $A$에서 $X$와 서로소인 수들을 골라 평균을 구해보려고 한다.\n효성이를 도와 이를 계산해주자.\n",
        "input_text": "첫 번째 줄에 입력될 수들의 개수 $N$이 주어진다. $(2 \\le N \\le 500,000)$\n두 번째 줄에는 수열 $A$를 이루는 자연수 $A_{i}$ 가 공백으로 구분되어 주어진다. $(2 \\le A_{i} \\le 1,000,000)$\n수열 $A$에 $X$와 서로소인 수가 최소 1개 이상 존재한다.\n마지막 줄에는 $X$가 주어진다. $(2\\le X \\le 1,000,000)$\n",
        "output_text": "첫째 줄에 수열 A에서 X와 서로소인 수들의 평균을 출력한다.\n절대/상대 오차는 10-6까지 허용한다.\n",
        "memory_median": 3976.0,
        "time_median": 100.0,
        "length_median": 581.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "416": {
        "problem_text": "B를 A로 나누었을 때 나머지가 0 이라면 A는 B의 약수라고 할 수 있다. (A > 0, B > 0) 예를 들면 15 의 약수는 1, 3, 5, 15 이다.\n주어진 수가 가지는 약수 개수가 홀수인지 짝수인지 판별해보자.\n",
        "input_text": "첫 번째 줄에는 전체 테스트 개수 (N) 가 주어진다. (1 ≤ N ≤ 100)\n두 번째 줄에는 약수 개수를 판별할 수 (X) 가 주어진다 (1 ≤ X ≤ 1018).\n",
        "output_text": "주어진 수의 약수 개수가 홀수이면 1, 짝수이면 0 을 출력하시오.\n",
        "memory_median": 2000.0,
        "time_median": 0.0,
        "length_median": 351.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "417": {
        "problem_text": "A positive integer k is called squarefree if k is not divisible by d2 for any d > 1.\n",
        "input_text": "The input contains one integer n, 1 ≤ n ≤ 1010.\n",
        "output_text": "Your program should output one integer, the n-th non-squarefree number.\n",
        "memory_median": 7478.0,
        "time_median": 112.0,
        "length_median": 850.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "418": {
        "problem_text": "Your friend has secretly picked $N$ consecutive positive integers between $1$ and $100$, and wants you to guess if their sum is even or odd.\nIf the sum must be even, output 'Even'.  If the sum must be odd, output 'Odd'.  If the sum could be even or could be odd, output 'Either'.\n",
        "input_text": "The input is a single integer $N$ with $1 \\le N \\le 10$.\n",
        "output_text": "Output a single word. The word should be 'Even', 'Odd', or 'Either', according to the rules given earlier.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 267.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "419": {
        "problem_text": "\n골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.\n골드바흐의 약한 추측: 5보다 큰 홀수는 세 소수의 합으로 나타낼 수 있다.\n르모앙의 추측: 5보다 큰 홀수는 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타낼 수 있다. 세미소수는 두 소수를 곱한 수이다.\n\n홀수 N이 주어졌을 때, 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타내는 방법의 수를 구해보자.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 홀수이고, 5 < N ≤ 1,000,000을 만족한다.\n",
        "output_text": "각각의 테스트 케이스마다 홀수 소수 하나와 짝수 세미소수 하나의 합으로 나타내는 방법의 수를 출력한다.\n",
        "memory_median": 100652.0,
        "time_median": 732.0,
        "length_median": 1998.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "420": {
        "problem_text": "동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 이 원숭이는 수를 이리저리 가지고 노는 것을 매우 좋아한다. 그중에서도 1을 가지고 노는 것을 매우매우매우매우매우 좋아한다. 이제 원숭이가 1을 가지고 노는 법을 알아보자.\n원숭이는 1만으로 이루어진 수를 매우매우매우매우매우매우매우 좋아한다. 그래서 어떤 자연수 N이 있을 때, N의 배수 중에서 1만으로 이루어진 수가 있을 까 생각하게 되었다. 그리고는 원숭이는 N의 배수 중에서 1만으로 이루어진 수중에 가장 작은 수의 자릿수가 알고 싶어졌다. 하지만 오늘도 역시 멍청한 원숭이는 스스로 계산하지 못하고 여러분에게 도움을 요청했다. 조건에 맞는 가장 작은 수의 자릿수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 자연수 N이 주어진다. N은 1이상 1,000,000이하인 자연수이다.\n",
        "output_text": "첫째 줄에 N의 배수 중에 1만으로 이루어진 수 중 가장 작은 수의 자릿수를 출력한다. 불가능한 경우는 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 355.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "421": {
        "problem_text": "David is a young boy and he loves numbers. Recently he learned how to divide two numbers. David divides the whole day. He is happy if the result of the division is an integer, but he is not very amused if this is not the case. After quite a while he decided to use only a single dividend each day.\nThe parents of David are very careful and they would like to ensure that David experiences enough happiness. Therefore they decide which number David will use as the dividend for this day.\nThere is still a problem: The parents are not very good at math and don’t know how to calculate the number of positive integral divisors for a given dividend N, which lead to an integral result. Now it’s up to you to help David’s parents.\n",
        "input_text": "The single input line contains the single integer N, where N is chosen as a dividend (1 ≤ N ≤ 1018).\n",
        "output_text": "Print the number of positive integral divisors of N that lead to an integral result of the division.\n",
        "memory_median": 2028.0,
        "time_median": 20.0,
        "length_median": 2054.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "422": {
        "problem_text": "\r\n\t유리수 분수를 소수로 나타내면, 소수점 아래 자리가 유한 개인 경우(1/8 = 0.125)와 어떤 자리에서부터 일정한 숫자가 한없이 되풀이 되는 경우(1/11 = 0.090909...)가 있다.\n\r\n\t소수를 입력받은 뒤, 분수로 나타내는 프로그램을 작성하시오.\n",
        "input_text": "\r\n\t첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 개수는 100개를 넘지 않는다. 각 테스트 케이스는 한 줄에 소수가 하나씩 주어진다.\n\r\n\t소수의 첫 두 자리는 \"0.\"이다. 그 다음에는 숫자 0개~6개가 주어진다. 그 다음, 길이가 1과 9사이면서 괄호로 감싸져있는 수가 주어질 수도 있다. 이 수는 무한히 반복되는 자리를 의미한다.\n\r\n\t항상 0이 아닌 자리가 하나는 주어지며, 괄호 안에 주어지는 수는 0이나 9로만 이루어져 있지 않다.\n",
        "output_text": "\r\n\t각 테스트 케이스에 대해서, 입력으로 주어진 소수의 분수 표현을 출력한다. (분모와 분자는 서로소이어야 한다)\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1154.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "423": {
        "problem_text": "소수나라는 특이하게 모든 소수(prime number)를 화폐 단위로 사용한다.\n소수나라에 놀러 온 하나는 관광을 하다가 가격이 N인 물건을 발견하고 너무 마음에 들어 999983원을 내고 구매하려고 했다. 하지만 상점 주인이 거스름돈이 없어 정확히 N원을 지불해달라고 하였다.\n물건을 구매하려던 하나는 소수나라의 화폐를 이용하여 N원을 정확히 만들 수 있는 방법의 가짓수가 얼마나 되는지 궁금해졌다.\n하나를 도와 N원을 지불하기 위한 가짓수가 얼마나 되는지 구해보자.\n단, 하나는 소수나라의 모든 화폐가 무한정 있다고 가정한다.\n",
        "input_text": "구매하려고하는 물건의 값 N(2 ≤ N ≤ 40,000, N은 정수)이 주어진다.\n",
        "output_text": "소수나라의 화폐를 이용하여 지불할 수 있는 방법의 수를 출력한다.\n단, 지불할 수 있는 방법의 수가 매우 크기때문에, 123,456,789로 나눈 나머지 값을 출력한다.\n",
        "memory_median": 2318.0,
        "time_median": 180.0,
        "length_median": 679.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "424": {
        "problem_text": "\r\n\t양의 정수는 서로 다른 소수의 합으로 나타낼 수 있다. 두 정수 n과 k가 주어졌을 때, n을 서로 다른 k개의 소수의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오. 여기서 덧셈의 순서만 다른 경우(3+5, 5+3)는 모두 1가지로 센다.\n\r\n\t예를 들어, n=24, k=3일 때, 2가지로 나타낼 수 있다. {2, 3, 19}, {2, 5, 17} 합이 24가 되는 서로 다른 소수 3개는 이 2가지를 제외하고는 없다. 또, n=24, k=2일 때 답은 {5, 19}, {7, 17}, {11, 13} 3가지이며, n=2, k=1일 때 답은 {2} 1가지이다. n=1, k=1일 경우에는 1은 소수가 아니기 때문에 답은 0이다. 마지막으로 서로 다른 2개 소수의 합이 4가 되는 경우도 없기 때문에, n=4, k=2도 답이 0이다.\n",
        "input_text": "\r\n\t첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각각의 테스트 케이스는 한 줄에 n과 k가 공백으로 구분되어 있다. (n ≤ 1120, k ≤ 14)\n",
        "output_text": "\r\n\t각 테스트 케이스에 해당하는 경우의 수를 한 줄에 하나씩 출력한다. 정답은 항상 231보다 작다.\n",
        "memory_median": 2088.0,
        "time_median": 4.0,
        "length_median": 871.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "425": {
        "problem_text": "\r\n\t페르마의 소정리 (Fermat's little theorem)의 내용은 다음과 같다.\n\r\n\tp가 소수일 때, 임의의 정수 a>1에 대해서, ap == a (mod p)가 성립한다.\n\r\n\t즉, a를 p제곱한 뒤, p로 나눴을 때, 나머지는 a가 되는 것이다.\n\r\n\t하지만, p가 소수가 아닌 경우에 어떤 정수 a에 대해서 위의 식을 만족하는 경우가 있다. 이때, p를 밑이 a인 가짜소수라고 한다. (모든 a에 대해서 식을 만족하는 수를 카마이클 수라고 한다)\n\r\n\tp와 a가 주어졌을 때, p가 밑이 a인 가짜소수인지 아닌지 알아내는 프로그램을 작성하시오. \n",
        "input_text": "\r\n\t입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있고, p와 a를 포함하고 있다. 입력의 마지막 줄에는 \"0 0\"이 주어진다. (2 < p ≤ 1,000,000,000, 1 < a < p)\n",
        "output_text": "\r\n\t각 테스트 케이스에 대해서, p가 밑이 a인 가짜소수라면 yes를, 아니라면 no를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 775.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "426": {
        "problem_text": "S는 다음과 같이 정의된다.\n\nS(0, n) = n (모든 양의 정수 n)\nS(k, n) = S(k-1, 1) + S(k-1, 2) + ... + S(k-1, n) (모든 양의 정수 k, n)\n\nk와 n이 주어졌을 때, S(k, n)을 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 k와 n이 주어진다. (1 ≤ k ≤ 50, 1 ≤ n ≤ 1,000,000,000)\n",
        "output_text": "첫째 줄에 S(k, n)을 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 4.0,
        "length_median": 1053.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "427": {
        "problem_text": "홍준이는 프로그래밍 대회를 개최했다. 이 대회는 사람들이 팀을 이루어서 참가해야 하며, 팀원의 수는 홍준이가 정해준다. 팀원이 홍준이가 정한 값보다 부족하다면, 그 팀은 대회에 참여할 수 없다. 모든 팀은 같은 수의 팀원으로 이루어져 있다.\n대회에 참여 의사를 밝힌 학교는 총 N개이다. 각 학교는 모든 학생이 참여할 수 있는 경우에만 대회에 참가한다. 즉, 남는 사람 없이 모든 학생이 팀에 들어갈 수 있어야 한다.\n대회는 예선과 본선으로 구성되어 있다. 모든 팀은 같은 학교 소속으로 이루어져 있어야 한다. 예선에서 각 학교 1등팀만 본선에 진출한다. \n홍준이의 대회는 올해가 첫 해이기 때문에, 많은 관심이 필요하다. 따라서, 본선에 참가하는 사람의 수를 최대가 되도록 팀원의 수를 정하려고 한다. 또, 본선이 지루해지는 것을 막기 위해 적어도 두 팀이 본선에 참가할 수 있어야 한다.\n홍준이가 팀원을 몇 명으로 정해야 본선에 참가하는 사람의 수가 최대가 되는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 홍준이의 대회에 참여 의사를 밝힌 학교의 수 N (2 ≤ N ≤ 200,000)이 주어진다.\n둘째 줄에는 각 학교 학생의 수가 주어진다. 학생의 수는 구간 [1, 2,000,000]에 포함된다.\n",
        "output_text": "첫째 줄에 홍준이의 대회 본선에 참가하는 사람의 수의 최댓값을 출력한다.\n",
        "memory_median": 16740.0,
        "time_median": 184.0,
        "length_median": 578.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "428": {
        "problem_text": "엄지 생일 기념으로 학생들은 파티를 하고 있다. 엄지는 N(1≤N≤100,000)명의 학생에게 1부터 N번까지 차례대로 번호를 부여하였고 그들을 순서대로 빙 둘러앉아 원을 만들게 하였다. (즉 i번째 학생은 i-1과 i+1학생 사이에 앉아있다. 단, N번째 학생은 N-1번째 학생과 첫 번째 학생 사이에 앉아있다.)\nN명의 학생은 둘러앉아 \"머리톡톡\" 게임을 하려한다. 게임 규칙은 다음과 같다. 각각의 학생은 자신의 머리 위에 1,000,000 이하의 자연수 중 하나를 쓴다. 그리고 1번부터 N번 학생까지 한 명씩 차례대로 일어나 원을 돌면서 자신이 쓴 숫자가 다른 사람이 쓴 숫자의 배수이면 그 학생의 머리를 \"톡톡\" 친다.\n문제는 각각의 학생이 일어나 자신의 자리로 돌아올 때까지 총 몇 명의 학생의 머리를 치는지 구하는 것이다.\n",
        "input_text": "첫째 줄에 학생의 수 N이 입력되고 다음 N개의 줄에는 1번부터 N번까지 각각의 학생이 자신의 머리에 쓴 숫자를 입력받는다.\n",
        "output_text": "총 N개의 줄로 i번째 줄에는 i번째 학생이 한 바퀴를 돌면서 머리를 친 학생의 수를 출력한다.\n",
        "memory_median": 6712.0,
        "time_median": 132.0,
        "length_median": 686.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "429": {
        "problem_text": "$1$부터 $N$까지의 자연수를 색칠한다. 단, 서로소인 서로 다른 두 자연수는 다른 색으로 칠해야 한다. 최소한의 색을 써서 모든 자연수를 칠하는 방법을 찾는 프로그램을 작성하자.\n",
        "input_text": "첫째 줄에 자연수 $N$이 주어진다. ($1 \\le N \\le 500\\,000$)\n",
        "output_text": "첫째 줄에 사용한 색의 수 $K$를 출력한다.\n둘째 줄에 $N$개의 수를 공백을 사이에 두고 출력한다. $i$번째 수는 자연수 $i$의 색이다. 색은 $1$ 이상 $K$ 이하의 정수로 나타낸다.\n",
        "memory_median": 3976.0,
        "time_median": 44.0,
        "length_median": 578.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "430": {
        "problem_text": "Z 대학교 학생은 입학할 때 학번을 받게 된다. 학번은 0보다 크거나 같고, 106-1보다 작거나 같은 정수이다. Z 대학의 김상근 교수는 학번으로 학생들을 구분한다. 상근이는 학생들을 조금 더 쉽게 기억하기 위해서 자신이 가르치는 학생들의 학번을 m으로 나누었을 때, 나머지가 모두 다른 가장 작은 양의 정수를 찾으려고 한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 N이 주어진다. 각 테스트 케이스의 첫째 줄에는 상근이가 가르치는 학생의 수 G가 (1 ≤ G ≤ 300) 주어진다. 다음 G개 줄에는 학생의 학번이 한 줄에 하나씩 주어진다. 학번이 같은 경우는 없다.\n",
        "output_text": "각 테스트 케이스마다, 학번을 m으로 나눈 나머지가 모두 다른 가장 작은 정수 m을 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 192.0,
        "length_median": 708.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "431": {
        "problem_text": "어제 자다가 알람 시계를 떨어뜨렸는지, 08:15분이 51:80분이 되어 있었다. 그때 나는 디지털로 표시된 어떤 숫자는 180도 뒤집혔을 때도 숫자가 될 수 있다는 걸 깨달았다.\n\n소수 18115211이 디지털로 표시된 그림\n\n18115211이 180도 뒤집혀서 11251181이 되었다. (소수가 아님)\n\n, , ,  은 뒤집혀서도 , , ,  그대로이다.\n 은 그냥 왼쪽으로 옮겨진다. \n 은 가 되고,  는 이 된다.\n, ,  은 더 이상 숫자가 아니다. (, , )\n\n내가 좋아하는 숫자는 소수이다. 당신이 할 일은 주어진 숫자가 소수인지, 뒤집혀서도 소수인지 확인하는 것이다.\n",
        "input_text": "첫 번째 줄에 N이 주어진다 (1 ≤ N ≤ 1016).\nN의 첫 숫자는 0이 아니다.\n",
        "output_text": "첫 번째 줄에 N이 소수이고 뒤집혀서도 소수이면 \"yes\"를 출력하고, 아니면 \"no\"를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 1496.0,
        "length_median": 902.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "432": {
        "problem_text": "최백준은 음하철도 구구팔에 탔다.\n문제는 구구팔의 기장인 조교 김재홍이 반쯤 미쳐서 열차를 멈추지 않는다는 것이다. 그래서 최백준은 달리고 있는 열차에서 뛰어내려야 한다.\n그런데 뛰어내릴 때 정류장 까지 거리가 너무 멀면 마이 아플 수 있다.\n그래서 철도가 정류장에 가장 많이 근접했을 때 뛰어내리고자 한다.\n어디서 뛰어내려야 하는가?\n",
        "input_text": "첫번째 줄에는 xs와 ys가 주어진다. 이는 정류장의 위치가 (xs, ys)임을 의미한다.\n두번째 줄에는 xe, ye, dx, dy가 주어진다. 이는 현재 열차 위치가 (xe, ye)이고, 열차가 1초마다 x가 증가하는 방향으로 dx만큼, y가 증가하는 방향으로 dy만큼 이동함을 의미한다\n주어지는 모든 수는 -100이상, 100이하의 정수이다.\n",
        "output_text": "최백준이 뛰어내릴 위치의 x좌표와 y좌표를 출력한다. 뛰어내릴 위치의 좌표가 항상 정수인 입력만 주어진다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 848.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "433": {
        "problem_text": "자연수 N이 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 수 중에서 N과 서로소인 것의 개수를 구하는 프로그램을 작성하시오.\n두 정수를 나눌 수 있는 양의 정수가 1밖에 없을 때, 두 정수를 서로소라고 한다. 즉, 두 수의 최대공약수가 1이면 서로소이다. 1은 모든 정수와 서로소이다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T (0 < T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, A, B, N이 주어진다. (1 ≤ A ≤ B ≤ 1015, 1 ≤ N ≤ 109)\n",
        "output_text": "각 테스트 케이스마다 A보다 크거나 같고, B보다 작거나 같은 자연수 중에서 N과 서로소인 것의 개수를 출력한다. \n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1277.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "434": {
        "problem_text": "다솜이는 슈퍼에서 사탕을 사려고 한다. 슈퍼에는 사탕이 N종류가 있다. 각각의 사탕은 가격이 있다. 다솜이는 사탕을 사는데, 사탕의 가격의 합이 소수가 되게하려고 한다.\n가격이 같은 사탕은 모양이 같게 생겼다. 따라서 다솜이는 사탕을 적절히 샀을 때, 그 모양이 전부 똑같은 방법은 사지 않으려고 한다.\n예를 들어, (1, 2, 1, 3, 1)을 사는 것과, (3, 1, 1, 1, 2)를 사는 것은 같은 방법이다. 따라서 한번만 세야 한다.\n",
        "input_text": "첫째 줄에 슈퍼에 있는 사탕의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 사탕의 가격이 주어진다. 사탕의 가격은 10,000보다 작거나 같은 음이 아닌 정수이다.\n",
        "output_text": "첫째 줄에 다솜이가 사탕을 살 수 있는 방법의 경우의 수를 출력한다.\n",
        "memory_median": 7850.0,
        "time_median": 48.0,
        "length_median": 1148.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "435": {
        "problem_text": "정수 N을 정수 D로 나눴을 때의 몫을 Q, 나머지를 R이라고 하면 항등식 R = N - Q×D가 성립한다.\nn개의 정수로 된 수열이 있을 때, 모든 정수를 한 정수 D로 나눴을 때 나머지가 같아지는 경우가 있다. 그리고 수열에 따라서는 이러한 정수 D가 여러 개 존재할 수 있다.\nn개의 정수로 된 수열이 주어졌을 때, 가장 큰 D를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 n(1 ≤ n ≤ 1,000)이 주어진다. 다음 줄에는 절댓값이 1,000,000을 넘지 않는 n개의 정수들이 주어진다.\n",
        "output_text": "첫째 줄에 가장 큰 D를 출력한다. 항상 가장 큰 D가 존재하는 경우만 입력으로 주어진다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 549.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "436": {
        "problem_text": "음이 아닌 정수 N와 소수(prime number) A가 주어지면, N!을 Ak로 나누었을 때, 나머지가 0이 되는 최대의 음이 아닌 정수 k를 구하여라. (단, N!=N×(N-1)×···×1, 0!=1)\n",
        "input_text": "첫째 줄에 정수 N과 A가 사이에 공백을 두고 주어진다. (0 ≤ N < 231, 2 ≤ A ≤ 11, A는 소수)\n",
        "output_text": "첫째 줄에 최대의 음이 아닌 정수 k를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 233.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "437": {
        "problem_text": "N개의 정점으로 이루어져 있는 트리 T가 주어졌을 때, 다음 쿼리를 수행하는 프로그램을 작성하시오. \n\nr u v: T의 루트가 r이라고 했을 때, u와 v의 LCA를 출력한다.\n\n",
        "input_text": "첫째 줄에 정점의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에는 트리 T의 간선 정보 u와 v가 주어지다. u와 v는 트리의 간선을 나타내는 두 정점이다.\n다음 줄에는 쿼리의 개수 M(1 ≤ M ≤ 100,000)가 주어진다. 다음 M개의 줄에는 쿼리를 나타내는 r, u, v가 주어진다.\n",
        "output_text": "각각의 쿼리마다 한 줄에 하나씩 결과를 출력한다.\n",
        "memory_median": 20184.0,
        "time_median": 208.0,
        "length_median": 1692.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "438": {
        "problem_text": "한동이는 경상도내를 돌아다니면서 열심히 일하는 영업사원이다. 예전에는 자기가 원하는 도시만 골라서 다닐 수 있었지만 시대가 바뀌어서 이제 그렇게는 하지 못하게 되었다. 시대가 바뀜에 따라, 한동이는 회사에서 돌아야 할 도시의 목록을 받고, 그 목록대로 도시를 여행한다. 회사에서 주는 여행지 목록은 정말 안타깝게도 최적화되어 있지가 않다. 여행을 떠나기 전에 한동이는 모든 도시를 방문하는데 걸리는 최소의 시간을 알고싶어하는데, 한동이는 경영학과라 컴퓨터를 하지 못 하기 때문에 여러분이 한동이를 도와주자.\n포항 시내의 도시들은 1부터 n까지 번호 지어져 있다. 한동이는 항상 포항시청에서 여행을 시작하고, 포항시청의 번호는 항상 1번이다. 모든 도시들은 양방향 도로로 연결되어있는데 한 도시에서 바로 길이 이어져있는 다른 도시로 이동하는데는 항상 1의 시간이 걸린다. 포항시청에서는 어떤 도시든지 갈 수 있다. 또한 포항의 도로는 굉장히 잘 되어있어서 도로끼리 사이클을 만들지 않는다.\n여러분의 목표는 한동이가 모든 도시를 방문하는데 걸리는 최소의 시간을 출력하는 것이다.\n",
        "input_text": "입력의 첫 줄에는 포항에 있는 도시의 숫자 n이 주어진다. 1 ≤ n ≤ 30,000. \n다음 n-1줄에는 도시를 잇는 도로가 주어진다. 각 줄에는 정수 a와 b가 주어진다. 이는 a도시와 b도시를 잇는 도로가 존재한다는 의미이다. (1 ≤ a,b ≤ n; a≠b)\nn+1번째 줄에는 정수 m이 주어지는데, 이는 한동이가 방문해야 할 도시의 숫자를 의미한다. 1 ≤ m ≤ 5,000 그 후 m개의 줄에는 한 줄에 하나씩 한동이가 방문해야 할 도시의 숫자가 순서대로 주어진다.\n",
        "output_text": "첫 줄에 한동이가 방문해야 할 모든 도시를 방문 할 수 있는 최소 시간을 출력한다.\n",
        "memory_median": 6198.0,
        "time_median": 16.0,
        "length_median": 1496.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "439": {
        "problem_text": "n과 m이 주어졌을 때, n개의 노드로 이루어져 있고, m개의 리프로 이루어져 있는 트리를 만드는 프로그램을 작성하시오.\n항상 정답이 존재하는 경우만 입력으로 주어진다.\n트리는 사이클이 없는 연결 그래프이고, 리프는 차수가 1인 노드를 의미한다.\n",
        "input_text": "첫째 줄에 n과 m이 주어진다. (3 ≤ n ≤ 50, 2 ≤ m ≤ n-1)\n",
        "output_text": "첫째 줄부터 n-1개의 줄에 트리의 간선 정보를 출력한다. 트리의 정점은 0번부터 n-1번까지 이다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 314.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "440": {
        "problem_text": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.\n이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 단 하루만 반대로 하기로 했다. 즉, 부하가 상사를 칭찬하면, 그 위로 쭉 사장까지 모두 칭찬을 받는다.\n칭찬에 대한 정보는 실시간으로 주어진다.\n입력으로 아래와 같은 쿼리가 주어질 것이다.\n\n1 i w: i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000) 부하가 없다면 입력으로 들어오지 않는다.\n2 i: i번째 직원이 칭찬을 받은 정도를 출력한다. (1 ≤ i ≤ n)\n\n직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.\n",
        "input_text": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)\n둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.\n다음 m줄에는 쿼리가 한 줄에 하나씩 주어진다.\n",
        "output_text": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.\n",
        "memory_median": 14314.0,
        "time_median": 56.0,
        "length_median": 1529.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "441": {
        "problem_text": "방향성이 없는 그래프 G가 주어진다. 문제는 G의 최소 스패닝 트리보다는 크면서 가장 작은 스패닝 트리인 'The second minimum spanning tree'를 구하는 것이다.\n\nMST와 second MST의 모습\n",
        "input_text": "첫째 줄에 그래프의 정점의 수 V(1 ≤ V ≤ 50,000)와 간선의 수 E(1 ≤ E ≤ 200,000)가 들어온다. 둘째 줄부터 E+1번째 줄까지 한 간선으로 연결된 두 정점과 그 간선의 가중치가 주어진다. 가중치는 100,000보다 작거나 같은 자연수 또는 0이고, 답은 231-1을 넘지 않는다.\n정점 번호는 1보다 크거나 같고, V보다 작거나 같은 자연수이다.\n",
        "output_text": "두 번째로 작은 스패닝 트리의 값을 출력한다. 만약 스패닝 트리나 두 번째로 작은 스패닝 트리가 존재하지 않는다면 -1을 출력한다.\n",
        "memory_median": 24146.0,
        "time_median": 204.0,
        "length_median": 3801.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "442": {
        "problem_text": "증가하는 정수 수열을 이용해서 트리를 만드는 방법은 다음과 같다.\n\n첫 번째 정수는 트리의 루트 노드이다.\n다음에 등장하는 연속된 수의 집합은 루트의 자식을 나타낸다. 이 집합에 포함되는 수의 첫 번째 수는 항상 루트 노드+1보다 크다.\n그 다음부터는 모든 연속된 수의 집합은 아직 자식이 없는 노드의 자식이 된다. 그러한 노드가 여러 가지 인 경우에는 가장 작은 수를 가지는 노드의 자식이 된다.\n집합은 수가 연속하지 않는 곳에서 구분된다.\n\n예를 들어, 수열 1 3 4 5 8 9 15 30 31 32를 위의 규칙을 이용해 트리를 만들면 아래 그림과 같이 된다.\n\n두 노드의 부모는 다르지만, 두 부모가 형제(sibling)일 때 두 노드를 사촌이라고 한다.\n수열 특정 노드 번호 k가 주어졌을 때, k의 사촌의 수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 노드의 수 n과 사촌의 수를 구해야 하는 노드의 번호 k가 주어진다. (1 ≤ n ≤ 1,000, 1 ≤ k ≤ 1,000,000) 다음 줄에는 총 n개의 수가 주어지며, 모든 수는 1보다 크거나 같고, 1,000,000보다 작거나 같다. 입력으로 주어지는 수열은 항상 증가한다. k는 항상 수열에 포함되는 수이다.\n입력의 마지막 줄에는 0이 두 개 주어진다.\n",
        "output_text": "각 테스트 케이스 마다, k의 사촌의 수를 출력한다.\n",
        "memory_median": 2160.0,
        "time_median": 284.0,
        "length_median": 1080.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "443": {
        "problem_text": "갑자기 맥북이 상근이의 손에서 떨어졌고, 화면이 켜지지 않았다. AS센터에 문의해보니 수리비가 97만원이 나왔고, 상근이는 큰 혼란에 빠졌다. 돈도 중요하지만, 상근이는 그 속에 들어있는 파일이 걱정되기 시작했다. 다행히 상근이는 저장되어 있는 중요한 디렉토리의 전체 경로를 텍스트 파일로 따로 저장하고 있었다. 예를 들면, WINNT\\SYSTEM32\\CERTSRV\\CERTCO~1\\X86. \n상근이의 중요한 디렉토리의 전체 경로가 모두 주어졌을 때, 디렉토리 구조를 구해 보기 좋게 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 중요한 디렉토리 전체 경로의 개수 N(1 ≤ N ≤ 500)이 주어진다. 다음 N개 줄에는 디렉토리 경로가 주어진다. 경로는 한 줄로 이루어져 있으며, 공백을 포함하지 않는다. 경로는 80글자를 넘지 않으며, 디렉토리는 역슬래시(\\)로 구분된다.\n각 디렉토리의 이름은 1~8글자이며, 알파벳 대문자, 숫자, 특수 문자로 이루어져 있다. 디렉토리 이름에 들어있을 수 있는 특수문자는 !#\\$%&'()-@^_`{}~ 이다.\n",
        "output_text": "디렉토리 구조를 보기 좋게 출력한다. 한 줄에 하나씩 디렉토리의 이름을 출력하며, 공백은 디렉토리 구조상에서 깊이를 의미한다. 각 서브 디렉토리는 사전순으로 출력해야 하며, 부모 디렉토리에서 출력한 공백의 개수보다 1개 많게 공백을 출력한다. 예제 출력을 보면서 형식을 참고하는 것이 좋다.\n",
        "memory_median": 4852.0,
        "time_median": 16.0,
        "length_median": 1311.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "444": {
        "problem_text": "인간의 DNA 구조는 A, C, G, T로 이루어진 하나의 긴 문자열로 표현할 수 있다.\n이때, 몇 몇 질병은 DNA 구조를 나타낸 문자열의 어떤 연속된 부분 문자열과 관련이 있다는 것이 밝혀져 있다. 만일 DNA가 특정 문자열을 부분 문자열로 가진다면 그 질병에 걸릴 가능성이 높다는 것이다. 이러한 특정 문자열을 마커(marker)라 한다.\n하지만 때때로 DNA 구조를 그대로 확인하는 것만으로는 질병과 관련된 마커를 확인할 수 없는 경우가 있다. 마커의 돌연변이 가능성 때문이다.\n마커의 돌연변이는 아래와 같이 일어난다.\n\n먼저, 마커를 세 부분으로 나눈다, 이때, 첫 부분과 세 번째 부분은 비어 있어도 된다.\n두 번째 부분을 뒤집는다.\n\n예를 들어 마커가 AGGT라면 아래와 같은 여섯 가지 경우가 가능하다.\nGAGT, GGAT, TGGA, AGGT, ATGG, AGTG\n어떤 사람의 DNA 구조와 마커가 주어졌을 때, DNA 내에 마커가 돌연변이의 형태를 포함하여 몇 번 출현하는지 세는 프로그램을 작성하라.\n단, 마커의 출현 위치는 서로 겹쳐도 된다. 예를 들어 DNA 구조가 ATGGAT이며 마커가 AGGT라면 답은 3이 된다. ATGG, TGGA, GGAT가 한 번씩 출현하기 때문이다.\n",
        "input_text": "첫 줄에 테스트 케이스의 수 T가 주어진다.\n각 테스트 케이스의 첫 줄엔 두 개의 정수 n과 m이 주어진다. 이는 각각 DNA 문자열의 길이와 마커의 길이이다. (1 ≤ n ≤ 1,000,000, 1 ≤ m ≤ 100) 두 번째 줄엔 DNA 구조가 주어진다. 마지막 줄엔 마커가 주어진다.\n모든 DNA와 마커는 A,G,T,C로만 이루어진 문자열이다.\n",
        "output_text": "각 테스트 케이스마다 주어진 DNA 구조에 마커와 그 돌연변이가 몇 번 출현하는지 하나의 정수로 출력한다.\n만일 DNA 구조 내에 마커 또는 그 돌연변이가 한 번도 출현하지 않는다면 답은 0이 된다.\n",
        "memory_median": 16296.0,
        "time_median": 1160.0,
        "length_median": 2380.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "445": {
        "problem_text": "트리 T는 아래 그림 1과 같은 구조를 가지고 있으며 원은 ‘정점’이라 하고, 정점과 정점을 연결하는 선을 ‘에지’라 한다. 특히 가장 위에 위치한 정점을 ‘루트’라 하는데 오직 하나만 있다. N개의 정점들은 숫자 1부터 N으로 표현하고 루트는 항상 1이다.\n두 정점 v와 w를 연결하는 경로는 정점들의 순서리스트 (v0, v1, ..., vm)로, 정점 vi와 vi+1은 에지로 연결되고 v0 = v, vm = w이다. 트리에서는 임의의 두 정점 v와 w 사이에 항상 두 정점을 연결하는 경로가 오직 하나만 존재한다. 예를 들어, 그림 1에서 정점 3과 11 사이의 유일한 경로는 (3, 4, 1, 7, 11)이다.\n\n그림 1\n각 정점 v에서 루트 r과 연결하는 유일한 경로 P에 대해서 정점 v와 에지로 연결된 정점 중에서 P상에 있는 정점을 v의 ‘부모 정점’이라고 한다. 예를 들어, 그림 1에서 4, 7, 9의 부모 정점은 1이고, 2와 11의 부모 정점은 7이다.\n트리 T에서 어떤 두 정점을 연결하는 에지를 제거하면 그 두 정점 외에도 경로가 존재하지 않는 정점 쌍이 있을 수 있다. 여러분은 “정점 v와 w를 연결하는 경로가 존재하는가?”와 같은 질의에 답해야 한다. 예를 들어, 그림 1에서 7과 11 사이의 에지를 제거하면 8과 5를 연결하는 경로는 존재하지 않는다. \n트리 정보가 주어지고, 에지의 제거 정보와 질의가 임의의 순서로 주어질 때, 작업을 순서대로 수행하며 질의에 대한 답을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 트리의 정점의 개수와 질의의 개수를 나타내는 두 정수 N과 Q (1 ≤ N, Q ≤ 200,000)가 주어진다. 다음 N-1개의 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 a가 주어진다 (1 ≤ a ≤ N). 다음 Q개의 줄 각각에는 세 정수 b, c, d가 주어진다. d = 0이면, b와 c를 연결하는 경로가 존재하는 지 묻는 질의만 수행함을 의미한다. d = 1이면, b와 c를 연결하는 경로가 존재하는 지 묻는 질의를 수행하고, 대답이 “YES”이면, 이어서 b의 부모 정점과 b를 연결하는 에지를 제거한다. 대답이 “NO”이면, c의 부모 정점과 c를 연결하는 에지를 제거한다. 만약 제거하려는 에지가 원래 존재하지 않거나 이미 제거된 경우에는 제거되는 에지가 없다.\n",
        "output_text": "표준 출력으로 질의에 대한 답을 순서대로 Q개의 줄에 출력한다. 각 줄마다 경로가 존재하면 YES를 아니면 NO를 출력한다.\n",
        "memory_median": 33020.0,
        "time_median": 368.0,
        "length_median": 2420.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "446": {
        "problem_text": "\n시청 공무원 마이크로는 과장으로부터 시에 있는 나무의 기둥의 길이와 가장 긴 가지의 길이를 파악하라는 업무 지시를 받았다.\n마이크로는 ICPC Sinchon Winter Algorithm Camp에서 배운 트리 자료 구조를 이용하면 이 작업을 좀 더 수월하게 할 수 있으리라 판단했다. \n\n마이크로는 트리의 기둥과 가지를 분류하기 위해 기가 노드를 추가로 정의하였다.\n기가 노드는 루트 노드에서 순회를 시작했을 때, 처음으로 자식 노드가 $2$개 이상인 노드다. 기둥-가지를 줄여 기가 노드라 이름 붙였다. 위 그림에서 기가 노드는 $4$번 노드다.\n\n단, 위 그림과 같이 리프 노드가 단 $1$개인 경우 리프 노드가 동시에 기가 노드가 된다.\n\n또한, 위 그림과 같이 루트 노드가 동시에 기가 노드인 경우도 가능하다.\n\n\n트리의 기둥은 루트 노드에서부터 기가 노드까지다. 위 그림에서 기둥은 $1-2-3-4$ 이다.\r\n\t기둥의 길이는 기둥의 간선 길이의 합인 $1 + 2 + 3 = 6$ 이 된다.\n트리의 가지는 기가 노드에서부터 임의의 리프 노드까지다. 위 그림에서 가지는 $4-5-6-7$, $4-5-8$, $4-9$, $4-10-11$, $4-10-12$ 총 $5$개가 있다.\r\n\t가지의 길이는 가지의 간선 길이의 합이다. 다행히도 가장 긴 가지의 길이 하나만 기재하면 된다. $4-10-12$ 가지가 간선 길이의 합 $3 + 3 = 6$ 으로 가장 긴 가지이다.\n\n마이크로는 시의 나무를 트리 자료 구조로 옮겼다. 그런데 과장이 마이크로에게 또 다른 업무를 지시했다! 너무 바쁜 마이크로를 대신해 트리의 기둥과 가장 긴 가지의 길이를 측정하자.\n",
        "input_text": "첫 번째 줄에는 노드의 개수 $N$($1 \\le N \\le 200\\,000$)과 루트 노드의 번호 $R$($1 \\le R \\le N$)이 주어진다.\n이후 $N-1$개의 줄에 세 개의 정수 $a$, $b$, $d$($1 \\le a, b \\le N$, $ a \\ne b$)가 주어진다. 이는 $a$번 노드와 $b$번 노드가 연결되어있으며 이 간선의 길이가 $d$($1 \\le d \\le 1\\,000$)임을 의미한다. 노드는 $1$번부터 $N$번까지 정수 번호가 매겨져 있으며 같은 간선은 여러 번 주어지지 않는다. \n트리가 아닌 그래프는 입력으로 주어지지 않는다.\n",
        "output_text": "나무의 기둥의 길이와 가장 긴 가지의 길이를 출력한다.\n",
        "memory_median": 24404.0,
        "time_median": 140.0,
        "length_median": 1290.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "447": {
        "problem_text": "동네 뒷 산에는 등산로가 있다. 등산로는 N개의 작은 오두막들이 N −1개의 오솔길로 이어진 형태이다. 한 오솔길은 두 개의 오두막을 양 방향으로 연결한다. 한 오솔길의 길이는 1이다. 어떤 오두막에서도 다른 모든 오두막으로 하나 이상의 오솔길을 따라 이동하는 것이 가능하다. 오두막들은 1번부터 N번까지 번호가 붙어 있으며, 1번 오두막이 산 정상에 있다. 1번 오두막에서 다른 오두막으로 가는 가장 짧은 길을 따라 가면서 거치는 모든 오솔길들은 항상 산을 내려가는 방향이다.\n철수는 등산 마니아이다. 철수가 한 오두막에서 다른 오두막으로 갈 때는 항상 산 정상을 거치는 가장 짧은 길을 따라 간다. 이렇게 간 길의 다양성은 길에 포함된 오솔길의 개수로 정의된다. 두 번 이상 지나간 오솔길은 한 번만 센다는 것에 주의하라.\n아래 그림은 가능한 하나의 상황을 보여 준다. 산 정상에 1번 오두막이 있고 3번 오두막과 4번 오두막이 오솔길로 이어져 있다.\n\n아래 그림은 2번 오두막에서 7번 오두막으로 가는 가장 짧은 길을 보여준다.\n\n아래 그림은 2번 오두막에서 7번 오두막으로, 정상을 거쳐서 가는 가장 짧은 길을 보여 준다.\n\n등산로의 구성을 입력으로 받아 모든 가능한 i, j의 쌍에 대해서(1 ≤ i < j ≤ N), 철수가 i번 오두막에서 j번 오두막으로 가는 길의 다양성의 총 합을 계산하는 프로그램을 작성하라.\n",
        "input_text": "첫 번째 줄에 N이 주어진다. 다음 N −1개의 줄에 오두막 번호 두 개가 공백 하나를 사이에 두고 주어진다. 두 오두막이 오솔길로 이어져 있다는 뜻이다.\n",
        "output_text": "첫 번째 줄에 문제의 정답을 출력한다.\n",
        "memory_median": 37048.0,
        "time_median": 252.0,
        "length_median": 796.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "448": {
        "problem_text": "성대나라에는 각 도시별로 가뭄을 대비하기 위한 물탱크가 하나씩 존재한다. 이 물탱크들은 모두 연결되어있으며, 루트(성대나라의 수도)가 있는 트리의 형태를 가진다.\r\n지금 성대나라는 물탱크의 물을 사용하여 가뭄을 버텨냈으나, 그 영향으로 모든 물탱크에 물이 비어버리고 말았다.\n성대나라의 물관리 시스템은 다소 특수해서, 물은 항상 다음과 같은 방식으로 채워진다:\nA번 도시에 물을 채우기로 했다면, 수도에서부터 A번 도시까지 잇는 직선 경로에\r\n수도부터 차례대로 1L, 2L, ⋯이 채워져서 A번 도시에는 (수도부터 A번 도시까지의 도시 수) L 만큼 추가된다.\n예를 들어, 아래 그림과 같이 물탱크가 연결되어 있을 때, \"4번 도시에 물을 채운다\"라고 하면, 1번 도시에 1L, 4번 도시에 2L의 물이 추가된다. 만약 \"5번 도시에 물을 채운다\"라고 하면 1번 도시에 1L, 2번 도시에 2L, 5번 도시에 3L의 물이 추가된다.\n\n성대나라의 물탱크 관리 담당인 균관이는 어느 도시에 몇 리터의 물이 저장되어있는지 자신이 궁금해질 때마다 알기를 원한다. 균관이를 도와주는 프로그램을 만들어보자.\n",
        "input_text": "첫째 줄에 성대나라의 도시의 수 N (1 ≤ N ≤ 200,000)과 수도의 번호 C (1 ≤ C ≤ N)가 공백으로 구분되어 주어진다.\n둘째 줄부터 N-1개의 줄에 연결되어있는 두 도시의 번호 쌍 x, y가 공백으로 구분되어 주어진다(1 ≤ x, y ≤ N, x ≠ y). 물탱크의 연결 형태는 트리 구조임이 보장된다. N+1번째 줄에 질의의 수 Q(1 ≤ Q ≤ 200,000)가 주어진다. N+2번째 줄부터 Q개의 줄에 질의가 들어온다. 질의는 다음과 같이 두 종류 중 하나로 주어진다:\n\n1 A : A도시에 물을 채운다.\n2 A : 현재 A도시에 얼마만큼의 물이 채워져 있는지 출력하라.\n\n두 경우 모두 1 ≤ A ≤ N  을 만족한다.\n",
        "output_text": "2로 시작하는 질의가 올 때 마다 그 결과를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 31656.0,
        "time_median": 244.0,
        "length_median": 1531.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "449": {
        "problem_text": "어떤 그래프가 있다. 여기에 크루스칼이 공을 놓으려고 한다.\n크루스칼의 공은 이상한 특성을 가지고 있다. 처음에는 아주 낮은 온도를 갖고 있다가 시간에 지남에 따라서 점점 온도가 올라가는 것이다.\n그래프에도 이상한 특성이 있다. 크루스칼의 공이 어떤 간선을 지나서 다른 정점으로 이동할 때, 그 간선의 고유값보다 온도가 같거나 높아야만 그 간선을 통과할 수 있다는 것이다.\n당신이 궁금한 것은 x정점에 크루스칼이 공을 놓았을 때, y정점으로 갈 수 있는 최소온도와 그 때 공이 움직일 수 있는 범위 안의 정점 개수를 출력하는 것이다.\n",
        "input_text": "첫째 줄에는 그래프의 정점의 개수 n과 간선의 개수 m이 주어진다. 그리고 두 번째 줄에서 m+1번째 줄까지는 a b c의 형태로 a와 b를 연결하는 간선의 고유값이 c라는 의미이다. m+2번째 줄에는 알고 싶은 쿼리의 개수 Q가 주어진다. m+3번째 줄에서 m+Q+2번째 줄에는 x y가 주어진다. (1 ≤ n, m, Q ≤ 100,000, 1 ≤ c ≤ 1,000,000, x ≠ y) 단, 어떠한 두 간선도 고유값이 같은 경우는 없다.\n그래프 정점의 번호는 1부터 N까지 매겨져 있다.\n",
        "output_text": "첫 번째 줄에서 Q번째 줄까지 각각의 쿼리마다 x정점에 크루스칼의 공을 놓았을 때 y정점으로 갈 수 있게 되는 최소온도 c와 이때 공이 움직일 수 있는 범위에 포함되는 정점의 개수 v를 c v의 형태로 출력한다. 만약, x에서 y로 가는 경로가 없을 때는 -1을 출력한다.\n",
        "memory_median": 19834.0,
        "time_median": 220.0,
        "length_median": 2089.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "450": {
        "problem_text": "텔레토비 동산에 사는 너구리 구구는 입구, 거실, 주방, 안방, 공부방, 운동실, 음악실, 음식 창고 등 N개의 방을 가지고 있다. 입구를 포함한 모든 방은 1부터 N까지의 번호가 있고, 입구는 1번이다.  구구의 집으로 들어가는 입구는 한 개이며 입구과 모든 방들은 총 N-1개의 길로 서로 오고 갈 수 있다.\n구구는 스머프 동산에서 멜론아 아이스크림을 발견했다. 구구는 무더운 여름 햇살을 피해 최대한 입구에서 먼 방에 아이스크림을 숨기려고 한다.\n구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는 방까지 이동하는 거리를 구하여라.\n",
        "input_text": "첫째 줄에 정수 N(1 ≤ N ≤ 5,000)이 주어진다.\n다음 N-1개의 줄에 구구의 집의 모든 길의 정보가 정수 A, B, C(1 ≤ A, B ≤ N, 1 ≤ C ≤ 1,000,000,000)로 주어진다.\nA번 방과 B번 방 사이를 양방향으로 연결하는 길의 길이가 C임을 의미한다.\n",
        "output_text": "구구가 집 입구에서 멜론아 아이스크림을 숨기려고 하는 방까지 이동하는 거리를 구하여라.\n",
        "memory_median": 2504.0,
        "time_median": 4.0,
        "length_median": 799.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "451": {
        "problem_text": "스타트링크에서 매우 재미있는 게임을 만들었다. 이 게임은 정말 재미있다.\n게임에는 유저가 접속하는 기능이 있고, 각 유저는 가입할 때, 자신의 닉네임을 정해야 한다. 닉네임은 알파벳 소문자로만 이루어져 있고, 두 유저가 같은 닉네임을 정하는 것도 가능하다.\n이 게임은 유저의 닉네임을 이용해서 내부에 저장할 별칭을 만든다. 별칭은 유저에게 보여지지는 않고, 내부에서만 사용된다. 저장 공간을 최소로 하기 위해서 별칭의 길이를 최소로 하려고 한다.\n별칭은 유저 닉네임의 접두사(Prefix) 중에서 가장 길이가 짧은 것을 사용한다. 이때, 접두사가 이전에 가입한 닉네임의 접두사가 아니어야 한다. 가능한 별칭이 없는 경우에는 유저가 가입한 시점까지 같은 닉네임으로 가입한 사람의 수 x를 계산해야 한다. x가 1인 경우에는 닉네임을 별칭으로 사용하고, x가 2 이상인 경우에는 닉네임의 뒤에 x를 붙여서 별칭으로 사용한다.\n예를 들어, 닉네임을 \"baekjoon\"으로 정한 유저가 가입하면, 이 유저의 별칭은 \"b\"가 된다. \n그 다음, 닉네임이 \"startlink\"로 정한 유저가 가입하면, 이 유저의 별칭은 \"s\"이다. \"bakejoon\"이 닉네임인 유저가 가입하면, 별칭은 \"bak\"가 되고, \"beakjoon\"인 유저가 가입하면, 별칭은 \"be\"가 된다. 마지막으로 \"baekjoon\"으로 유저가 가입하면 별칭은 \"baekjoon2\"가 된다.\n유저가 가입한 순서대로 닉네임이 주어졌을 때, 각 유저의 별칭을 구해보자. 위의 규칙을 이용해 별칭을 정하면 두 유저가 같은 별칭을 갖는 것도 가능하다.\n",
        "input_text": "첫째 줄에 가입한 유저의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 유저의 닉네임이 가입한 순서대로 한 줄에 하나씩 주어진다. 닉네임은 알파벳 소문자로만 이루어져 있고, 길이는 10을 넘지 않는다.\n",
        "output_text": "유저가 가입한 순서대로 별칭을 한 줄에 하나씩 출력한다.\n",
        "memory_median": 66440.0,
        "time_median": 118.0,
        "length_median": 1051.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "452": {
        "problem_text": "IOI 를 개최하는 파타야 시는 경주대회인 IOR 2011 도 함께 개최하며 이를 위해 가장 적합한 경주코스를 찾고 있다.\n파타야 인근 지역에는 N 개의 도시가 있고 N-1 개의 고속도로가 이 도시들을 연결하고 있다. 각 고속도로는 양방향이며 서로 다른 두 개의 도시를 연결한다. 각 고속도로의 길이는 킬로미터 단위로 나타내며 정수 값이다. 그리고 임의의 두 도시는 직접 고속도로로 연결되지 않더라도 단 하나의 경로에 의해 연결된다. 즉, 같은 도시를 두 번 이상 방문하지 않고 한 도시에서 출발하여 다른 도시에 도착하는 방법은 유일하다.\nIOR 에 사용되는 경주코스는 출발 도시와 도착 도시가 서로 달라야 하며 길이는 정확하게 K 킬로미터인 경로이다. 그리고 충돌을 방지하기 위해 한 고속도로를 두 번 이상 사용하지 않는다. (따라서 한 도시도 두 번 이상 방문하지 않는다.) 또한 교통체증을 줄이기 위해 되도록 가장 작은 수의 고속도로를 사용하여 경주코스를 구성하려고 한다.\n다음의 파라미터를 받는 best_path(N,K,H,L) 함수를 작성하라.\n\nN – 도시의 수. 각 도시는 0 번부터 N-1 번까지 정수로 나타낸다.\nK – 경주코스의 길이.\nH – 각 고속도로를 나타내는 2 차원 배열. 고속도로 i (0 ≤ i < N-1)는 도시 H[i][0]와 도시 H[i][1]를 연결하는 도로이다.\nL – 고속도로의 길이를 나타내는 1 차원 배열. 고속도로 i (0 ≤ i < N-1)의 길이는 L[i]이다.\n\n배열 H 에 저장된 값은 0 이상 N-1 이하이다. 또한 배열 L 에 저장된 값은 0 이상 1 000 000 이하의 정수이다. 그리고 모든 도시들은 연결되어 있다.\n당신이 작성한 함수는 길이가 K 인 경주코스 중에서 고속도로 수가 가장 작은 경주코스의 고속도로 수를 반환한다. 만약 길이가 K 인 경주코스가 없다면 -1 을 반환하라.\n",
        "input_text": "첫째 줄에 N과 K가 주어진다. 둘째 줄부터 N-1개 줄에는 H[i][0], H[i][1], L[i]가 주어진다.\n",
        "output_text": "best_path(N,K,H,L)가 리턴한 값을 출력한다.\n",
        "memory_median": 34648.0,
        "time_median": 464.0,
        "length_median": 2267.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "453": {
        "problem_text": "1부터 N까지의 번호가 부여된 N개의 정점과 N-1개의 간선으로 구성된 트리가 있다. 이 트리의 루트는 1번 정점이며, 임의의 한 정점과 다른 정점 사이의 경로가 반드시 한 개 존재한다.\n트리의 각 정점은 특정 색깔을 가지고 있다. 편의상 색깔은 1 이상 C 이하의 자연수로 표현된다. 이때, 질의 f(v,c)를 다음과 같이 정의하자.\nf(v, c) : 정점 v가 루트인 부트리(sub-tree)에서 색깔이 c 이하인 정점의 개수\nM개의 질의 f(vi, ci)가 주어질 때, 각 질의에 대한 답을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 정점의 수를 나타내는 N(1 ≤ N ≤ 2×105), 질의의 개수를 나타내는 M(1 ≤ M ≤ 2×105), 정점의 색깔 종류를 나타내는 C(1 ≤ C ≤ N)가 공백 하나를 사이에 두고 차례로 주어진다.\n두 번째 줄에는 각 정점의 색깔을 나타내는 N개의 정수가 공백으로 구분되어 순서대로 주어진다. 첫 번째 수는 1번 정점의 색깔이며, ..., N 번째 수는 N번 정점의 색깔이다.\n세 번째 줄부터 N-1개의 줄에 걸쳐서 트리를 이루는 각 간선의 정보가 주어진다. 각 간선의 정보는 해당 간선을 이루는 서로 다른 두 정점의 번호로 구성된다. 각 정점의 번호는 1 이상 N 이하의 자연수이다.\n이후, 이어서 M개의 줄에 걸쳐서 i번째 줄에 i번째 질의의 정보 vi, ci가 공백으로 구분되어 주어진다. vi는 1 이상 N 이하의 정점 번호를 나타낸다. ci는 1 이상 C 이하의 색깔 정보를 나타낸다.\n",
        "output_text": "M개의 질의에 대한 정답을 모두 더한 뒤, 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 64004.0,
        "time_median": 432.0,
        "length_median": 1816.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "454": {
        "problem_text": "0이 하나 포함되어 있는 배열 A가 있다. 이때, 다음 쿼리를 수행해야 한다.\n\n1 x: A에 x를 추가한다.\n2 x: A에서 x를 제거한다. A에 x가 두 개 이상 있는 경우에는 하나만 삭제한다. 항상 A에 x가 있는 쿼리만 주어진다.\n3 x: A에 포함된 각각의 원소와 x를 XOR 연산을 한 다음, 가장 큰 값을 출력한다.\n\n",
        "input_text": "첫째 줄에 쿼리의 개수 M(1 ≤ M ≤ 200,000)이 주어진다. 둘째 줄부터 M개의 줄에 쿼리가 주어진다. 입력으로 주어지는 x의 범위는 109보다 작거나 같은 자연수이다.\n3번 쿼리는 하나 이상 주어진다.\n",
        "output_text": "쿼리를 수행한 결과를 출력한다.\n",
        "memory_median": 48200.0,
        "time_median": 224.0,
        "length_median": 1619.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "455": {
        "problem_text": "그래프의 한 정점 S에서 다른 한 정점 T로 이동하려 한다. 이동할 때 T에 가까워지며 이동하는 경우, 이를 합리적인 이동경로라 한다. 물론 이러한 경로는 최단경로가 아닐 수도 있다.\n그래프가 주어졌을 때 가능한 합리적인 이동경로의 개수를 구하는 프로그램을 작성하시오. S = 1, T = 2 인 경우로 한다.\n",
        "input_text": "첫째 줄에 정점의 개수 N(1 < N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 100,000이 주어진다. 다음 M개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 길이 C(0 < C ≤ 10,000)인 간선으로 연결되어 있다는 의미이다. 두 정점은 최대 한 개의 간선으로만 연결될 수 있다. 간선은 방향성이 없다.\n",
        "output_text": "첫째 줄에 답을 출력한다. 답은 2147483647을 넘지 않는다.\n",
        "memory_median": 2576.0,
        "time_median": 4.0,
        "length_median": 1300.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "456": {
        "problem_text": "트리는 사이클을 갖지 않는 연결된 그래프이다.\n중앙 정점은 모든 정점으로 이르는 비용의 합이 가장 작은 정점이다. 트리의 정점 개수가 작은 경우에는 모든 경우의 수를 다 계산해보는 프로그램을 이용해 쉽게 구할 수 있다.\n\n위의 그림은 가중치가 있는 트리로, 정점의 개수는 5개이다. 이 트리의 중앙 정점은 B이다.\nB-A = 2, B-D = 7, B-C = 1, B-E = 7+5=12, 총: 2+1+7+12 = 22\nN이 큰 경우에 문제를 풀어보자.\n트리를 입력 받아, 모든 정점과 중앙 정점까지 비용의 합을 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫 줄에는 트리의 정점의 수 n이 주어진다. (1 ≤ n ≤ 10,000) 각 정점은 0번부터 n-1번까지 번호가 붙여져 있다. 다음 n-1개 줄에는 세 정수 a, b, w가 주어진다. (1 ≤ w ≤ 100) a와 b는 간선을 나타내고, w는 그 간선의 가중치이다.\n입력의 마지막 줄에는 0이 하나 주어진다.\n",
        "output_text": "각 테스트 케이스마다 모든 정점과 중앙 정점 사이의 비용의 합을 출력한다.\n",
        "memory_median": 3794.0,
        "time_median": 40.0,
        "length_median": 1367.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "457": {
        "problem_text": "사과나무는 나무(tree)의 일종으로, 각각의 정점에 정확히 한 개의 사과가 있고, 모든 내부 정점(자식이 있는 정점)이 최소 두 개의 자식을 갖는 나무이다. 예를 들면 아래의 그림은 사과나무의 예이다. 나무같이 보이기 위해서 그림은 루트를 아래에 그린다.\n\n이러한 사과나무에 서식하는 벌레를 생각해 보자. 이 벌레는 이 사과나무의 루트에서 DFS 순서로 탐색을 하게 된다. 자식이 여러 개인 경우에는 (뒤집혀진 그림에서) 왼쪽을 먼저 방문하게 된다. 이러한 탐색을 하면서, 새로운 노드를 방문할 때 0을, 모든 자식 노드를 방문하고 리턴할 때 1을 나열하면 하나의 이진 수열이 된다. 위의 그림으로 이진 수열을 만들면 다음과 같다.\n\n\n\n0\n0\n0\n1\n0\n1\n1\n0\n1\n1\n\n\n\n\na\nb\nc\n \nd\n \n \ne\n \n \n\n\n \n \n \nc\n \nd\nb\n \ne\na\n\n\n\n이진수의 각 숫자들은 그 숫자가 0이든 1이든 하나의 정점에 대응되게 된다. 즉 0의 경우에는 새로 방문되는 정점에 대응되고, 1의 경우에는 리턴하기 전에 있었던 정점에 대응된다. 위의 표에서는 각 숫자에 대응되는 정점도 표시하였다.\n이러한 사과나무에서 썩은 사과가 발견된 경우에는 가지를 잘라 내어야 한다. 만약 우리가 어떤 정점을 제거하면, 그 정점과 그 자손 정점들이 모두 제거되게 된다. 위의 예에서 b를 제거하면 b, c, d가 모두 제거되게 된다.\n만약 한 개의 사과가 썩은 경우라면 그 사과를 제거하면 되지만, 두 개의 사과가 썩은 경우라면 문제가 복잡해진다. 사과나무의 성질을 유지하기 위해서, 우리는 오직 한 개의 사과만 제거할 수 있다. 이 경우 루트를 제거하면 되지만, 루트를 제거하게 되면 멀쩡한 사과들을 많이 잃게 된다(제거되는 것은 잃는 것). 따라서 우리는 한 개의 사과를 제거하되, 이를 통해 두 개(이하)의 썩은 사과를 함께 제거하고, 그러면서도 가장 적은 개수의 멀쩡한 사과를 잃도록 잘라야 한다. 위의 예에서 c, d의 사과가 썩은 경우에는 b를 제거하면 된다.\n사과나무에 대한 정보가 주어졌을 때, 제거해야 하는 사과를 알아내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정점의 개수 N(1 ≤ N ≤ 2,000)이 주어진다. 둘째 줄에는 벌레가 만드는 2×N자리의 이진수가 주어진다. 셋째 줄에는 썩은 사과의 위치를 나타내는 두 정수 X, Y가 주어진다. 이는 2×N자리의 이진수에서 X번째의 숫자에 대응되는 정점과, Y번째 숫자에 대응되는 정점에 있는 사과가 썩었다는 의미이다. 이때 두 정점이 서로 같을 수도 있다.\n",
        "output_text": "첫째 줄에 제거해야 할 사과를 나타내는 두 정수 i, j를 출력한다. 제거해야 할 사과를 Z라고 했을 때, 이는 Z를 방문할 때의 0의 위치와 Z에서 리턴될 때의 1의 위치가 이진수에서 각각 i, j 번째임을 나타낸다.\n",
        "memory_median": 2110.0,
        "time_median": 0.0,
        "length_median": 1281.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "458": {
        "problem_text": "N개의 노드로 구성된 루트가 있는 트리가 다음과 같이 주어진다. 각 노드는 0부터 N-1까지의 번호로 구별되고, 0번 노드는 루트 노드이고, 나머지 노드 각각은 0번 노드의 자식 노드이다. \n트리에 적용할 수 있는 연산은 세 종류이며, 이를 통해 트리의 모양을 바꾸거나 트리 에지에 색칠을 할 수 있다. 각 연산과 그 의미는 다음과 같다. \n\npaint(a, b, c): a번 노드와 b번 노드를 잇는 최단 경로를 찾은 후, 경로 상에 있는 모든 에지를 색깔 c로 칠한다. \nmove(a, b): a번 노드의 부모 노드를 b번 노드로 바꾼다. 단, b번 노드는 a번 노드를 루트로 하는 부트리(subtree)에 속하지 않는다. 부모 노드를 바꾸기 전 a번 노드의 부모 노드를 p라 할 때, 새로운 에지 (a,b)는 원래의 에지 (a,p)의 색깔을 갖는다. \ncount(a, b): a번 노드와 b번 노드를 잇는 최단경로를 찾은 후, 그 경로 사이에 있는 에지에 칠해진 서로 다른 색깔의 개수를 출력한다. \n\n에지에 칠하는 색깔 c를 정수로 표시한다. 그리고 처음에는 모든 에지의 색깔이 0이라고 가정한다. \n예를 들어, 그림 1에서 보인 것처럼 6개의 노드로 구성된 초기 트리에 적용된 연산이 차례로\nmove(1,3); move(5,3); paint(5,4,8); move(3,4); paint(0,3,7); count(2,5);\n일 때, 각 연산을 실행한 후 어떻게 트리의 모양과 에지 색깔이 바뀌는지를 아래 그림 2부터 그림 4에서 차례대로 보였다. \n\n그림 1. 초기 형태\n\n그림 2. 좌측: move(1,3)을 실행한 후, 우측: move(5,3)을 실행 한 후\n\n그림 3. paint(5,4,8)을 실행한 후\n\n그림 4. 좌측: move(3,4)를 실행한 후, 우측: paint(0,3,7)을 실행한 후\n그리고, 마지막 연산 count(2,5)에 대한 결과로는 3을 출력하게 된다. 왜냐하면, 그림 4의 우측 그림에서 보듯이 2번 노드와 5번 노드 사이의 최단 경로 상에 있는 에지들에 칠해진 색깔이 {0,7,8}로 3가지이기 때문이다. \n트리에 대한 정보와 일련의 연산이 주어질 때, 각 연산을 효과적으로 실행하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 앞에서 설명한 트리의 노드 개수를 나타내는 정수 N(1 ≤ N ≤ 105)과 연산의 개수를 나타내는 정수 K(1 ≤ K ≤ 3×105)가 주어진다. 이어서 K 줄에 걸쳐 각 연산에 관한 정보가 한 줄에 하나씩 주어지는데, 각 줄에는 연산의 종류를 나타내는 정수 r(1 ≤ r ≤ 3)이 첫 번째로 주어진다.\n\nr = 1일 경우엔 연산이 paint 임을 의미하며, 세 정수 (a,b,c)가 추가로 같은 줄에 주어지는데, 여기서 a, b(0 ≤ a, b ≤ N-1)는 노드 번호를, c(0 ≤ c ≤109)는 색의 번호를 나타낸다.\nr = 2일 경우엔 연산이 move임을 의미하며, 두 정수 a, b(1 ≤ a ≤ N-1, 0 ≤ b ≤ N-1)가 추가로 같은 줄에 주어지는데, 이는 노드 번호를 나타낸다. \nr = 3일 경우엔 연산이 count임을 의미하며, 두 정수 a, b(0 ≤ a, b ≤ N-1)가 추가로 같은 줄에 주어지는데, 이는 노드 번호를 나타낸다. \n\n노드의 개수가 N인 트리의 초기 모양은 그림 1에서 보인 것처럼 0번 노드가 루트이고, 나머지 노드들의 부모 노드는 0번 노드이며, 초기 트리의 모든 에지 색깔은 0이라고 가정한 사실을 기억하기 바란다. \n또한, paint와 count 연산 시 a번 노드와 b번 노드 사이의 최단경로의 길이는 항상 1,000 이하이다.\n",
        "output_text": "입력에서 주어진 count 연산 각각에 대해, 그 순서대로 그 때의 결과 값을 한 줄에 출력한다. \n",
        "memory_median": 3196.0,
        "time_median": 876.0,
        "length_median": 1520.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "459": {
        "problem_text": "영선회사에는 매우 좋은 문화가 있는데, 바로 상사가 직속 부하를 칭찬하면 그 부하가 부하의 직속 부하를 연쇄적으로 칭찬하는 내리 칭찬이 있다. 즉, 상사가 한 직속 부하를 칭찬하면 그 부하의 모든 부하들이 칭찬을 받는다.\n이러한 내리 칭찬은 회사에 가장 큰 장점이 되었고, 사장 영선이는 이 장점을 이용하기 위하여 근무 시간 도중 도중 칭찬의 방향을 바꿀 것이다. 가장 처음에는 부하 직원 방향이다.\n칭찬에 대한 정보는 실시간으로 주어진다.\n입력으로 아래와 같은 쿼리가 주어질 것이다.\n\n1 i w: i번째 직원이 직속 상사로부터 w만큼 칭찬을 받는다. 만약, 칭찬의 방향이 상사 방향이라면, i번째 직원이 직속 부하 중 한 명으로부터 w만큼 칭찬을 받는다. (1 ≤ i ≤ n, 1 ≤ w ≤ 1,000)\n2 i: i번째 직원이 칭찬을 받은 정도를 출력한다.\n3: 칭찬의 방향이 부하 직원 방향이면 상사 방향으로, 상사 방향이면 부하 직원 방향으로 바꾼다.\n\n직속 상사와 직속 부하관계에 대해 주어지고, 쿼리가 주어졌을 때 2번 쿼리에 따라 출력하시오.\n",
        "input_text": "첫째 줄에는 회사의 직원 수 n명, 쿼리의 개수 m이 주어진다. 직원은 1번부터 n번까지 번호가 매겨져 있다. (2 ≤ n, m ≤ 100,000)\n둘째 줄에는 직원 n명의 직속 상사의 번호가 주어진다. 직속 상사의 번호는 자신의 번호보다 작으며, 최종적으로 1번이 사장이다. 1번의 경우, 상사가 없으므로 -1이 입력된다.\n다음 m줄에는 쿼리가 한 줄에 하나씩 주어진다.\n",
        "output_text": "2번 쿼리가 주어질 때마다, 알맞게 출력하시오.\n",
        "memory_median": 11252.0,
        "time_median": 56.0,
        "length_median": 2196.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "460": {
        "problem_text": "정점이 $N$개인 트리가 있다. 정점에는 1부터 $N$까지 번호가 붙어있다. 트리의 루트는 항상 1번 정점이며 맨 처음에는 모든 정점이 하얀색으로 칠해져 있는 상태이다.\n하나의 정점에 색칠하면 해당 정점 아래 있는 모든 정점이 같은 색으로 칠해진다. 색은 섞이지 않고 색칠할 때마다 그 색으로 덮어진다. 단, 하얀색으로 색칠할 수는 없다.\n아래 그림처럼 정점 10개로 구성된 트리가 있다고 가정을 해보자.\n\n[그림 1] 하얀색으로 칠해져 있는 트리\n3번 정점을 노란색으로 칠하면 그 아래 있는 정점 5, 6, 8, 9, 10 모두 노란색으로 칠해진다.\n\n[그림 2] 정점 3에 노란색을 칠한 후 트리의 상태\n그리고 정점 5에 파란색을 칠한다면 그 아래 있는 정점 8, 9, 10 모두 파란색으로 칠해진다.\n\n[그림 3] 정점 5에 파란색을 칠한 후 트리의 상태\n입력으로 트리의 정보와 정점의 색 정보가 주어진다. 색 정보는 음이 아닌 정수로 주어지며 값이 0인 경우는 항상 하얀색을 의미한다.\n하얀색을 제외한 색만 사용해서 모든 정점을 주어진 색으로 칠하고 싶을 때 최소 몇 번 색을 칠해야 모든 정점을 원하는 색으로 칠할 수 있는지 구해보자.\n",
        "input_text": "첫째 줄에 트리를 구성하는 정점의 개수 $N(1 ≤ N ≤ 200,000)$이 주어진다.\n둘째 줄에 1번 정점부터 $N$번 정점까지 각 색 정보 $C_i (0 ≤ C_i ≤ N)$가 공백으로 구분되어 주어진다.\n셋째 줄부터 $N - 1$개의 줄에 걸쳐 연결된 두 정점 $a, b(1 ≤ a, b ≤ N$, $a ≠ b)$가 공백으로 구분되어 주어진다.  \n모든 정점을 칠할 수 있는 입력만 주어진다.\n",
        "output_text": "하얀색을 제외한 색만 사용해서 모든 정점을 원하는 색으로 칠하기 위해 최소 몇 번 칠하면 되는지 출력한다.\n",
        "memory_median": 21436.0,
        "time_median": 136.0,
        "length_median": 754.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "461": {
        "problem_text": "$1$부터 $N$까지 $N$개의 정점으로 이루어진 트리가 있다. $i$번째 간선은 서로 다른 두 정점 $A_i$, $B_i$를 잇는다. ($1 ≤ i ≤ N - 1$)\n$N$개의 정점 중 몇 개를 골라, 그 고른 정점들을 $S = \\{s_1, s_2, \\dots , s_K\\}$라고 하자. 또한, $s_i = v$를 만족하는 $i$ ($1 ≤ i ≤ K$)가 존재할 때, 정점 $v$가 $S$에 속한다고 부르자.\n$S$에 속하는 서로 다른 두 정점 $u$, $v$에 대하여, $S$에 속하는 정점만을 이용하여 트리 위에서 $u$, $v$ 사이를 오갈 수 있다면, “$u$와 $v$는 $S$ 위에서 연결되어 있다”고 하자.\n예를 들어, 아래와 같은 트리를 생각하자. ($N = 7$)\n\n만일, $K = 6$, $S = \\{1, 2, 3, 4, 5, 6\\}$라면, “$1$과 $2$”, “$3$과 $5$”, “$4$와 $6$”은 각각 서로 $S$ 위에서 연결되어 있다. 그러나, “$1$과 $6$”, “$2$와 $7$”은 각각 서로 $S$ 위에서 연결되어 있지 않다.\n다음 조건을 모두 만족하는 정점쌍 $(u, v)$의 개수를 $S$의 연결 강도라고 하자.\n\n$u$와 $v$는 서로 다른 두 정점.\n$1 ≤ u < v ≤ N$.\n$u$와 $v$는 $S$ 위에서 연결되어 있다.\n\n고른 정점들 $S$가 주어질 때, $S$의 연결 강도를 계산하는 프로그램을 작성하라. 여러분은 이러한 질의 $Q$개에 대하여 모두 답해야 한다.\n",
        "input_text": "첫 번째 줄에 정수 $N$이 주어진다.\n다음 ($N - 1$)개의 줄에 각 간선에 대한 정보가 주어진다. 이 중 $i$ ($1 ≤ i ≤ N - 1$)번째 줄에는 두 정수 $A_i$, $B_i$가 주어진다.\n다음 줄에 정수 $Q$가 주어진다.\n다음 $Q$개의 줄에 각 질의에 대한 정보가 주어진다. 이 중 $i$ ($1 ≤ i ≤ Q$)번째 줄은 $i$번째 질의를 나타내며, 정수 $K$와 $K$개의 정수 $s_1, \\dots , s_K$가 차례대로 주어진다.\n",
        "output_text": "첫 번째 줄부터 $Q$개의 줄에 걸쳐, 각 질의에 대한 답을 출력한다. 이 중 $i$ ($1 ≤ i ≤ Q$)번째 줄에는 $i$번째 질의에서 주어진 $S$에 대하여, $S$의 연결 강도를 출력한다.\n",
        "memory_median": 27686.0,
        "time_median": 398.0,
        "length_median": 1495.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "462": {
        "problem_text": "총 N개의 정점과 M개의 간선으로 이루어져 있는 무방향 가중치 연결 그래프 G가 있다. 그래프 G는 루프가 없고, 두 정점을 연결하는 간선은 최대 1개이다.\n각각의 간선 (u, v)에 대해서, 그 간선을 포함하는 최소 스패닝 트리의 가중치 합을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정점의 개수 N과 간선의 개수 M (2 ≤ N ≤ 200,000, N-1 ≤ M ≤ 200,000)\n둘째 줄부터 M개의 줄에 간선의 정보 u, v, w가 주어진다. u와 v를 연결하는 간선의 가중치가 w라는 뜻이다. (1 ≤ u, v ≤ n, u ≠ v, 1 ≤ w ≤ 109) \n",
        "output_text": "각각의 간선마다 그 간선을 포함하는 최소 스패닝 트리의 가중치 합을 출력한다. 간선은 입력받은 순서대로 출력한다.\n",
        "memory_median": 57712.0,
        "time_median": 374.0,
        "length_median": 2658.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "463": {
        "problem_text": "상근이는 \"얼음을 꿈꾸다\" 여행사의 사장이다. 이 여행사는 남극 근처의 섬 N개를 구매해 당일치기 여행을 제공하고 있다. 관광객들에게 가장 인기 있는 동물은 황제 펭귄으로 섬에서 쉽게 찾을 수 있다.\n여행사는 점점 인기를 얻게 되었고, 이제 보트를 이용하는 것이 효율적이지 않은 상황까지 이르렀다. 상근이는 섬 사이에 다리를 건설해 관광객을 버스로 이동시키려고 한다. 상근이는 컴퓨터 프로그램을 이용해서 다리를 건설하는 과정을 관리하려고 한다.\n섬은 1번부터 N번까지 번호가 매겨져 있다. 가장 처음에는 아무 다리도 없으며, 각 섬에 펭귄이 몇 마리 살고있는지는 모두 알고있다. 펭귄의 수는 변할 수 있다. 하지만, 항상 0보다 크거나 같고, 1000보다 작거나 같다.\n상근이의 프로그램은 다음과 같은 세 가지 명령을 수행할 수 있어야 한다.\n\n\"bridge A B\" - 섬 A와 B사이에 다리를 건설하는 명령이다. (A와 B는 다르다) 이전까지 지어진 다리를 이용해서 이동할 수 없는 경우에만 다리를 지어야 한다. 다리를 지어야 하면 \"yes\", 지을 필요가 없이 이미 이동할 수 있으면 \"no\"를 출력한다.\n\"penguins A X\" - 섬 A에 살고있는 펭귄의 수를 다시 세보니 X마리가 되었다는 명령이다. 아무것도 출력할 필요가 없다.\n\"excursion A B\" - 관광객들이 섬 A에서 시작해 B에서 끝나는 여행 경로를 이용하는 명령이다. A에서 B로 갈 수 있는 경우에는 이동하는 섬에 있는 모든 펭귄의 수를 구해 출력한다. (A와 B 포함) 이동할 수 없는 경우에는 \"impossible\"를 출력한다.\n\n상근이의 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 섬의 수 N (1 ≤ N ≤ 30,000)이 주어진다.\n둘째 줄에는 각 섬에 있는 펭귄의 수가 주어진다.\n셋째 줄에는 명령의 개수 Q (1 ≤ Q ≤ 300,000)가 주어진다.\n다음 Q개 줄에는 문제에서 주어진 명령 중 하나가 주어진다.\n",
        "output_text": "\"bridge\"나 \"excursion\" 명령이 주어질 때 마다 출력한다.\n",
        "memory_median": 16200.0,
        "time_median": 320.0,
        "length_median": 3690.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "464": {
        "problem_text": "아침 산책을 즐기는 서현이는 서울과학고에 입학해서도 아침 산책을 즐기려고 합니다. 서현이는 산책을 위해 서울과학고의 지리를 분석했고, 그 결과 서울과학고를 $N$개의 장소를 $N-1$개의 길이 잇는 트리 형태로 단순화시킬 수 있었습니다. 트리 구조이므로, 모든 장소를 몇 개의 길을 통해 오고갈 수 있습니다.\n아침 산책은 시작점과 도착점을 정하고, 시작점에서 도착점까지 트리 위의 단순 경로(같은 점을 여러 번 지나지 않는 경로)를 따라 걷게 됩니다. 트리 위의 두 점 사이의 경로는 유일하므로 시작점과 도착점이 정해지면 경로는 유일하게 결정됩니다.\n$N$개 장소 중에 일부 장소는 실내이며, 나머지 장소는 실외입니다. 서현이는 산책을 시작하기 전부터 운동을 하는 것을 원치 않기 때문에, 산책의 시작점과 끝점은 모두 실내여야 합니다. 또한, 산책 도중에 실내 장소를 만나면 산책을 그만두고자 하는 욕구가 생기기 때문에, 산책 경로 위에 시작점과 끝점을 제외하고 실내 장소가 있으면 안 됩니다.\n서현이는 매일 다른 산책 경로를 걷고자 합니다. 서로 다른 산책 경로가 몇 가지 있는지 구해 봅시다.\n",
        "input_text": "첫 줄에는 정점의 수 $N$이 주어집니다.\n둘째 줄에는 1과 0으로 이루어진 길이 $N$의 문자열 $A$가 주어집니다. $i$번째 문자 $A_i$가 1일 경우 $i$번 장소는 실내이며, 0인 경우 $i$번 장소는 실외입니다.\n셋째 줄부터 $N+1$번 줄까지는 $i+2$번 줄에 트리의 각 간선을 나타내는 두 정수 $u_i$, $v_i$가 주어집니다. 이는 $i$번째 간선이 $u_i$번 정점과 $v_i$번 정점을 연결한다는 의미입니다.\n",
        "output_text": "가능한 서로 다른 산책 경로의 수를 출력합니다.\n",
        "memory_median": 22556.0,
        "time_median": 140.0,
        "length_median": 1075.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "465": {
        "problem_text": "팀포2 덕후 연수는 팀포2를 다운받던 도중 하드 용량이 부족하다는 것을 알았다. 이때는 침착하게 팀포2를 하지 말거나 하드를 새로 사면 되지만 불가능했고, 결국 하드에서 쓸모없는 파일을 지워야만 한다.\n연수는 또한 턱스 덕후여서 리눅스를 사용중이다. 리눅스에서 현재 디렉토리의 특정 파일을 지우려면 \"rm 파일명\"의 형식을 갖춰 명령하면 된다. 그러나 파일 개수가 너무 많을 경우 일일이 다 칠 수 없기에, 와일드카드 '*'를 사용할 수도 있다. \"rm 문자열*\" 형식으로 명령하면 현재 디렉토리에서 파일 이름이 \"문자열\"이거나 \"문자열\"로 시작하는 모든 파일이 한번에 삭제된다! 그러나 지워서는 안 되는 파일들 또한 존재한다. rm 명령어를 잘못 사용하여 이러한 파일들을 지우지 않도록 조심해야 할 것이다. 때에 따라서 \"rm *\"도 사용할 수 있긴 하다. 현재 디렉토리의 모든 파일을 지우고 싶을 때만...\n모든 파일이 디렉토리 하나에 존재하고 연수가 그 디렉토리에 있을 때, 지우고 싶은 파일들을 모두 지우는 데 필요한 최소 rm 명령 횟수를 구하시오. 단, 사용할 수 있는 와일드카드는 '*' 뿐이며 반드시 제일 끝에만 사용해야 한다. 예를 들면 \"rm *.txt\"는 사용할 수 없다.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 주어지며, 첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 다음과 같은 형식이다.\n\n첫째 줄에 지워야 하는 파일의 개수 N1이 주어진다. (1 ≤ N1 ≤ 1000)\n이어서 N1개의 줄에 지워야 하는 파일명이 줄마다 하나씩 주어진다.\n이어서 지우면 안 되는 파일의 개수 N2가 주어진다. (0 ≤ N2 ≤ 1000)\n이어서 N2개의 줄에 지우면 안 되는 파일명이 줄마다 하나씩 주어진다.\n\n파일 이름은 모두 1글자 이상 20글자 이하이며, 영문 대소문자, 숫자, 점(.)으로만 이루어져 있다. 하나의 테스트 케이스에 등장하는 모든 파일 이름은 서로 다르다.\n",
        "output_text": "각 테스트 케이스마다 한 줄에 걸쳐 문제의 정답을 출력한다.\n",
        "memory_median": 21782.0,
        "time_median": 96.0,
        "length_median": 1624.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "466": {
        "problem_text": "N개의 정점으로 이루어진 트리(무방향 사이클이 없는 연결 그래프)가 있다. 정점은 1번부터 N번까지 번호가 매겨져 있고, 간선은 1번부터 N-1번까지 번호가 매겨져 있다. 가장 처음에 모든 정점의 색은 흰색이다.\n아래의 두 쿼리를 수행하는 프로그램을 작성하시오.\n\n1 i: i번 정점의 색을 바꾼다. (흰색 -> 검정색, 검정색 -> 흰색)\n2 v: 1번 정점에서 v번 정점으로 가는 경로에 존재하는 첫 번째 검정 정점의 번호를 출력한다. 만약, 그러한 정점이 없으면 -1을 출력한다.\n\n",
        "input_text": "첫째 줄에 N (2 ≤ N ≤ 100,000)이 주어진다.\n둘째 줄부터 N-1개의 줄에는 i번 간선이 연결하는 두 정점 번호 u와 v가 주어진다.\n다음 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.\n다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다.\n",
        "output_text": "각각의 2번 쿼리의 결과를 순서대로 한 줄에 하나씩 출력한다.\n",
        "memory_median": 22560.0,
        "time_median": 104.0,
        "length_median": 2559.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "467": {
        "problem_text": "N개의 정점으로 구성된 트리가 있다. 각 정점은 1번부터 N번까지 번호가 매겨져있고, 1 이상 10만 이하의 자연수로 표현되는 색깔을 하나 갖고 있다. 루트는 1번 정점이고, 트리이기 때문에 임의의 서로 다른 두 정점을 잇는 경로는 반드시 한 개 존재한다.\n정점 u와 v를 잇는 경로가 존재하면 u에서 v로 갈 수 있다고 하자.\n여러분은 아래 두 가지 쿼리를 처리해야 한다.\n\n1 a : 정점 a와 a의 부모 정점을 연결하는 간선을 제거한다. (해당 간선이 존재하는 경우에만 주어진다.)\n2 a : 정점 a에서 갈 수 있는 정점들만 보았을 때, 색깔의 종류의 개수를 출력한다.\n\n",
        "input_text": "첫 번째 줄에는 정점의 개수 N(1 ≤ N ≤ 100,000)과 2번 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다.\n다음 N-1개 줄의 i번째 줄에는 정점 i+1의 부모 정점을 나타내는 정수 p(1 ≤ p ≤ N)가 주어진다.\n다음 N개 줄의 i번째 줄에는 정점 i의 색깔을 나타내는 정수 c(1 ≤ c ≤ 100,000)가 주어진다.\n다음 N+Q-1개의 줄에는 여러분이 처리해야 할 쿼리가 주어지는데, 1번 쿼리는 N-1개, 2번 쿼리는 Q개 주어진다.\n쿼리는 한 줄에 하나씩 쿼리의 종류를 나타내는 X(1 ≤ X ≤ 2)와 쿼리에서 처리할 정점의 번호 a(1 ≤ a ≤ N)가 주어진다.\n입력은 모두 자연수로 주어진다.\n",
        "output_text": "Q개의 2번 쿼리에 대한 답을 순서대로 한 줄에 하나씩 출력한다.\n",
        "memory_median": 39624.0,
        "time_median": 400.0,
        "length_median": 1292.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "468": {
        "problem_text": "총 N명의 직원이 재직 중인 회사가 있고, 각 직원은 1번부터 N번까지 번호가 매겨져 있다. 이 회사는 수직적인 구조를 가지고 있고, 대표를 제외한 모든 직원은 한 명의 직속 상사를 갖고 있다. 직속 상사의 직속 상사도 상사이고, 직속 상사의 상사도 상사이다. 따라서, 대표를 제외한 모든 직원은 한 명 이상의 상사를 가지고 있고, 한 명의 직속 상사를 갖고 있다. 상사가 없는 사람은 대표이다.\n이 회사가 가지고 있는 문화는 아래와 같은 쿼리로 나타낼 수 있다. 가장 처음에 컴퓨터는 켜져있는 상태이다.\n\n1 i: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 켠다.\n2 i: i번 직원을 상사로 가지고 있는 모든 직원은 컴퓨터를 끈다.\n3 i: i번 직원을 상사로 가지고 있는 직원 중에서 컴퓨터가 켜져있는 사람의 수를 출력한다.\n\n",
        "input_text": "첫째 줄에 직원의 수 N (1 ≤ N ≤ 100,000)이 주어진다.\n둘째 줄에는 각 직원의 상사 번호가 주어진다. i번째 정수는 i번 직원의 직속 상사 번호이다. 대표의 번호는 1번이고, 상사 번호로 0이 주어진다.\n셋째 줄에 쿼리의 수 M (1 ≤ M ≤ 100,000)이 주어진다. \n넷째 줄부터 M개의 줄에 쿼리가 주어진다. (1 ≤ i ≤ N)\n",
        "output_text": "3번 쿼리의 결과를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 15808.0,
        "time_median": 84.0,
        "length_median": 2211.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "469": {
        "problem_text": "이 이야기는 세상의 태초에, IOI라는 것은 꿈꿀 수도 없었던 아주 먼 옛날에 생긴 일이다.\n0, …, N - 1 까지 번호가 붙여진 N 개의 빌라봉(호수)이 있는 땅에 큰 뱀이 살고 있다. 이 땅에는 M 개의 길이 있고, 각각의 길은 한 쌍의 빌라봉을 연결하며, 이 길을 통해 뱀은 양방향으로 이동할 수 있다. 임의의 빌라봉 쌍은 길을 따라서 (직접 또는 간접적으로) 최대 하나의 경로로 연결이 되어 있다. 단, 어떤 빌라봉 쌍들은 연결되어 있지 않을 수도 있다 (즉, M ≤ N - 1 이다). 뱀이 하나의 길을 지나가는 데에는 며칠의 시간이 걸리는데, 이 시간은 길마다 다를 수 있다.\n뱀의 친구 캥거루는 N - M - 1 개의 새로운 길을 만들어 뱀이 모든 빌라봉 쌍 사이를 오갈 수 있도록 하고 싶다. 캥거루는 임의의 두 빌라봉을 선택하여 그 사이에 길을 만들 수 있으며, 캥거루가 만든 길을 통행하는 데에는 항상 L 일이 걸린다.\n캥거루는 또한 뱀이 최대한 빨리 이동할 수 있기를 원한다. 캥거루는 임의의 두 빌라봉 사이를 오가는데 드는 최대 시간이 최소가 되도록 길을 만들 것이다. 캥거루가 이렇게 길을 만든 뒤 뱀이 두 빌라봉 사이를 오가는데 드는 최대 시간을 계산하시오.\n\n위 그림에는 N = 12 개의 빌라봉과 M = 8 개의 길이 있다. 새로 만들어지는 길을 뱀이 통행하는 데에는 2일이 걸린다고 가정하자 (즉, L = 2 이다). 그러면 캥거루는 아래와 같이 세 개의 길을 만들 수 있다.\n\n빌라봉 1과 2 사이,\n빌라봉 1과 6 사이,\n빌라봉 4와 10 사이.\n\n\n모든 길이 만들어진 뒤의 모습이 위 그림에 나타나 있다. 여기서 두 빌라봉 사이의 최대 통행 시간은 18일인데 (빌라봉 0과 11 사이), 이것이 가능한 가장 작은 값이다. 즉, 캥거루가 어떤 식으로 새로운 길을 만들더라도, 뱀이 통행하는 데 18일 이상이 걸리는 빌라봉 쌍이 항상 존재한다.\n",
        "input_text": "첫째 줄에는 N, M, L이 주어진다. 둘째 줄부터 M개 줄에는 A[i] B[i] T[i]가 주어진다.\n\nN: 빌라봉의 개수\nM: 이미 존재하는 길들의 개수\nL: 뱀이 새로 지어진 길을 통행하는데 걸리는 시간 (일 단위).\nA, B, T: 이미 존재하는 길들이 연결하는 빌라봉들과 각각을 통행하는데 걸리는 시간을 나타내는 길이가 M인 배열들. i 번째 길은 빌라봉 A[i1]과 B[i-1]을 이으며, 통행 시간은 양방향 모두 T[i-1]일이다.\n\n",
        "output_text": "첫째 줄에 모든 빌라봉이 연결되고 최대 통행시간이 최소가 되도록 N-M-1개의 길을 만든 뒤의 최대 통행 시간을 출력한다.\n",
        "memory_median": 16068.0,
        "time_median": 88.0,
        "length_median": 1968.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "470": {
        "problem_text": "㈜승범이네는 사장 승범이를 포함한 N명의 직원이 모두 판매원인 다단계 회사이다. 사장 승범이를 제외한 모든 판매원에게는 사수가 한 명씩 배정된다. 만약 판매원 A가 B의 사수라면, B를 A의 부사수라고 부른다.\n작년에 창설된 ㈜승범이네는 큰 수익률을 기록하고 대기업으로 거듭났다. ㈜승범이네의 더 큰 성장을 위해 멘토링 제도를 도입하려고 한다. 승범이는 사수와 부사수 관계에 있는 두 판매원을 각각 서로의 멘토와 멘티로 만들 수 있으며, 이 경우 두 판매원이 멘토링 관계에 있다고 한다. 한 판매원은 최대 1개의 멘토링 관계에만 속할 수 있다. 즉, 한 판매원이 여러 명의 멘토가 되거나, 여러 명의 멘티가 되거나, 멘토인 동시에 멘티가 될 수는 없다. 물론 멘토링 관계에 속하지 않는 직원이 있을 수도 있다.\n이렇게 만들어진 멘토링 관계에서는 시너지 효과가 발생한다. 승범이는 모든 판매원의 실력을 수치화시켰으며, 한 멘토링 관계에서 발생하는 시너지는 멘토와 멘티의 실력의 곱과 같다는 것을 발견했다. 승범이는 적절하게 멘토링 관계를 만들어, 모든 멘토링 관계에서 발생하는 시너지의 합을 최대로 만들려고 한다.\n  \n위 그림은 ㈜승범이네의 회사 구조와 멘토링 관계를 나타낸 예시이다. 각 원은 한 명의 판매원을 의미하며, 원 안에 쓰인 숫자는 그 판매원의 실력이다. 화살표는 사수-부사수 관계를 나타낸다. 이 경우 가능한 시너지의 최대 합은 5×7 + 4×3 + 3×3 + 4×5 + 3×1 = 79이다.\n",
        "input_text": "첫 번째 줄에 판매원들의 수 N(2 ≤ N ≤ 200,000)이 주어진다. 판매원들은 1번, 2번, …, N번으로 번호가 매겨지며, 승범이는 항상 1번이다.\n두 번째 줄에 2번 판매원부터 N번 판매원의 사수가 순서대로 공백으로 구분되어 주어진다. \n세 번째 줄에 i번 판매원의 실력을 나타내는 정수 A1, A2, …, AN (0 ≤ Ai ≤ 100)이 순서대로 공백으로 구분되어 주어진다.\n",
        "output_text": "첫 번째 줄에 모든 멘토링 관계에서 발생하는 시너지의 합의 최댓값을 출력한다. 만약 멘토링 관계가 하나도 성립될 수 없을 경우, 0을 출력한다.\n",
        "memory_median": 31846.0,
        "time_median": 136.0,
        "length_median": 992.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "471": {
        "problem_text": "1번부터 N번까지 번호가 붙여진 N개의 정점과 N-1개의 간선으로 구성된 트리가 있다. 트리의 각 정점에는 가중치가 있다. 이때 M개의 질문에 대해 다음의 연산을 수행해야 한다.\n연산 X Y K : 정점 X와 Y를 잇는 경로 상에서 K번째로 작은 가중치를 출력한다.\n",
        "input_text": "첫째 줄에는 두 개의 양의 정수 N과 M이 주어진다. (1 ≤ N, M ≤ 100,000)\n둘째 줄에는 각 정점의 가중치를 나타내는 N개의 정수가 주어진다. i번째 정수는 i번 정점의 가중치이다. 이 가중치는 모두 서로 다른 값들이며 int 범위이다.\n다음 N-1개의 각 줄에는 트리의 간선 (X, Y)를 나타내는 두 정수 X와 Y가 주어진다.\n다음 M개의 각 줄에는 연산을 나타내는 세 양의 정수 X Y K가 주어진다. X, Y는 1 이상이고 N 이하이다. K는 1 이상이고 X와 Y를 잇는 경로 상의 정점의 개수 이하이다. X와 Y가 같다면, 경로 상의 정점의 개수는 1개라 간주한다.\n",
        "output_text": "M개의 줄에 걸쳐서 각 연산에 해당하는 답을 출력한다.\n",
        "memory_median": 78378.0,
        "time_median": 554.0,
        "length_median": 3176.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "472": {
        "problem_text": "상근이는 유전자 조작을 통해 줄기 두 개로 이루어진 식물을 만들었다. 이 식물은 줄기의 x좌표 L, R과 높이 H로 나타낼 수 있다. 아래 그림은 L=2, R=5, H=4인 식물이다.\n\n상근이는 매일 매일 화단에 식물을 하나씩 심는다. 첫 번째 날에 심은 식물의 높이는 1이고, 그 다음날에 심은 식물은 전날에 심은 식물의 높이보다 1 크다.\n새 식물의 줄기가 다른 식물의 수평 선분과 교차하는 경우가 있다. 이러한 경우에 그 위치에는 꽃이 하나 피게 된다. (이미 꽃이 있는 경우에는 꽃이 더 피지 않는다) 점에서 접하는 경우에는 꽃이 피지 않는다.\n아래 그림은 예제를 나타낸 것이다.\n\n모든 식물의 좌표가 주어졌을 때, 매일 매일 피는 꽃의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 식물을 심은 날의 수 N (1 ≤ N ≤ 100,000)이 주어진다.\n다음 N개 줄에는 매일 매일 심은 식물의 두 줄기 좌표 L과 R이 주어진다. (1 ≤ L < R ≤ 100,000) \n",
        "output_text": "총 N개의 줄에 매일 매일 핀 꽃의 수를 출력한다.\n",
        "memory_median": 3588.0,
        "time_median": 84.0,
        "length_median": 1222.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "473": {
        "problem_text": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.\n\ni j : Ai, Ai+1, ..., Aj에서 가장 큰 연속합을 출력한다. (1 ≤ i ≤ j ≤ N)\n\n수열의 인덱스는 1부터 시작한다.\n연속합은 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합이며, 수는 한 개 이상 선택해야 한다.\n",
        "input_text": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)\n둘째 줄에는 A1, A2, ..., AN이 주어진다. (-1,000 ≤ Ai ≤ 1,000)\n셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)\n넷째 줄부터 M개의 줄에는 쿼리가 주어진다.\n",
        "output_text": "쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.\n",
        "memory_median": 10208.0,
        "time_median": 96.0,
        "length_median": 1679.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "474": {
        "problem_text": "그래프 G는 정점의 집합 V와 간선의 집합 E로 이루어져 있고, G = (V, E)로 나타낸다. 대부분의 경우에 V와 E는 명시되어 있다. 일부 그래프의 경우에는 집합이 명시되어 있지 않다. 예를 들어, 순열 그래프는 간선의 집합이 명시되어 있지 않다.\n{1, 2, 3, 4, 5}로 이루어진 두 순열 (2, 5, 4, 1, 3)과 (1, 5, 3, 2, 4)가 있다. 평행선을 그리고, 그 위에 순열에 적힌 숫자 순서대로 정점을 그린다. 그 다음 같은 숫자끼리 선분을 연결한다. 아래 그림과 같이 교차하는 선분의 쌍은 총 여섯 개라는 것을 알 수 있다.\n\n교차하는 쌍은 순열 그래프의 간선이 된다. 순열 그래프의 정점은 숫자가 되고, 간선은 교차하는 쌍이 된다. 위의 예를 이용해 순열 그래프를 만들면 V = {1, 2, 3, 4, 5}, E = {(1,2), (1,4), (1,5), (2,3), (2,5), (3,4)}. 위의 두 순열을 이용해 순열 그래프를 그리면 아래 그림과 같이 된다.\n\n{1, 2, ..., n}으로 이루어진 두 순열이 주어졌을 때, 두 순열을 이용해 만든 순열 그래프의 간선의 개수를 구하는 프로그램을 작성하시오. 예를 들어, (2, 5, 4, 1, 3)과 (1, 5, 3, 2, 4)로 만든 순열 그래프의 간선의 개수는 6개이다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n이 주어진다. 둘째 줄과 셋째 줄에는 두 순열이 주어진다. 순열은 {1, 2, ..., n}으로 이루어져 있고, 공백으로 구분되어져 있다. (1 ≤ n ≤ 100,000)\n",
        "output_text": "각 테스트 케이스 마다, 입력으로 주어진 두 순열로 만든 순열 그래프의 간선의 개수를 출력한다.\n",
        "memory_median": 4188.0,
        "time_median": 2464.0,
        "length_median": 1133.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "475": {
        "problem_text": "여우가 정보섬에 올라왔다!\n오늘도 하늘에는 아름다운 별들이 빛나고 있다. 정보섬은 언덕 꼭대기에 위치해 있기 때문에 별이 잘 보이기로 유명하다. 그래서인지, 여우 한 마리가 정보섬에 올라와 밤하늘을 바라보며 별자리를 만들고 있다. 여우는 세 개의 별을 연결하여 V형 별자리를 만드는데, 그 이유는 V가 자신의 얼굴과 닮았기 때문이라나 뭐라나. 여우는 자신의 시점을 기준으로 생각하기 때문에, V가 회전한 모양(<, >, ㄴ, ㄱ, ^ 등)은 V라고 생각하지 않는다.\n여우는 만들 수 있는 V형 별자리의 총 개수가 궁금해졌다. 그러나 일일이 세보기에는 별이 너무 많았기 때문에, 여우는 뛰어난 프로그래머인 당신에게 도움을 요청했다! 귀여운 여우를 위해 얼마나 많은 V형 별자리가 만들어질 수 있는지 계산해 주자.\nV형 별자리를 명확하게 정의하면 다음과 같다. 세 별 (s,t,u)가 s.x < t.x < u.x이고 s.y > t.y < u.y이면 V형 별자리이다. 예를 들어 아래의 '정보섬의 밤하늘 참고도'에서 (a,b,c)는 V형 별자리를 이루지만 (d,b,c)는 d.x < b.x가 아니므로 V형 별자리가 아니다. V형 별자리의 개수를 셀 때, 한 별이 여러 별자리에 속할 수 있다.\n\n답이 매우 커질 수 있으므로 (109+7)로 나눈 나머지를 출력한다.\n",
        "input_text": "첫 줄에 별의 개수 N이 주어진다. 그 다음 줄부터 N개의 줄에 걸쳐 별의 좌표 x y가 주어진다.\n",
        "output_text": "(만들 수 있는 V형 별자리의 개수) mod (109+7)을 출력한다.\n",
        "memory_median": 13520.0,
        "time_median": 192.0,
        "length_median": 1697.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "476": {
        "problem_text": "You are a president deeply loved by many folks in your country. Every time you go on a parade (which is your main job, what else should a president do), the folks would throw eggs at you — because you love eggs! The folks passionately send their eggs to you, and you always can catch the eggs. In fact, egg-catching is exactly what makes you look forward to the parade every day! A folk would throw an egg at you for each time your parade comes to his home. You are given n coordinates on a 2D-map, these are where the folks that will throw an egg at you each time they see you on a parade. Note that the coordinates may repeat, since several folks may live together. There are in total m days left in your term and the area to parade each day are set. A parade always takes place in an axis-parallel rectangle area, as stated clearly in the constitution and as the president you have no choice but to follow it. You are given m 2D-ranges [ℓ, r]×[b, t] describing the parades.\n",
        "input_text": "Input begins with an integer T (1 ≤ T ≤ 20) indicating the number of test cases. The first line of each test case contains two integers n (0 < n ≤ 10000) and m (0 ≤ m ≤ 50000) separated by a blank where n is the number of folks throwing eggs and m is the number of days left in your term. Each of the following n lines contains two integers x and y (0 ≤ x, y ≤ 105) indicating that there is a folk’s home located at (x, y). Then m more lines follow. Each of them contains four integer ℓ, r, b, t (0 ≤ ℓ ≤ r ≤ 105, 0 ≤ b ≤ t ≤ 105) separated by blanks. [ℓ, r] × [b, t] corresponds to a parade area.\n",
        "output_text": "For each test case, output the total sum of eggs you receive on one line.\n",
        "memory_median": 14844.0,
        "time_median": 740.0,
        "length_median": 2293.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "477": {
        "problem_text": "N명의 사람들이 어떤 공연장에 입장하기 위해서 한 줄로 서 있다. 줄 서 있는 각 사람은 자기 앞에 서 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 알고 있다. 그러면, 이 수들을 표시하는 수열을 S라고 한다.\nN명의 키 집합과 수열 S가 주어질 때, 원래 줄 서 있는 키 순서를 정확히 찾아내는 프로그램을 작성하시오. \n예를 들어서, 사람들의 키 집합이 다음과 같이 주어진다 (여기서, 같은 키의 사람들이 여러 명 존재할 수 있어서 중복이 포함된다). \n{120, 167, 163, 172, 145, 134, 182, 155, 167, 120, 119, 156}\n또한 각 사람이 자기 앞에 있는 사람들 중에서 자기보다 키가 작거나 같은 사람들의 수를 표시하는 수열 S는 다음과 같이 주어진다. \nS : 0 1 0 0 3 2 6 7 4 6 9 4\n그러면, 실제 줄 서 있는 사람들의 키 순서는 다음과 같다. \n134 167 120 119 156 120 167 182 155 163  172 145\n",
        "input_text": "첫째 줄에는 전체 사람의 수 N (1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에 사람들의 키를 나타내는 양의 정수가 하나씩 주어진다. 여기서 모든 키들은 2×109이하이다. 그리고 마지막 줄에 수열 S가 한 줄로 주어진다. 단 그 수열의 수는 하나의 공백을 두고 나타난다. \n",
        "output_text": "출력은 N개의 줄로 구성된다. N개의 줄 각각에 원래 줄 서 있는 사람들의 키를 순서대로 하나씩 출력한다. \n",
        "memory_median": 4720.0,
        "time_median": 84.0,
        "length_median": 1216.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "478": {
        "problem_text": "각각 N(1 ≤ N ≤ 2,000)개의 쌍으로 이루어진 2N개의 정점과 M(1 ≤ M ≤ N×(N-1)/2)개의 간선으로 구성된 이분그래프가 주어질 때 서로 교차하는 총 개수를 구하는 것이다.\n\n교차 조건 : 한 독립 집합 A와 다른 독립 집합 B가 연결된 두 개의 간선을 (A1, B1), (A2, B2)라 한다면 A1 < A2, B1 > B2 또는 A1 > A2, B1 < B2를 만족한다면 두 간선을 교차한다고 한다.\n\n\n예를 들어 위에 예에서 (3, 2)는 (1, 5)와 (5, 1)과 교차한다. 이 문제를 해결하는 프로그램을 작성하시오.\n",
        "input_text": "첫 줄에 N과 간선의 개수 M이 주어진다. 그 다음 줄부터 M+1번째 줄까지 두 개의 수(i, j)가 주어지는데 이는 왼쪽 그룹의 i번 정점과 오른쪽 그룹의 j번 정점을 연결하는 간선이 있다는 의미이다. 중복되는 간선이 입력으로 주어지지 않는다.\n",
        "output_text": "입력에서 주어진 간선이 교차하는 총 개수를 출력한다.\n",
        "memory_median": 26644.0,
        "time_median": 712.0,
        "length_median": 1095.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "479": {
        "problem_text": "축에 평행한 직사각형 N개가 평면 위에 있다. 이 직사각형들이 차지하는 전체 면적을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 양의 정수 N이 주어진다. (1 ≤ N ≤ 200,000) 다음 N개 줄에는 공백으로 나누어진 네 값 \"x1, x2, y1, y2\"가 주어진다. 이 값은 직사각형 [x1,x2] × [y1,y2]를 나타낸다. 모든 좌표는 0보다 크거나 같고, 109보다 작거나 같으며, 각각의 직사각형은 x1 < x2, y1 < y2를 만족한다.\n",
        "output_text": "첫째 줄에 주어진 직사각형 N개가 차지하는 전체 면적을 출력한다. 한 구역이 여러 개의 직사각형으로 덮어져 있는 경우에도 한 번으로 센다.\n",
        "memory_median": 43124.0,
        "time_median": 652.0,
        "length_median": 2042.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "480": {
        "problem_text": "재성이는 현실 세계에서 짱 쎈 친구이다! 너무 쎄서 학교의 학생 모두가 그를 보면 오금이 지릴 정도였는데, 그가 쎄지게 된 계기는 다음과 같다.\n원래 재성이는 마법에 천부적인 재능이 있어서 순간적으로 공기의 압력을 증가시키는 에어 프레셔와 바쿰프레스라는 공격기술을, 그리고 이전으로 돌아갈 수 있는 타임머신 기술을 사용할 수 있는 마력을 가지고 있었다. 하지만 그걸 모르고 재혁이한테 뚜까맞던 재성이는 어느 순간 너무 화나서 각성을 했다.\n각성 후에, 이때까지 쌓인 한을 풀기 위해 재성이는 재혁이를 i일엔 ai의 충격을 주면서 때렸다. 언제는 한번 변덕이 돋아서 j일부터 m일까지로 돌아가서 각각 l의 충격을 더해서 때리곤 했는데, 타임머신 기술을 활용하는 건 매우 힘든 일이므로 충격이 음수가 되면서 자기가 도리어 역으로 퍼맞을 수도 있다.\n재혁이는 계속 뚜까맞다보니 자신이 n일부터 m일까지 얼마나 퍼맞았는지 궁금했다.\n처절한 재혁이를 위해 재성이가 n일부터 m일까지 얼마나 때렸는지를 알려주자.\n",
        "input_text": "재성이가 재혁이를 때린 날수 N과 재성이가 변덕을 부린 날의 개수 Q1, 재혁이가 얼마나 맞았는지 궁금한 구간의 개수 Q2가 주어진다. (1 ≤ N ≤ 1,000,000, 0 ≤ Q1, Q2 ≤ 10,000)\n그 다음줄엔 재혁이가 i번째 날에 맞았던 충격 ai가 주어진다.(1 ≤ ai ≤ 1,500,000)\n그 다음 Q1+Q2 줄에는 다음과 같은 쿼리가 주어진다.\n\n1 n m : 재혁이가 n일부터 m일까지 맞은 양을 출력한다. 이 1번 쿼리는 Q2개 주어진다.(1 ≤ n, m ≤ N)\n2 s e l : 재성이가 s일에서 e일까지로 돌아가서 l의 충격을 더해서 때릴 수 있다. 이 2번 쿼리는 Q1개 주어진다.(-1,000 ≤ l ≤ 1,000, 1 ≤ s, e ≤ N)\n\n",
        "output_text": "1번 쿼리에 대한 답을 Q2줄에 걸쳐 차례대로 출력한다.\n",
        "memory_median": 63616.0,
        "time_median": 188.0,
        "length_median": 1825.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "481": {
        "problem_text": "N개의 자연수로 이루어진 수열이 있다. 이 수열의 연속한 일부분에 일정한 값을 더하는 연산과 연속한 일부분의 최대공약수를 구하는 연산을 수행하자.\n",
        "input_text": "첫째 줄에 수열의 원소의 개수를 나타내는 하나의 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)\n둘째 줄에 수열의 각 원소를 나타내는 N개의 자연수가 주어진다. i번째로 등장한 자연수는 수열의 i번째 원소이며 1 이상 10억 이하의 값을 가진다.\n셋째 줄에 연산의 총 횟수를 나타내는 하나의 자연수 Q가 주어진다. (1 ≤ Q ≤ 100,000)\n넷째 줄부터 Q개의 줄에 걸쳐 각 연산에 대한 정보가 주어진다. 각 줄에는 T, A, B 3개의 정수가 주어진다.\n\nT가 0이 아니라면, 수열의 A번째 원소부터 B번째 원소까지에 T라는 수를 더하는 연산이다.\nT가 0이라면, 수열의 A번째 원소부터 B번째 원소까지의 최대공약수를 출력해야 한다.\nT는 0 이상 10억 이하의 값을 가진다. A와 B는 1 이상 N 이하이며, B는 A보다 크거나 같다.\n\nT가 0인 연산은 하나 이상 주어진다.\n",
        "output_text": "T가 0인 연산이 주어질 때마다 순서대로 각 줄에 해당 연산에서 요구하는 답을 출력한다.\n",
        "memory_median": 9828.0,
        "time_median": 112.0,
        "length_median": 2339.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "482": {
        "problem_text": "크기가 N(1 ≤ N ≤ 100,000)인 1차원 배열 A[1], …, A[N]이 있다. 어떤 i, j(1 ≤ i ≤ j ≤ N)에 대한 점수는, (A[i] + … + A[j]) × min{A[i], …, A[j]}가 된다. 즉, i부터 j까지의 합에 i부터 j까지의 최솟값을 곱한 것이 점수가 된다.\n배열이 주어졌을 때, 최대의 점수를 갖는 부분배열을 골라내는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정수 N이 주어진다. 다음 줄에는 A[1], …, A[N]을 나타내는 정수들이 주어진다. 각각의 정수들은 음이 아닌 값을 가지며, 1,000,000을 넘지 않는다.\n",
        "output_text": "첫째 줄에 최대 점수를 출력하고, 둘째 줄에 그 구간의 시작 위치(i)와 끝 위치(j)를 출력한다.\n",
        "memory_median": 5586.0,
        "time_median": 28.0,
        "length_median": 1357.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "483": {
        "problem_text": "For the daily milking, Farmer John's N cows (1 <= N <= 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun, they should not differ too much in height.\nFarmer John has made a list of Q (1 <= Q <= 180,000) potential groups of cows and their heights (1 <= height <= 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.\nNote: on the largest test case, I/O takes up the majority of the runtime.\n",
        "input_text": "\nLine 1: Two space-separated integers, N and Q.\nLines 2..N+1: Line i+1 contains a single integer that is the height of cow i\nLines N+2..N+Q+1: Two integers A and B (1 <= A <= B <= N), representing the range of cows from A to B inclusive.\n\n \n",
        "output_text": "\nLines 1..Q: Each line contains a single integer that is an answer to an input query and tells the difference in height between the tallest and shortest cow in the input range.\n\n",
        "memory_median": 3780.0,
        "time_median": 140.0,
        "length_median": 1528.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "484": {
        "problem_text": "정렬 알고리즘의 상한(upper bound)은 n2이다. 이 사실은 쉽게 증명할 수 있다. 올바른 순서가 아닌 임의의 두 원소(ai > aj, i < j)를 선택하고, 그 위치를 서로 바꿔준다. 이렇게 올바른 순서가 아닌 것을 도치(inversion)라고 하며, 도치의 개수는 최대 n(n-1)/2개이다. \n현주는 사회에 대한 불만이 많은 아이이다. 그는 항상 정렬을 할 때, 두 원소를 선택하는 것에도 큰 불만을 가지고 있다. 현주는 ai > aj > ak와 i < j < k를 만족하는 세 원소를 선택한 뒤, ak, aj, ai로 순서를 바꾸려고 한다.\n현주는 자신이 만든 정렬 알고리즘을 불만 정렬 알고리즘이라고 이름을 붙였다. 이제 이 알고리즘의 상한을 구하려고 한다. 현주가 선택할 수 있는 세 원소의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 수열의 길이가 주어진다. (1 ≤ n ≤ 105)\n다음 줄에는 수열의 원소가 공백으로 구분되어 주어진다. 각 원소는 1보다 크거나 같고, n보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 도치된 세 원소 (ai > aj > ak와 i < j < k를 만족하는 세 원소)의 개수를 출력한다.\n",
        "memory_median": 4610.0,
        "time_median": 40.0,
        "length_median": 1138.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "485": {
        "problem_text": "최근 '백준 우주 연합(BIU)'은 어떤 은하계 근처에서 새로운 행성 하나를 발견했다. 그 행성은 유성우가 많이 내려 사람이 살기엔 적절치 못한 곳이었으나, 유성우에 관한 연구 대상으로는 아주 좋은 곳으로 밝혀졌다.\nBIU 회원국은 이미 그 행성 가까이에 우주정거장을 세웠다. 이 우주 정거장의 목적은 유성우의 운석 샘플을 채취하는 것이다. BIU 연합 최고 지도 사령관인 백준은 행성 궤도를 M개의 구역으로 나누고 1부터 M까지 순서대로 번호를 부여했다. (행성 궤도는 원 궤도이므로 1번 구역과 M번 구역은 서로 인접해 있다.) 각 구역은 N개의 BIU회원국들이 서로 적당히 나누어 가졌다.\n각 BIU 회원국들은 모으고자 하는 운석 샘플의 목표치를 정했다. 당신의 임무는 유성우 예보를 바탕으로 각 나라들이 언제 샘플 채취를 완료할 수 있는지 말해주는 것이다.\n",
        "input_text": "첫째 줄에 두 정수 N, M (1 ≤ N, M ≤ 300,000)이 주어진다. N은 BIU연합의 회원국 개수고, M은 행성 궤도의 구역 개수이다.\n둘째 줄에는 M개의 정수 oi (1 ≤ oi ≤ N)가 주어진다. oi는 i번째 구역을 소유하고 있는 BIU연합의 회원국 번호를 나타낸다.\n세 번째 줄에는 N개의 정수 pj (1 ≤ pj ≤ 109)가 주어진다. pj는 j번째 BIU회원국이 목표치로 정한 운석 샘플 수량을 나타낸다.\n네 번째 줄에는 정수 Q (1 ≤ Q ≤ 300,000)가 주어진다. Q는 유성우 예보의 수를 나타낸다.\n다음 Q개의 줄에는 예측된 유성우의 개수가 날짜 순서로 표시된다. 각 u번째 줄은 세 가지 정수 lu, ru, au로 구성되는데, lu ≤ ru인 경우 구역 lu,lu+1,…,ru에 au개의 운석이 내리고, lu>ru인 경우 구역 lu,lu+1,…,m,1,…,ru에 각 구역당 au개의 운석이 내린다는 뜻이다. (정수 au의 범위는 1 ≤ au ≤ 109 이고, 여기서 u는 유성우 예보 시작 후 u번째 날을 의미한다.)\n",
        "output_text": "회원국별로 샘플조사를 끝마칠 수 있는 최소 일 수 wj를 회원국 번호 순서대로 한 줄에 하나씩 출력한다. 끝마치는 날에는 최소한 pj개의 운석 샘플을 가지고 있어야 하며, 유성우 예보 기간 안에 운석 샘플을 다 채우지 못 할 경우 NIE(폴란드어로 NO를 의미)를 출력한다.\n",
        "memory_median": 59508.0,
        "time_median": 1914.0,
        "length_median": 2136.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "486": {
        "problem_text": "For the daily milking, Farmer John's N cows (1 <= N <= 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.\nFarmer John has made a list of Q (1 <= Q <= 200,000) potential groups of cows and their heights (1 <= height <= 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.\n",
        "input_text": "\nLine 1: Two space-separated integers, N and Q.\nLines 2..N+1: Line i+1 contains a single integer that is the height of cow i\nLines N+2..N+Q+1: Two integers A and B (1 <= A <= B <= N), representing the range of cows from A to B inclusive.\n\n \n",
        "output_text": "\nLines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.\n\n",
        "memory_median": 3780.0,
        "time_median": 52.0,
        "length_median": 1550.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "487": {
        "problem_text": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. \n\n1 L R X: 모든 L ≤ i ≤ R에 대해서 Ai = min(Ai, X) 를 적용한다. \n2 L R: max(AL, AL+1, ..., AR)을 출력한다.\n3 L R: AL + AL+1 + ... + AR을 출력한다.\n\n",
        "input_text": "첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 1,000,000)\n둘째 줄에는 A1, A2, ..., AN이 주어진다. (0 ≤ Ai < 231)\n셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 1,000,000)\n넷째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ L ≤ R ≤ N, 0 ≤ X < 231) 2번과 3번 쿼리는 한 번 이상 주어진다.\n",
        "output_text": "2, 3번 쿼리의 결과를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 119198.0,
        "time_median": 2280.0,
        "length_median": 2852.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "488": {
        "problem_text": "N개의 농장과 농장을 양방향으로 연결하는 N-1개의 도로가 있다. 임의의 두 농장 사이에는 하나의 경로만 존재한다. 농장은 1번부터 N번까지 번호가 매겨져 있다.\n농장을 관리하는 재현이는 도로에 나무를 심기로 결정했다. 나무를 심는 과정은 쿼리로 이루어져 있으며, 쿼리는 총 2가지가 존재한다.\n\nP u v: u번 농장과 v번 농장 사이의 경로에 존재하는 모든 도로에 나무를 하나씩 심는다.\nQ u v: u번 농장과 v번 농장 사이의 도로에 존재하는 나무의 개수를 출력한다.\n\n초기에 나무는 한 그루도 심겨져 있지 않다. 쿼리를 수행해보자.\n",
        "input_text": "첫째 줄에 농장의 수 N과 쿼리의 수 M(1 ≤ N, M ≤ 100,000)이 주어진다.\n둘째 줄부터 N-1개의 줄에는 도로가 연결하는 농장의 번호가 주어진다.\n다음 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. 쿼리는 한 개의 문자 w와 두 개의 정수 u, v로 이루어져 있고, 문제에서 설명한 형식이다.\n",
        "output_text": "쿼리 Q가 주어질 때 마다, 나무의 개수를 출력한다.\n",
        "memory_median": 24008.0,
        "time_median": 144.0,
        "length_median": 3222.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "489": {
        "problem_text": "싱글 CPU에서 여러개의 작업을 실행할 때, 스케줄러는 어떤 작업을 언제 실행해야할지 CPU에게 알려준다.\n이번 문제에서 살펴볼 스케줄러는 라운드 로빈 스케줄러이다. 총 작업은 N개가 있으며, 0번부터 N-1번까지 번호가 매겨져 있다. 스케줄러는 각 작업을 0번 작업부터 순서대로 한 번에 1초씩 실행시킨다. 모든 작업을 순서대로 실행시킨 후에는 다시 0번 작업부터 실행을 시작한다. 이때, 완료된 작업이 있으면, 그 작업은 앞으로 실행시키지 않는다.\n각 작업을 수행해야하는 시간이 주어졌을 때, 각 작업이 언제 완료되는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 작업의 개수 N (1 ≤ N ≤ 100,000)이 주어진다. 둘째에는 각 작업을 수행해야하는 시간이 공백으로 구분되어 주어진다. 각 작업을 수행해야하는 시간은 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄부터 N개의 줄에 각 작업을 완료하는데 필요한 시간을 0번 작업부터 출력한다.\n",
        "memory_median": 5868.0,
        "time_median": 76.0,
        "length_median": 1409.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "490": {
        "problem_text": "비어있는 배열 A가 주어졌을 때, 다음과 같은 5가지 쿼리를 수행하는 프로그램을 작성하시오. 배열의 인덱스는 1부터 시작한다.\n\n1 x: 배열 A의 끝에 x를 추가한다.\n2 L R x: A의 L번째 수부터 R번째 수까지 중에서 x와 xor한 값이 가장 큰 y를 찾아 출력한다.\n3 k: 배열 A의 마지막 k개를 제거한다.\n4 L R x: A의 L번째 수부터 R번째 수까지 중에서 x보다 작거나 같은 원소의 개수를 출력한다.\n5 L R k: A의 L번째 수부터 R번째 수까지 중에서 k번째로 작은 수를 출력한다.\n\n",
        "input_text": "첫째 줄에 쿼리의 개수 M (1 ≤ M ≤ 500,000)이 주어진다.\n둘째 줄부터 M개의 줄에는 쿼리가 한 줄에 하나씩 주어진다. (1 ≤ x ≤ 500,000, 1 ≤ L ≤ R ≤ N)\n3번 쿼리의 경우 1 ≤ k ≤ N, 5번 쿼리의 경우: k ≤ R-L+1\nN은 쿼리를 실행하기 전 배열 A의 크기이다.\n",
        "output_text": "2,4,5번 쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.\n",
        "memory_median": 164068.0,
        "time_median": 884.0,
        "length_median": 2781.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "491": {
        "problem_text": "길이 N의 정수 수열 K1, K2, ..., KN과 상수 U, V가 주어진다.\nQ개의 쿼리가 주어지며, 그 종류는 두 가지가 있다.\n\nA, B가 주어지면, max(U × (Ki + Ki + 1 + ... + Kj) + V × (j - i)) (A ≤ i ≤ j ≤ B) 의 값을 구한다.\nA, B가 주어지면, KA의 값을 B으로 바꾼다.\n\n",
        "input_text": "첫 번째 줄에 정수 N과 Q, U, V가 입력된다. (1 ≤ N, Q ≤ 105,  - 5 ≤ U, V ≤ 5)\n두 번째 줄에 정수 K1, K2, ..., KN이 주어진다. (-102 ≤ Ki ≤ 102)\n세 번째 줄부터 쿼리가 주어진다. 세 정수 C, A, B가 주어진다. (0 ≤ C ≤ 1, A, B, C는 정수)\nC가 0이면 첫 번째 쿼리를, 아니면 두 번째 쿼리를 수행한다. 첫 번째 쿼리일 경우 1 ≤ A ≤ B ≤ N 이다. 두 번째 쿼리일 경우 1 ≤ A ≤ N, -102 ≤ B ≤ 102이다.\n",
        "output_text": "한 줄마다 첫 번째 쿼리의 결과값을 출력한다.\n",
        "memory_median": 10592.0,
        "time_median": 104.0,
        "length_median": 1911.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "492": {
        "problem_text": "어려서부터 땅따먹기를 곧잘 즐기던 구사과는, 땅따먹기로 입신의 경지에 다다르게 되었다. 그래서 구사과는 자신만이 할 수 있는 새로운 땅따먹기 게임을 만들었는데, 이름하여 반평면 땅따먹기이다.\n반평면 땅따먹기의 규칙은 땅따먹기보다 좀 더 간단하다. 땅따먹기 특이점을 넘긴 능력을 보유한 구사과는 땅따먹기에서만큼은 뭐든지 할 수 있다. 이를테면 무한히 먼 곳으로부터 손가락으로 돌을 쳐 무한히 멀리 직선으로 날아가도록 할 수 있다. 반평면 땅따먹기는 이 능력을 이용한 게임으로, 구사과가 점령하는 돌을 쳐서 날릴 때마다 그 자취인 직선을 기준으로 나뉘는 두 영역 중 (0, -∞)를 포함하는 쪽 전부를 점령하게 된다.\n무한한 2차원 평면 위에서 게임을 하던 구사과는 문득 현재 자신이 점령한 땅의 모양에 관해서 궁금해졌다. 하지만 땅따먹기 이외에는 젬병인 구사과는 정작 자신이 점령한 땅에 대해서는 잘 알지 못했다. 높은 곳을 좋아하는 구사과는 종종 자신이 점령한 땅 중 해당 x좌표에서 가장 높은 y좌표가 몇인지 알고 싶었다.\n우수한 프로그래머인 당신만이 구사과의 유일한 희망이다. 구사과가 게임을 진행한 정보가 주어질 때 이를 토대로 구사과의 궁금증을 해결해주자!\n",
        "input_text": "첫 줄에는 게임을 진행한 정보의 개수 Q(1 ≤ Q ≤ 200,000)이 주어지며, 이어서 Q 줄에 걸쳐 각 정보가 주어진다. 각 줄의 첫 번째 숫자가 1일 경우 이어서 2개의 정수 a, b(|a| ≤ 1,000,000, |b| ≤ 1,000,000,000,000)가 주어지며 이는 구사과가 y = ax + b 형태의 직선을 따라 돌을 날렸음을 의미한다. 각 줄의 첫 번째 숫자가 2일 경우 이어서 1개의 정수 x(|x| ≤ 1,000,000,000,000)이 주어지며, 이는 구사과가 현재까지 점령한 땅 중 해당 x 좌표에서 가장 높은 y값을 궁금해함을 의미한다. 첫 번째 정보는 무조건 1로 시작함이 보장된다.\n",
        "output_text": "모든 구사과의 궁금증에 대하여 해당하는 y값을 한 줄에 걸쳐 하나씩 출력한다.\n",
        "memory_median": 9796.0,
        "time_median": 152.0,
        "length_median": 1827.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "493": {
        "problem_text": "크기가 N인 수열 A와 정수 K가 주어졌을 때, A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 구해보자.\n",
        "input_text": "첫째 줄에 N, K가 주어진다. 둘째 줄에 수열 A1, A2, ..., AN이 주어진다.\n",
        "output_text": "첫째 줄에 A의 증가하는 부분 수열 중에서 길이가 K인 것의 개수를 109+7로 나눈 나머지를 출력한다.\n",
        "memory_median": 12268.0,
        "time_median": 152.0,
        "length_median": 1073.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "494": {
        "problem_text": "총 N개의 정수로 이루어진 배열 A가 주어진다. 이때, 다음 쿼리를 총 Q번 반복 수행하는 프로그램을 작성하시오. 배열은 1번부터 시작한다.\n\nl r: l번째 수부터 r번째 수 중에서 서로 다른 수의 개수를 세고 출력한다.\n\n",
        "input_text": "첫째 줄에 배열의 크기 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에는 배열에 포함된 수가 1번째 수부터 주어진다. 수는 공백으로 구분되어져 있다. 배열에 포함된 수는 1,000,000,000보다 작거나 같은 자연수이다.\n셋째 줄에는 쿼리의 개수 Q(1 ≤ Q ≤ 1,000,000)가 주어진다. 넷째 줄부터 Q개의 줄에는 쿼리를 나타내는 두 정수 xi, ri가 주어진다. 이때, li = xi + Qi-1로 구한다. (1 ≤ li ≤ ri ≤ N, -(N-1) ≤ xi ≤ (N-1)) Qi는 i번 쿼리의 정답이고, 첫 쿼리의 번호는 1번이다. 마지막으로, Q0 = 0이다.\n",
        "output_text": "첫째 줄부터 Q개의 줄에 쿼리의 답을 한 줄에 하나씩 출력한다.\n",
        "memory_median": 547360.0,
        "time_median": 2774.0,
        "length_median": 2037.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "495": {
        "problem_text": "야구선수인 메시는 국제 메시 기구(IMO, International messi organization)의 금고 관리자이다. 트리를 사랑하는 메시는 금고를 금고 1이 루트인 트리 모양으로 연결해서 관리한다고 한다.\n업무시간에 A+B를 풀고 있던 메시는 메일 하나를 받았는데, 그 메일에는 '메시 흑역사.jpg.exe'라는 이름의 첨부파일이 하나 있었다. 안 그래도 어제 도난 사건으로 금고 N개가 다 털려 0원밖에 남지 않아 해고당할 위기에 처했는데 흑역사까지 드러날 위기에 처한 메시는 한 치의 고민도 없이 첨부파일을 열었다. 그러자 이상한 콘솔 창이 등장했다!\n금★고의 요☆정 지♨니! 금고 속의 돈을 늘려드립니다! 명령어를 입력하세요. 명령어의 목록은 다음과 같습니다.\n\n\"1 X V\" 금고 X의 서브트리에 있는 모든 금고에 V원을 더합니다. (1 ≤ X ≤ N, 1 ≤ V ≤ 109)\n\"2 X Y V\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고에 V원을 더합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 1 ≤ V ≤ 109)\n\"3 X V\" 금고 X의 서브트리에 있는 모든 금고의 돈을 V배 합니다. (1 ≤ X ≤ N, 0 ≤ V ≤ 109)\n\"4 X Y V\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 V배 합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N, 0 ≤ V ≤ 109)\n\"5 X\" 금고 X의 서브트리에 있는 모든 금고의 돈을 합한 값을 출력합니다. (1 ≤ X ≤ N)\n\"6 X Y\" 금고 X부터 금고 Y까지의 경로에 있는 모든 금고의 돈을 합한 값을 출력합니다. 단, 경로는 경계를 포함합니다. (1 ≤ X, Y ≤ N)\n\n메시는 도난 사건을 없던 일로 만들 기회라고 생각하여 명령어를 입력했지만, 이 파일은 당연하게도 바이러스라서 메시가 3개월간 짜던 A+B의 코드를 다 날려버렸다. 화가 난 메시는 위의 명령어를 실행하는 프로그램을 직접 만들기로 했다.\n",
        "input_text": "첫째 줄에 N, Q가 주어진다. (1 ≤ N ≤ 500,000, 1 ≤ Q ≤ 100,000)\n다음 N-1줄 중 i번째 줄에는 Si, Ei가 주어지며, 이는 금고 Si와 금고 Ei가 연결되어 있다는 뜻이다. (1 ≤ Si, Ei ≤ N)\n금고가 연결된 모양은 올바른 트리 모양이다.\n다음 Q줄에는 명령어들이 한 줄에 하나씩 주어진다.\n",
        "output_text": "출력 명령어가 주어질 때마다 값을 출력한다. 단, 메시의 컴퓨터는 최신 트렌드인 4294967296비트 컴퓨터와는 다르게 32비트 컴퓨터이므로 232로 나눈 나머지를 대신 출력한다.\n",
        "memory_median": 121824.0,
        "time_median": 1310.0,
        "length_median": 4325.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "496": {
        "problem_text": "Cow Land is a special amusement park for cows, where they roam around, eat delicious grass, and visit different cow attractions (the roller cowster is particularly popular).\nThere are a total of $N$ different attractions ($2 \\leq N \\leq 10^5$). Certain pairs of attractions are connected by pathways, $N-1$ in total, in such a way that there is a unique route consisting of various pathways between any two attractions. Each attraction $i$ has an integer enjoyment value $e_i$, which can change over the course of a day, since some attractions are more appealing in the morning and others later in the afternoon.\nA cow that travels from attraction $i$ to attraction $j$ gets to experience all the attractions on the route from $i$ to $j$. Curiously, the total enjoyment value of this entire route is given by the bitwise XOR of all the enjoyment values along the route, including those of attractions $i$ and $j$.\nPlease help the cows determine the enjoyment values of the routes they plan to use during their next trip to Cow Land.\n",
        "input_text": "The first line of input contains $N$ and a number of queries $Q$ ($1 \\leq Q \\leq 10^5$). The next line contains $e_1 \\ldots e_N$ ($0 \\leq e_i \\leq 10^9$). The next $N-1$ lines each describe a pathway in terms of two integer attraction IDs $a$ and $b$ (both in the range $1 \\ldots N$). Finally, the last $Q$ lines each describe either an update to one of the $e_i$ values or a query for the enjoyment of a route. A line of the form \"1 $i$ $v$\" indicates that $e_i$ should be updated to value $v$, and a line of the form \"2 $i$ $j$\" is a query for the enjoyment of the route connecting attractions $i$ and $j$.\nIn test data worth at most 50% of points, there will be no changes to the values of the attractions.\n",
        "output_text": "\t\t\t\t\tFor each query of the form \"2 $i$ $j$\", print on a single line the enjoyment of\r\nthe route from $i$ to $j$.\r\n\n\t\t\t\t\t",
        "memory_median": 20286.0,
        "time_median": 180.0,
        "length_median": 2668.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "497": {
        "problem_text": "You are given a sequence of n integers a1 , a2 , ... , an in non-decreasing order. In addition to that, you are given several queries consisting of indices i and j (1 ≤ i ≤ j ≤ n). For each query, determine the most frequent value among the integers ai , ... , aj.\n",
        "input_text": "The input consists of several test cases. Each test case starts with a line containing two integers n and q (1 ≤ n, q ≤ 100000). The next line contains n integers a1 , ... , an (-100000 ≤ ai ≤ 100000, for each i ∈ {1, ..., n}) separated by spaces. You can assume that for each i ∈ {1, ..., n-1}: ai ≤ ai+1. The following q lines contain one query each, consisting of two integers i and j (1 ≤ i ≤ j ≤ n), which indicate the boundary indices for the query.\nThe last test case is followed by a line containing a single 0.\n",
        "output_text": "For each query, print one line with one integer: The number of occurrences of the most frequent value within the given range.\n",
        "memory_median": 6406.0,
        "time_median": 400.0,
        "length_median": 1791.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "498": {
        "problem_text": "민호가 관리하는 천나라에는 N개의 집이 있다. 민호는 집을 쉽게 관리하기 위해 각각의 집을 1번, 2번, … N번으로 부르기로 했다.\n어느 날 미적 감각에 눈을 뜬 민호는 특정 구간의 집들의 색들을 새롭게 칠하거나, 특정 구간의 집들에 존재하는 색의 수를 알고 싶어졌다.\n작업은 다음과 같은 두가지로 이루어 진다.\n\n“C x y z” : x번과 y번, 그리고 그 사이에 있는 모든 집을 z번 색으로 색칠한다.\n“Q x y” : x번과 y번, 그리고 그 사이에 있는 모든 집에 존재하는 색의 가짓수를 출력한다.\n\n민호가 사용할 색의 종류는 (1번, 2번, … T번) 이라 하고 처음 모든 집은 1번으로 색칠되어 있다고 생각한다.\n민호가 해야하는 작업을 시뮬레이션 해보는 프로그램을 작성하자.\n",
        "input_text": "첫 번째 줄에 N, T, Q (1 ≤ N ≤ 100,000, 1 ≤ T ≤ 30, 1 ≤ Q ≤ 100,000)이 공백을 구분으로 주어진다. 각각 천나라에 존재하는 집의 개수, 사용할 색의 개수, 작업의 개수를 의미한다.\n두 번째 줄부터 작업이 주어진다. 작업은 “C x y z” 또는 “Q x y” 둘 중에 하나의 형식으로 주어진다.\n",
        "output_text": "작업이 “Q x y”일 때의 경우 x번과 y번, 그리고 그 사이에 있는 모든 집에 존재하는 색의 가짓수를 출력한다.\n",
        "memory_median": 5148.0,
        "time_median": 96.0,
        "length_median": 1806.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "499": {
        "problem_text": "길이가 N인 수열 A1, A2, ..., AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.\n\nx1 y1 x2 y2: x1 ≤ i ≤ y1, x2 ≤ j ≤ y2, i ≤ j인 모든 (i, j)에 대해서 Ai + ... + Aj의 최댓값을 출력한다. (1 ≤ x1 ≤ x2 ≤ N, 1 ≤ y1 ≤ y2 ≤ N, x1 ≤ y1, x2 ≤ y2)\n\n",
        "input_text": "첫째 줄에 수열의 크기 N (1 ≤ N ≤ 100,000)가 주어진다.\n둘째 줄에는 A1, A2, ..., AN이 주어진다. (-100,000 ≤ Ai ≤ 100,000)\n셋째 줄에는 쿼리의 개수 M (1 ≤ M ≤ 100,000)이 주어진다.\n넷째 줄부터 M개의 줄에는 쿼리 x1, y1, x2, y2가 한 줄에 하나씩 주어진다.\n",
        "output_text": "각각의 쿼리마다 정답을 한 줄에 하나씩 출력한다.\n",
        "memory_median": 15300.0,
        "time_median": 232.0,
        "length_median": 2359.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "500": {
        "problem_text": "It is well known that building a hotel near sea coast is very profitable. That is why the company International Ocean Investment bought a piece of earth on the Black See coast (similar to shown on the Figure) and would like to build a hotel – as big as possible. By different reasons the hotel has to be with rectangular basement. That is why the company searches somebody to find the rectangle with maximal surface which could be drawn on the piece of earth. For the purpose the terrain was split in N columns of equal squares (white on the Figure). Columns are labeled with 1, 2, …, N consecutively, from left to right, and the rectangle should be composed of integer number of such squares. Then for each column the number of whole squares in the column was counted. Write a program maxarrea to find the surface of the maximal rectangle on the terrain that could be composed of squares. \n",
        "input_text": "The first line of the standard input contains the positive integer N (N ≤ 1 000 000). On the next row N integers are given D1, D2, …, DN – DI is the number of squares in the column I, 0 < DI ≤ 15 000.\n",
        "output_text": "The program has to print on the standard output the found maximal surface. \n",
        "memory_median": 9836.0,
        "time_median": 160.0,
        "length_median": 902.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "501": {
        "problem_text": "지안지아는 똑같은 크기의 벽돌을 쌓아서 벽을 만들고 있다. 이 벽은 n열의 벽돌로 되어 있는데, 각 열은 왼쪽부터 오른쪽으로 차례대로 0부터 n-1까지 번호가 매겨져 있다. 각 열의 높이는 서로 다를 수 있다. 열의 높이는 이 열에 쌓인 벽돌의 수이다.\n지안지아는 다음과 같이 벽을 만든다. 처음에는 어느 열에도 벽돌이 없다. 다음, 지안지아는 k 단계에 걸쳐 벽돌을 더하거나 또는 빼거나 한다. k 단계가 다 끝나면 벽을 다 쌓은 것이다. 매 단계마다 지안지아는 연속된 벽돌 열의 범위와 높이 h를 받고, 다음과 같은 절차에 따라 정해진 일을 한다.\n\n벽돌을 더하는 단계에서는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 미만의 벽돌이 쌓인 열들에 벽돌을 더해서 정확히 벽돌 h장이 쌓이게 한다. h장 이상 벽돌이 있는 열에는 아무 일도 하지 않는다.\n벽돌을 빼는 단계에는, 지안지아는 주어진 범위에 해당하는 열들 중 h장 초과의 벽돌이 쌓인 열들에서 벽돌을 빼서 정확히 벽돌 h장이 쌓이게 한다. h장 이하 벽돌이 있는 열에는 아무 일도 하지 않는다.\n\n당신이 할 일은 벽의 최종 모양을 결정하는 것이다.\n10열의 벽돌이 있고 6단계를 거쳐 벽을 만든다고 가정하자. 아래 표의 모든 범위는 양 끝을 포함한다. 각 단계가 끝났을 때 벽의 모양은 아래 그림과 같다.\n\n\n\n단계\n하는 일\n범위\n높이\n\n\n\n\n0\n더하기\n1열부터 8열까지\n4\n\n\n1\n빼기\n4열부터 9열까지\n1\n\n\n2\n빼기\n3열부터 6열까지\n5\n\n\n3\n더하기\n0열부터 5열까지\n3\n\n\n4\n더하기\n2열\n5\n\n\n5\n빼기\n6열부터 7열까지\n0\n\n\n\n처음에 모든 열에는 벽돌이 없기 때문에, 단계 0이 끝나면 1열부터 8열까지는 모두 4장의 벽돌이 있다. 0열과 9열은 비어 있다. 단계 1에서는, 4열부터 8열까지는 벽돌이 빠져서 모든 열에 각각 벽돌이 1장이 있고, 9열은 계속 비어 있다. 주어진 범위 밖인 0열부터 3열은 아무 변화가 없다. 단계 2는 아무 변화가 없는데, 3열부터 6열까지 5장을 초과하여 벽돌이 있는 열이 없기 때문이다. 단계 3이 끝나면 0, 4, 5열의 벽돌은 3장으로 늘어난다. 단계 4가 끝나면 2열에는 벽돌이 5장 있다. 단계 5는 6열과 7열의 모든 벽돌을 없앤다.\n\n각 단계에서 하는 일이 주어졌을 때, 모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 계산하시오.\n",
        "input_text": "첫째 줄에 벽에 있는 열의 수 n과 단계의 수 k가 주어진다.\n둘째 줄부터 총 k개의 줄에 걸쳐서 단계 i에서 하는 일이 주어진다. op, left, right, height로 이루어져 있으며, 아래와 같은 의미를 갖는다.\n\nop: 1이면 더하는 단계, 2이면 빼는 단계이다.\nleft와 right: 각 단계에 해당하는 열의 범위이다. left 열에서 시작하고, right 열에서 끝난다. (양 끝점 left와 right도 포함된다) 항상 left ≤ right이다.\nheight: 각 단계에서 주어지는 높이이다.\n\n",
        "output_text": "모든 단계가 끝난 다음 각 열에 남아 있는 벽돌의 수를 한 줄에 하나씩 순서대로 출력한다.\n",
        "memory_median": 67560.0,
        "time_median": 1024.0,
        "length_median": 1877.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "502": {
        "problem_text": "HEPC 1등 상금으로 도토리 D개를 받은 욕심많은 다람쥐 수형이는 자신의 모든 도토리를 뺏기지 않게 보관하려고 한다. 수형이는 1부터 N까지의 번호가 붙여있는 N개의 상자를 가지고 있고 이 안에 도토리를 넣어 다른 다람쥐들이 찾지 못하게 전부 숨기려고 한다. 상자가 너무 많아 도토리가 있는 상자를 모두 외울 수 없는 수형이는 A번 상자부터 B번 상자까지 C개 간격으로 도토리를 하나씩 더 넣는 규칙을 만들었다! 다른 다람쥐들이 규칙을 눈치채고 모든 도토리를 잃는 것이 무서운 나머지 이러한 규칙들을 K개를 만들어 도토리를 최대한 안전하게 저장해 놓으려고 한다. 예를 들어 100번 상자부터 150번상자까지 10개 간격으로, 110번 상자부터 150번 상자까지 15개 간격으로 넣는다면 100, 110, 120, 125, 130, 140, 150번 상자에 도토리가 있으며 110번 상자와 140번 상자에는 2개의 도토리가 들어가 있게 된다. 상자 하나에 들어갈 수 있는 도토리의 개수는 제한이 없으며 앞의 상자부터 최대한 꽉꽉 채워나간다고 했을 때 마지막 도토리가 들어가 있는 상자의 번호를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 상자의 개수 N(1 ≤ N ≤ 1,000,000)과 규칙의 개수 K(1 ≤ K ≤ 10,000), 도토리의 개수 D(1 ≤ D ≤ 1,000,000,000)가 주어진다. 그 후 K개 줄에는 A, B, C(1 ≤ C ≤ A ≤ B ≤ N)가 주어지며 A번 상자부터 B번 상자까지 C개 간격으로 도토리를 하나씩 넣는 규칙을 뜻한다. D는 모든 규칙으로 넣을 수 있는 도토리의 수보다 같거나 작다.\n",
        "output_text": "D개의 도토리를 규칙에 맞게 상자 앞에서부터 넣었을 때 마지막 도토리가 들어가는 상자의 번호를 출력하시오.\n",
        "memory_median": 2220.0,
        "time_median": 4.0,
        "length_median": 809.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "503": {
        "problem_text": "넓은 시험 범위와 어려운 과제로 유명한 '운영체제로 보는 데이터베이스시스템 알고리즘' 수업은 시험지가 너무 많아 실내에서는 시험을 치를 수 없어서 야외에서 시험을 진행한다. 해당 수업의 수강생인 현수는 오랜 시간에 걸쳐 풀 수 있는 모든 문제를 풀었고 제출만을 남겨두고 있었다. 그러나 갑자기 불어오는 강풍에 현수의 시험지가 모두 날아가 버렸고, 날아간 시험지를 줍는 동안 남은 시간을 다 써버리고 말았다.\n시험지에 명시된 규칙 중에는 채점하는 조교의 편의를 위해 시험지를 반드시 순서대로 제출하라는 규칙이 있는데, 이 규칙 때문에 현수는 힘들게 치른 시험이 0점 처리될 위기에 빠지게 되었다!\n그러나, 마음씨 좋은 조교인 주찬이는 평소 수업에 열심히 참여한 현수에게 한 번의 기회를 주기로 했다. 규칙은 규칙이므로 많은 점수를 줄 수는 없고, 시험지를 현재 순서 그대로 K개의 그룹으로 나눈 뒤 각각의 그룹에서 맞은 문제 개수의 합을 구하여 그 중 최솟값을 시험 점수로 하기로 하였다. 현수가 이번 시험에서 받을 수 있는 최대 점수를 계산하는 프로그램을 작성하자.\n현수는 모르는 문제를 아예 풀지 않기 때문에 현수가 푼 문제는 모두 맞았다고 생각할 수 있으며, 조교는 마음씨가 좋아서 자신이 줄 수 있는 최대한의 점수를 준다.\n",
        "input_text": "첫 번째 줄에 시험지의 개수 N과 시험지를 나눌 그룹의 수 K가 정수로 주어진다. (1 ≤ K ≤ N ≤ 105)\n두 번째 줄에 각 시험지마다 맞은 문제의 개수 x가 정수로 주어진다 (0 ≤ x ≤ 20)\n",
        "output_text": "현수가 받을 수 있는 최대 점수를 출력한다.\n",
        "memory_median": 2412.0,
        "time_median": 8.0,
        "length_median": 729.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "504": {
        "problem_text": "수찬이는 선생님을 도와서 교실 벽면을 장식할 모자이크 그림을 그리기로 하였다. 이를 위하여 직사각형 모양의 큰 도화지를 준비하여 교실 벽에 붙이고 1cm 간격으로 가로선과 세로선을 그려서 정사각형 모양의 칸을 만들고, 각 칸마다 같은 색의 물감으로 색칠을 하였다. 그런데 잘못 칠해진 칸이 있음을 발견하게 되었다.\n수찬이는 도화지와 색깔이 같은 색종이를 사서 잘못 칠해진 칸에 색종이를 붙이고 다시 그리는 것이 좋겠다고 생각하고 선생님께 상의를 드렸다. 선생님께서는 정해진 장수의 색종이를 사용하여 아래와 같은 조건을 따르면서 잘못 칠해진 칸을 모두 가리되, 가장 작은 색종이의 크기를 구하는 새로운 문제를 내셨다.\n\n사용되는 색종이는 모두 크기가 같고 정사각형 모양이다.\n색종이 크기는 한 변의 길이로 나타내며, 원하는 크기의 색종이는 모두 구할 수 있다.\n모든 색종이는 반드시 도화지의 밑변에 맞추어 붙인다. 이때 색종이를 겹쳐서 붙일 수 있다.\n\n도화지 위의 행은 다음 그림과 같이 맨 아래에서 위쪽으로 1번부터 순서대로 번호가 매겨져 있고, 열은 왼쪽에서 오른쪽으로 1번부터 번호가 매겨져 있다. 이 그림은 도화지에 가로선과 세로선을 그어서 4개의 행과 14개의 열, 그리고 56개의 칸으로 나눈 모양을 보여준다. 잘못 칠해진 칸은 회색으로 표시되어 있다.  \n\n도화지 위의 칸은 행 번호와 열 번호로 나타낸다. 예를 들어 위 그림에서 가장 왼쪽에 있는 잘못 칠해진 칸 A의 위치는 (2, 1)이다. 위 그림과 같이 도화지에서 잘못 칠해진 칸이 9개 주어지고 색종이 4장을 사용한다면 가장 작은 색종이의 크기는 3cm이다.\n도화지의 행의 개수와 열의 개수, 그리고 도화지에 잘못 칠해진 칸들의 위치가 주어질 때, 주어진 장수의 색종이를 사용하여 앞의 세 가지 조건에 따라 모든 잘못 칠해진 칸을 가릴 수 있는 가장 작은 색종이의 크기를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 도화지 위의 행의 개수와 열의 개수를 나타내는 자연수가 빈칸을 사이에 두고 주어진다. 행의 개수와 열의 개수는 모두 1000000 이하이다. 둘째 줄에는 사용할 색종이의 장수를 나타내는 자연수가 주어진다. 사용할 색종이는 100장 이하이다. 셋째 줄에는 도화지에 잘못 칠해진 칸의 개수를 나타내는 자연수가 주어진다. 잘못 칠해진 칸은 1000개 이하이다. 넷째 줄부터 마지막 줄까지 잘못 칠해진 칸의 위치가 한 줄에 하나씩 주어진다. 잘못 칠해진 칸의 위치는 빈칸을 사이에 두고 행 번호가 주어진 다음 열 번호가 주어진다.\n",
        "output_text": "첫째 줄에 주어진 장수의 색종이를 사용하여 잘못 칠해진 칸을 모두 가릴 수 있는 가장 작은 색종이의 크기가 몇 cm인지를 나타내는 자연수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 889.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "505": {
        "problem_text": "승택이는 강을 건너려 한다.\n승택이는 수영을 못하기 때문에, 강에 놓인 징검다리를 밟고 건너갈 것이다.\n승택이는 수영은 못하지만 제자리뛰기는 정말 잘한다. 원하는 어느 곳으로든지 점프해서 바로 갈 수가 있다.\n승택이는 이제 강의 한쪽 변 앞에 서 있다.\n강엔 1번부터 시작해 2번, 3번, ... , N번 징검다리가 차례대로 놓여 있다.\n강의 폭이 넓은 탓에 징검다리의 수는 엄청나게 많다.\n이 징검다리를 모두 밟고 싶지는 않았던 승택이는 제자리뛰기 실력을 발휘해 적절한 개수의 징검다리만을 밟고 가기로 했다.\n물론 강 건너편으로 바로 점프하는 것도 가능하지만, 더 재미있게 강을 건너기 위해 승택이는 다음과 같은 규칙을 정했다.\n\n첫 징검다리는 점프해서 아무 것이나 밟을 수 있다. 이 점프가 첫 점프이다.\n두 번째 점프부터는 이전에 점프한 거리보다 1 이상 더 긴 거리를 뛰어야만 한다.\nN번 징검다리는 반드시 밟아야 한다.\nN번 징검다리를 밟은 후 강 건너로 이동할 땐 점프를 하지 않으므로 위의 규칙이 적용되지 않는다.\n\n승택이가 위의 규칙을 지키며 강을 건널 때, 밟을 수 있는 징검다리의 최대 수는 몇 개일까?\n",
        "input_text": "첫째 줄에 테스트 케이스의 수 T가 주어진다.\n각 테스트 케이스는 정수 한 개로 이루어져 있으며, 징검다리의 총 수 N을 의미한다. (1 ≤ N ≤ 1016)\n",
        "output_text": "각 테스트 케이스마다 한 줄에 승택이가 밟을 수 있는 최대 징검다리 수를 출력한다.\n",
        "memory_median": 2008.0,
        "time_median": 4.0,
        "length_median": 492.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "506": {
        "problem_text": "GSHS에서는 체력측정에서 제자리 멀리뛰기가 가장 중요하다. GSHS의 체육선생님께서는 학생들의 제자리 멀리뛰기 실력을 키워주게 하기 위해서 특수 훈련을 준비중이다.\n특수 훈련장소는 GSHS특수 트레이닝 센터로 이 곳은 끓는 용암으로 가득 차 있다. 체육선생님께서는 이 용암으로 가득찬 방의 가운데 있는 돌섬에 학생들을 가두고 학생들이 탈출해 나오기를 기대하고 있다. 탈출할 수 있는 방법은 단 한가지 이다. 돌섬에서 탈출구까지 띄엄 띄엄 존재하는 작은 돌섬들로 점프하여 탈출구까지 가는 것이다.\n돌섬에서 탈출구 사이에는 총 n개의 작은 돌섬이 있다. 선생님은 이 n개의 작은 돌섬들 중 m개를 제거하여 학생들이 최대한 멀리뛰기 연습의 효율을 높이기 위해서 학생들이 각 돌섬을 점프한 거리의 최솟값을 최대한 크게 하려고 한다. 물론 학생들은 체력이 좋기 때문에 두 돌섬이 아무리 멀더라도 점프할 수 있다. 즉, 빠지는 일은 없다.\n그리고 학생들은 탈출 시 n-m개의 모든 돌섬을 밟으면서 탈출해야 한다.\n학 생들이 갇힌 돌섬으로부터 탈출구까지의 거리 d가 주어지고, 각 n개의 작은 돌섬의 위치(갇힌 돌섬으로 부터의 거리)가 주어지며, 제거할 수 있는 작은 돌섬의 수 m이 주어질 때, m개를 제거한 후 학생들이 점프하는 최소거리의 최댓값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에는 갇힌 돌섬으로부터 탈출구까지의 거리 d(1 ≤ d ≤ 1,000,000,000), 작은 돌섬의 수 n(0 ≤ n ≤ 50,000), 제거할 수 있는 작은 돌섬의 수 m (0 ≤ m ≤ n)이 공백으로 구분되어 주어진다.\n두 번째 줄부터 n줄에 걸쳐서 갇힌섬으로부터 각 작은 돌섬이 얼마나 떨어져 있는지를 나타내는 하나의 정수가 한 줄에 하나씩 주어진다. (단, 두 돌섬은 같은 위치에 있을 수 없다.)\n",
        "output_text": "m개의 작은섬을 제거한 뒤 학생들이 점프할 수 있는 최소거리의 최댓값을 출력한다.\n",
        "memory_median": 2216.0,
        "time_median": 16.0,
        "length_median": 752.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "507": {
        "problem_text": "서버실은 여러 대의 서버 컴퓨터들을 안정적으로 운영할 수 있는 환경을 유지하기 위해 설치된 공간을 말한다.\n이 회사의 서버실은 N×N 칸으로 구분되어 있고, 각 칸마다 서버 랙이 있어 컴퓨터를 여러 대 쌓을 수 있다. 서버가 과열되지 않도록 서버실에는 언제나 냉방기가 작동하고 있다. 그런데 회사가 경제적으로 어려움에 처한 나머지, 서버실의 운영 비용을 줄이기 위해 서버실 내의 컴퓨터 중 절반만 정상적으로 관리하기로 하였다.\n냉방기에서 나온 차가운 공기는 서버실의 아래쪽부터 서서히 차오른다. 1분마다 컴퓨터 한 대의 높이만큼 방을 채운다. 이 회사의 서버 컴퓨터는 환경에 매우 민감하여 차가운 공기를 받아야만 동작하고 그렇지 못하면 장애를 일으킨다.\n서버실의 컴퓨터 중 절반 이상이 켜지려면 몇 분이 필요할까?\n",
        "input_text": "정수 N이 주어진다. (1 ≤ N ≤ 1000)\nN×N개의 각 칸에 컴퓨터가 몇 대 쌓여있는지가 입력된다. 한 칸에는 최대 10,000,000대까지 쌓여있을 수 있다.\n",
        "output_text": "몇 분이 지나야 전체 컴퓨터의 절반 이상이 장애를 일으키지 않고 동작할 수 있는지 출력한다.\n",
        "memory_median": 9038.0,
        "time_median": 178.0,
        "length_median": 756.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "508": {
        "problem_text": "오늘도 역시 준성이는 어김없이 색종이와 쿼리를 푸는 데 실패하였다!!\n색종이에 열등감을 느낀 준성이는 가위로 눈에 보이는 색종이를 모두 잘라 버리려고 한다!!\n색종이를 자를 때는 다음과 같은 규칙을 따른다.\n\n색종이는 직사각형이며, 색종이를 자를 때는 한 변에 평행하게 자른다.\n자르기 시작했으면, 경로 상의 모든 색종이를 자를 때까지 멈추지 않는다.\n이미 자른 곳을 또 자를 수 없다.\n\n분노에 찬 가위질을 하던 준성이는 갑자기 하나의 색종이를 정확히 n번의 가위질로 k개의 색종이 조각으로 만들 수 있는지 궁금해졌다.\r\n궁금하지만 화가 나서 코딩에 집중할 수 없는 준성이 대신 코드를 작성해주도록 하자.\n",
        "input_text": "첫 줄에 정수 n, k가 주어진다. (1 ≤ n ≤ 231-1, 1 ≤ k ≤ 263-1)\n",
        "output_text": "첫 줄에 정확히 n번의 가위질로 k개의 색종이 조각을 만들 수 있다면 YES, 아니라면 NO를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 554.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "509": {
        "problem_text": "동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그 원숭이는 좀 특이한 원숭이였다. 어떤 것도 꿰뚫어볼 수 있는 날카로운 눈을 가진 기이한 원숭이였다. 부드러운 눈을 가진 멍멍이는 언제나 날카로운 눈을 가진 원숭이를 부러워했지만 한편으로는 매우 질투했다.\n어느 날 멍멍이는 원숭이의 날카로운 눈이 너무 샘나서 원숭이를 직접 패고 싶었지만 날카로운 눈으로 찌를까봐 무서워서 때리지는 못하고 대신, 원숭이에게 문제 하나를 던져주었다. 그 문제는 다음과 같다.\n정수가 여러 개 모여 있는 정수더미가 있다. 그 안에 어떤 특정한 정수 하나만 홀수개 존재하고 나머지 정수는 모두 짝수개 존재한다. 정수더미 속에서 날카로운 눈을 이용해 홀수개 존재하는 정수를 찾아야 하는 문제이다.\n근데 멍멍이가 문제를 전달해 주려다가 생각해보니 정수더미 안에 정수가 적게 있으면 문제가 너무 쉬워지게 되는 것이다. 그래서 정수더미안에 정수를 무지막지하게 많이 넣기로 했다. 정수더미가 주어졌을 때, 그 안에 홀수개 존재하는 정수를 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 입력의 개수 N이 주어진다. N은 1이상 20,000이하인 수이다. 그 다음 줄부터 N줄에 걸쳐 세 개의 정수 A, C, B가 주어지는데, 이것은 A, A+B, A+2B, ..., A+kB (단, A+kB ≦ C) 의 정수들이 정수더미 안에 있다는 것을 나타낸다. A, B, C는 1보다 크거나 같고 2,147,483,647보다 작거나 같은 정수이다. 정수더미는 N개의 입력이 나타내는 정수들을 모두 포함한다.\n",
        "output_text": "첫째 줄에 정수 두 개를 출력하는데, 첫 번째는 홀수개 존재하는 정수를 출력하고, 두 번째는 그 정수가 몇 개 들어있는지 출력한다. 만약 홀수개 존재하는 정수가 없다면 NOTHING을 출력한다.\n",
        "memory_median": 2488.0,
        "time_median": 12.0,
        "length_median": 969.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "510": {
        "problem_text": "A, B, C가 주어졌을 때, Ax+Bsin(x)=C를 만족하는 x를 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 정수 A, B, C가 주어진다. (0 < B ≤ A ≤ 100,000, 0 < C ≤ 100,000)\n",
        "output_text": "첫째 줄에 x를 반올림해서 소수점 여섯째 자리까지 출력한다.\n",
        "memory_median": 2040.0,
        "time_median": 4.0,
        "length_median": 1161.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "511": {
        "problem_text": "세준 주차장은 R×C크기의 직사각형 모양이다. 세준 주차장에는 N개의 차와, M개의 주차 구역이 있다. 그리고, 모든 차는 주차 구역에 주차하려고 한다. 교통 제한 때문에, 차는 주차장의 경계와 평행하게만 움직일 수 있고, 모든 차는 1초에 한 칸씩 움직일 수 있다.\n보통 모든 차는 현재 위치에서 가장 가까운 위치에 있는 주차 구역에 주차를 하려고 한다. 하지만, 다음과 같이 생긴 주차장이라면 현재 위치에서 가장 가까운 위치에 주차하는 것이 비효율적이다.\n\r\n.C.....P.X...\r\nXX.......X..P\r\nXX.....C.....\n‘C’는 차이고, 'P‘는 주차 구역, 'X'는 벽이고, '.'은 빈 공간이다.\n만약 아래에 있는 차가 현재 위치에서 가장 가까운 곳에 주차를 한다면, 왼쪽 위에 있는 차는 가장 오른쪽에 있는 주차 구역에 주차를 해야 할 것이다. 이렇게 되면, 그 차가 주차하기 까지 14라는 시간이 걸린다. 하지만, 만약 아래에 있는 차가 오른 쪽에 있는 주차 구역에 주차를 하게 된다면, 두 차가 주차하기 까지 6이라는 시간이 걸린다.\n현재 주차장의 모양과, 차의 위치, 주차 구역의 위치가 주어졌을 때, 모든 차가 주차하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 차는 매우 작기 때문에, 한 칸에 여러 대의 차가 동시에 들어갈 수 있다. 차는 빈 공간과, 주차 구역만 통과할 수 있지만, 벽은 통과할 수 없다.\n만약 모든 차가 주차하는 것이 불가능하다면, -1을 출력한다.\n",
        "input_text": "첫째 줄에 주차장의 세로 크기 R과 가로 크기 C가 주어진다. R과 C의 크기는 50보다 작거나 같다. 둘째 줄부터 R개의 줄에는 주차장의 정보가 주어진다. 주차장의 정보는 문제에서 설명한 문자로 이루어져 있다. 차의 개수와, 주차 구역의 개수는 모두 0보다 크거나 같고 100을 넘지 않는다.\n",
        "output_text": "첫째 줄에 모든 차가 주차하는데 걸리는 시간의 최솟값을 출력한다. 차가 없는 경우는 0을 출력한다.\n",
        "memory_median": 2148.0,
        "time_median": 8.0,
        "length_median": 2630.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "512": {
        "problem_text": "직선 위에 서로 다른 N개의 점이 찍혀 있다. 점 i의 위치는 Xi이다. N개의 점 중 3개를 골라 가장 왼쪽에 있는 점을 a, 가운데 있는 점을 b, 가장 오른쪽에 있는 점을 c라고 하자. 각각의 점의 위치는 Xa, Xb, Xc이다. 이때 점 a, b 사이의 거리와 점 b, c사이의 거리가 같으면 세 점의 간격이 같다고 한다. 즉, Xb - Xa = Xc – Xb일 때 세 점의 간격이 같다. 다음은 N = 5인 경우의 예시이다.\n\n위 예시에서 점의 위치는 각각 -4, -1, 0, 2, 4이다. 이중 -4, -1, 0위치의 세 점을 각각 a, b, c라고 하면 Xb - Xa = 3, Xc – Xb = 1로 간격이 같지 않다. 그러나 -4, -1, 2 위치의 세 점을 각각 a, b, c라고 하면 Xb - Xa = 3, Xc – Xb = 3으로 세 점의 간격이 같다. 위 예시에서 간격이 같은 세 점 a, b, c로 가능한 경우는 (-4, -1, 2), (-4, 0, 4), (0, 2, 4)의 3가지가 있다. N개의 점의 위치가 주어졌을 때, 간격이 같은 세 점으로 가능한 경우가 모두 몇 가지 있는지 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 개수를 나타내는 자연수 T가 주어진다. 다음 줄부터 차례로 T개의 테스트 케이스가 주어진다. 각각의 테스트 케이스의 첫째 줄에 점의 개수 N(3 ≤ N ≤ 1,000)이 주어진다. 테스트 케이스의 둘째 줄에는 N개의 점의 위치 X1, X2, X3 … Xn이 차례로 주어진다. 모든 점의 위치는 -100,000,000이상 100,000,000이하의 정수이다.\n",
        "output_text": "각 테스트 케이스의 답을 순서대로 출력한다. 각 테스트 케이스마다 첫째 줄에 간격이 같은 세 점 a, b, c로 가능한 경우의 수를 출력한다.\n",
        "memory_median": 1992.0,
        "time_median": 460.0,
        "length_median": 692.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "513": {
        "problem_text": "1부터 N까지 번호가 붙여져 있는 N마리 서로 다른 동물이 있다. 모든 동물은 동일한 하나의 수평선 상에서 연속된 구간 내에서 활동한다. 이 구간을 그 동물의 활동영역이라 한다. 동물의 활동영역은 구간의 왼쪽 위치와 오른쪽 위치 쌍으로 나타낸다. 예를 들어, 7마리 동물의 활동영역이 다음 그림과 같다고 하자. 각 동물의 활동 영역은 선분으로 나타내어져 있다. 아래에서 동물 1의 활동영역은 (2, 4), 동물 2의 활동영역은 (6, 10), ..., 동물 7의 활동영역은 (3, 4)이다.\n\n활동영역이 (x1, x2)인 동물 i와 (x3, x4)인 동물 j에 대하여, 다음 세 조건 중 하나를 만족하면 i가 j보다 먹이사슬에서 상위에 있다고 한다. \n\n조건 1: x1 < x3 이고 x2 > x4\n조건 2: x1 = x3 이고 x2 > x4  \n조건 3: x1 < x3 이고 x2 = x4 \n\n동물들의 집단에 대하여 다음 조건을 만족하면서 모든 동물들을 나열 할 수 있으면, 이 집단은 먹이사슬 구조를 가진다고 말한다.\n조건: 나열된 각 동물은 뒤에 나오는 모든 동물보다 먹이사슬에서 상위에 있다. \n단, 하나의 동물로 이루어진 집단도 먹이사슬 구조를 가진다고 말한다. 먹이사슬 구조를 가지는 동물 집단의 크기는 이 집단에 속하는 동물의 수로 정의한다. \n동물들의 활동영역이 주어질 때, 먹이사슬 구조를 가지는 동물 집단의 최대 크기를 구하는 프로그램을 작성하시오. \n앞의 그림 예에서 먹이사슬 구조를 가지는 동물 집단의 예로 {1}, {2, 4}, {2, 6}, {1, 3}, {1, 3, 7}, ... 등이 있다. 집단 {1, 3, 7}에서  3은 1보다 상위이고 1은 7보다 상위로서 먹이사슬 구조를 가지는 최대 크기의 집단이다. 최대 크기 집단은 하나 이상일 수 있다.\n",
        "input_text": "첫 번째 줄에는 동물의 수를 나타내는 N (1 ≤ N ≤ 500,000)이 주어진다. 다음 각 줄에 동물의 번호, 동물의 활동영역의 왼쪽 위치 L, 오른쪽 위치 R이 빈 칸을 사이에 두고 나온다. L, R은 1 이상 1,000,000,000 이하의 양의 정수이다.\n",
        "output_text": "먹이사슬 구조를 가지는 최대 집단의 크기를 출력한다.\n",
        "memory_median": 8932.0,
        "time_median": 356.0,
        "length_median": 989.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "514": {
        "problem_text": "\r\n\tACM(Advanced Chip Manufacture)이라는 회사의 수석 칩(chip) 설계자인 한승이는 고민에 빠져있다. 경로 설계자들의 잘못으로 두 개의 블록의 포트를 연결하는 칩 위의 시그널들이 서로 교차하게 만들어졌다. 이 시점에서 경로 설계를 다시 하는 것은 비용이 너무 많이든다. 그 대신 엔지이너들은 교차하는 시그널들을 브리징 하기로 했다. 브리징은 시그널이 서로 교차하는 경우 하나의 시그널이 다른 시그널과 접촉하지 않도록 수직으로 띄우는 작업이다. 하지만 브리징은 어려운 작업이므로 가능하면 적은 수의 시그널만 브리징 해야한다. 실리콘 표면에서 서로 교차하지 않고 연결될 수 있는 최대 시그널의 개수를 찾는 프로그램을 작성하시오.\n\r\n\t \n\n\n\n\n\n\n\n\n\n\n그림 1. 문제가 생긴 두 개의 블록의 포트와 포트를 연결하는 시그널\n\n그림 2. 최대 세 개의 시그널이 서로 교차하지 않고 연결될 수 있다. 점선으로 표시된 시그널은 브리징 해야한다.\n\n\n\n\r\n\t \n\r\n\t두 개의 블록의 포트는 1번부터 N번까지 위에서 아래로 번호가 매겨져 있다. 각 포트는 다른 블록의 한 포트와 연결된다.\n",
        "input_text": "\r\n\t입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 첫 번째 줄에 포트의 개수 N(1 ≤ N ≤ 40000)이 주어지고, 두 번째 줄부터는 왼쪽 블록의 포트와 연결되어야 하는 오른쪽 블록의 포트 번호 ki(1 ≤ ki ≤ N)가 한 줄에 하나씩 N개 주어진다. 즉, i+1번째 줄에는 왼쪽 블록의 i번 포트와 연결되어야 하는 오른쪽 블록의 포트 번호가 주어진다.\n",
        "output_text": "\r\n\t각 테스트 케이스에 대해 서로 교차하지 않고 연결될 수 있는 최대 시그널의 개수를 한 줄에 하나씩 출력한다.\n",
        "memory_median": 2652.0,
        "time_median": 28.0,
        "length_median": 602.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "515": {
        "problem_text": "서강 백화점이 블랙 프라이데이를 맞아서 특별 이벤트를 진행한다. 백화점에서 제시하는 양의 정수의 무게 C에 딱 맞게 물건들을 가져오면 전부 만 원에 판매하는 이벤트이다.\n선택할 수 있는 물건은 최대 3개까지이고, 같은 물건을 중복 선택하는 것은 불가능하다. 그리고 백화점에서 판매하는 물건들의 무게는 모두 다르다.\n예를 들어, 백화점에서 판매하고 있는 물건 5개의 무게가 각각 1, 2, 3, 4, 5일 때, C가 5라면 {2, 3} 또는 {5}에 해당하는 물건의 조합을 만 원에 구매할 수 있다.\n판매하는 물건 N개의 양의 정수의 무게가 각각 주어질 때, 만 원에 구매할 수 있는 조합이 있는지 출력하라.\n",
        "input_text": "첫 번째 줄에 물건의 개수 N과 제시하는 무게 C가 공백으로 구분되어 주어진다. (1 ≤ N ≤ 5,000, 1 ≤ C ≤ 108, N과 C는 양의 정수)\n다음 줄에는 N개의 물건 각각의 무게 w가 공백으로 구분되어 주어진다. (1 ≤ w ≤ 108, w는 양의 정수)\n",
        "output_text": "문제의 조건을 만족하는 조합이 있으면 1, 그렇지 않으면 0을 출력한다.\n",
        "memory_median": 2160.0,
        "time_median": 140.0,
        "length_median": 872.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "516": {
        "problem_text": "오늘 사탕 M개를 가득 담은 박스가 택배로 택희네 집에 도착했다. 택희는 이 사탕을 N명의 친구들에게 나누어 주려고 한다.\n택희의 친구들은 문자로 사탕을 몇 개 받고 싶은지 보냈다. 만약 받고 싶은 개수만큼 사탕을 받지 못한다면, 그 친구는 분노하게 되고, 못 받는 개수가 많아질 수록 더욱 분노하게 된다.\n놀랍게도 택희는 친구들의 분노를 수치화 할 수 있는데, 이것은 못 받는 사탕 개수의 제곱이다.\n예를 들어, 택희의 친구 백준이가 받고 싶은 사탕의 개수가 32개였을 때, 사탕을 29개 받아 3개를 받지 못한다면, 그의 분노는 3의 제곱 9가 된다.\n택희가 받은 사탕의 개수와 친구의 수, 그리고 그 친구들이 받고 싶어하는 사탕의 개수가 주어졌을 때, 사탕을 적절히 나누어 주어 친구들의 분노의 합을 최소화해 그 값을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 M(1 ≤ M ≤ 2×109)와 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 친구들이 받고 싶어하는 사탕의 개수가 주어진다. 이 개수는 2×109보다 작으며, 친구들이 받고 싶어하는 사탕의 개수의 합은 항상 M을 넘는다.\n",
        "output_text": "첫째 줄에 택희 친구들의 분노의 합의 최솟값을 264로 나눈 나머지를 출력한다.\n",
        "memory_median": 2796.0,
        "time_median": 20.0,
        "length_median": 679.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "517": {
        "problem_text": "창영이의 퇴근길은 출근길과 조금 다르다. 창영이는 건강을 위해 따릉이를 빌려 타고 퇴근하는 습관을 기르고 있다.\n창영이의 퇴근길은 N×N 크기의 격자로 표현된다. 창영이는 A1,1에서 출발하여 AN,N까지 이동할 계획이다. 창영이는 상하좌우 인접한 격자로 한 번에 한 칸씩 이동할 수 있다. 각 격자 Ar,c에는 자연수가 적혀 있는데, 이는 해당 지역의 높이를 뜻한다. 인접한 격자 사이의 높이 차이의 절댓값을 경사라고 하고, 경사가 클수록 경사가 가파르다고 하자.\n따릉이는 가격에 따라 성능이 다르다. 비싼 따릉이는 경사가 가파르더라도 내리지 않고 타고 갈 수 있지만, 값싼 따릉이는 경사가 가파르면 힘들고 위험하기 때문에 내려서 이동해야 한다.\n창영이는 최소한의 비용으로 따릉이를 빌려서, 따릉이에서 한 번도 내리지 않고 집에 도착하고 싶다. 그러기 위해선 창영이가 지날 수 있는 최대 경사의 최솟값을 알아야만 한다. 여러분들이 창영이를 도와주자.\n",
        "input_text": "첫째 줄에 격자의 크기 N이 주어진다.\n둘째 줄부터 N개의 줄에 걸쳐 각 격자의 높이 정보가 주어진다. 첫 번째로 주어지는 값이 A1,1이고, 마지막으로 주어지는 값이 AN,N이다.\n",
        "output_text": "A1,1에서 AN,N까지, 경로상의 최대 경사의 최솟값을 출력한다.\n",
        "memory_median": 32260.0,
        "time_median": 534.0,
        "length_median": 1392.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "518": {
        "problem_text": "Given two sets P and Q of finitely many points in the plane, a closest pair of P and Q is a pair (p, q) of points p ∈ P and q ∈ Q such that the distance between p and q is the minimum among all pairs (p′, q′) with p′ ∈ P and q′ ∈ Q.\nSpecifically, in this problem, by the distance between two points a and b in the plane, we mean:\nd(a, b) = |xa - xb| + |ya - yb|\nwhere xa and ya denote the x- and y-coordinates of point a, and xb and yb denote the x- and y-coordinates of point b. Then, a pair (p, q) with p ∈ P and q ∈ Q is a closest pair of P and Q if and only if the following holds:\nd(p, q) = min{ d(p′, q′) | p′ ∈ P and q′ ∈ Q}\nGiven two sets P and Q, write a program that computes the distance between a closest pair of P and Q and the number of distinct closest pairs of P and Q.\nNote that you can assume the following on the input points in P and Q:\n\nAll the points in P lie on the horizontal line y = c1 while all the points in Q lie on the horizontal line y = c2 for some integers c1 and c2.\nNo two input points in P have the same coordinates; no two input points in Q have the same coordinates.\n\n",
        "input_text": "Your program is to read from standard input. The input consists of four lines. The first line contains two integers, n (1 ≤ n ≤ 500,000) and m (1 ≤ m ≤ 500,000), where n is the number of points in set P and m is the number of points in set Q. In the second line, two integers c1 and c2 (-108 ≤ c1, c2 ≤ 108) are given in order, separated by a single space. In the third line, n distinct integers between -108 and 108, inclusively, are given, separated by a single space, that are the x-coordinates of the points in set P, while their y- coordinates are all the same as c1. In the fourth line, m distinct integers between -108 and 108, inclusively, are given, separated by a single space, that are the x-coordinates of the points in set Q, while their y- coordinates are all the same as c2.\n",
        "output_text": "Your program is to write to standard output. Print exactly one line for the input. The line should contain two integers, separated by a single space, that represent the distance between a closest pair of P and Q and the number of closest pairs of P and Q in this order.\n",
        "memory_median": 8260.0,
        "time_median": 296.0,
        "length_median": 950.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "519": {
        "problem_text": "길이가 동일한 수열 $X=(x_0, x_1, \\cdots, x_{n-1})$와 $Y=(y_0, y_1, \\cdots, y_{n-1})$가 있다.\n이 두 수열의 각 원소는 음이 아닌 정수이다. 다음은 $n=5$인 경우의 한 예이다.\n\\[X=(1,0,0,0,1)\\]\n\\[Y=(0,5,2,0,1)\\]\n임의의 정수 $t$가 주어졌을 때 $XCorr(t)$는 다음과 같이 정의된다.\n\\[XCorr(t)=\\displaystyle\\sum_{i=0}^{n-1}{x_iy_{i+t}}\\]\n($i<0$이거나 $i\\geq n$이면 $x_i=y_i=0$으로 간주한다.)\n예를 들어 $t$가 $0, 1, -1$일 때, $XCorr(t)$값은 다음과 같이 계산된다.\n\\[XCorr(0) = x_0y_0 + x_1y_1 + \\dots + x_{n-1}y_{n-1}\\]\n\n\\[XCorr(1) = x_0y_1 + x_1y_2 + \\dots + x_{n-1}y_n\\]\n\n회색 칸에 들어있는 부분은 계산결과에 영향을 주지 않음에 주의하라. $y_0$는 계산식에 포함되지 않고, $x_{n-1}$은 곱해지는 $y_n=0$ 이므로 계산 결과에 영향을 주지 않는다. 따라서 예시 수열 $X$와 $Y$에서 $XCorr(1)$은 다음과 같이 계산할 수 있다.\n\\[1\\times5+0\\times2+0\\times0+0\\times1=5\\]\n\\[XCorr(-1) = x_0y_{-1} + x_1y_0 + \\dots + x_{n-1}y_{n-2}\\]\n\n임의의 $t$값의 범위 $(a \\le t \\le b)$에 대해 $XCorr(t)$를 모두 구해서 더한 값 $S(a,b)$는 다음과 같이 정의된다.\n\\[S(a,b)=\\displaystyle\\sum_{a \\le t \\le b}{XCorr(t)}\\]\n수열 $X$,$Y$와 $t$의 범위 $a$, $b$가 주어졌을 때 $S(a,b)$를 구하는 프로그램을 작성하시오.\n",
        "input_text": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 수열 $X$에서 0이 아닌 정수의 개수 $N$이 주어진다.(수열의 길이 $n$이 아님). 다음 $N$개의 줄에는 수열 $X$의 각 양의 정수 $x_i$에 대해 인덱스 $i$ 와 $x_i$ 값이 인덱스의 오름차순으로 주어진다. 다음 줄부터는 수열 $Y$가 $X$와 동일한 방식으로 주어진다. ($Y$에서 0이 아닌 정수의 개수 $M$이 주어지고 다음 $M$개의 줄에는 수열 $Y$의 각 양의 정수 $y_i$에 대해 인덱스 $i$와 $y_i$ 값이 인덱스의 오름차순으로 주어진다.) 다음 줄에는 $t$의 범위의 최솟값인 정수 $a$가 주어지고, 그 다음 줄에는 $t$의 범위의 최댓값인 정수 $b$ ($a \\le b$)가 주어진다. \n",
        "output_text": "표준 출력으로 $S(a,b)=\\displaystyle\\sum_{a \\leq t \\leq b}{XCorr(t)}$ 값을 정수로 출력하라.\n",
        "memory_median": 11400.0,
        "time_median": 196.0,
        "length_median": 912.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "520": {
        "problem_text": "N개의 음 아닌 정수들이 있다. 이들 중 몇 개의 정수를 선택하여 나열하면 등차수열을 만들 수 있다. 예를 들어 4, 3, 1, 5, 7이 있을 때 1, 3, 5, 7을 선택하여 나열하면 등차수열이 된다. 이와 같이 했을 때, 등차수열의 길이가 최대 얼마까지 가능한지 알아내시오.\n등차수열은 일정한 값만큼 증가하는 수열을 말한다. 이 일정한 값은 음수나 0도 될 수 있다.\n",
        "input_text": "첫째 줄에는 숫자의 개수 N(1 ≤ N ≤ 2,000)이 주어지고, 다음 N개의 줄에는 정수들이 주어진다. 정수들은 1,000,000,000보다 작은 음이 아닌 정수이다.\n",
        "output_text": "첫째 줄에 가장 긴 등차수열의 길이를 출력한다.\n",
        "memory_median": 17684.0,
        "time_median": 84.0,
        "length_median": 1005.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "521": {
        "problem_text": "Farmer John has just arranged his N haybales (1≤N≤100,000) at various points along the one-dimensional road running across his farm. To make sure they are spaced out appropriately, please help him answer Q queries (1≤Q≤100,000), each asking for the number of haybales within a specific interval along the road.\n \n",
        "input_text": "The first line contains N and Q.\nThe next line contains N distinct integers, each in the range 0…1,000,000,000, indicating that there is a haybale at each of those locations.\nEach of the next Q lines contains two integers A and B (0≤A≤B≤1,000,000,000) giving a query for the number of haybales between A and B, inclusive.\n",
        "output_text": "You should write Q lines of output. For each query, output the number of haybales in its respective interval.\n",
        "memory_median": 2412.0,
        "time_median": 84.0,
        "length_median": 546.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "522": {
        "problem_text": "생일을 맞이한 주성이가 생일 파티를 준비하려고 한다. 주성이는 일반 케이크 대신 평소 좋아하던 롤 케이크를 준비했다. 롤 케이크에는 장식이 존재해서 특정 위치에서만 자를 수 있다. 주성이는 롤 케이크 조각을 파티에 올 친구의 수 만큼 준비하고 싶어서, 가장 작은 조각의 크기를 미리 알아보기로 했다. 하지만 짓궂은 주성이의 친구들은 생일파티에 몇 명이 참석하는지 직접적으로 알려주지를 않는다. 그래서 몇 개의 수를 목록에 적어, 각 수만큼 조각을 만들었을 때 가장 작은 조각의 길이의 최댓값을 구하려고 한다.\n예를 들어 70cm의 롤 케이크에 자를 수 있는 지점이 5군데(10cm, 20cm, 35cm, 55cm, 60cm)가 있다고 하자. 만약 목록에 적힌 수 중 하나가 3이라면 이때 가장 작은 조각의 길이는 최대 15cm이다. 예를 들어 20cm, 35cm, 55cm 지점을 자를 때 최대가 된다.\n",
        "input_text": "첫 번째 줄에 자르는 횟수가 담긴 목록의 길이 N과 자를 수 있는 지점의 개수 M, 그리고 롤 케이크의 길이인 정수 L이 주어진다. (1 ≤ N ≤ M ≤ 1,000, 1 < L ≤ 4,000,000)\n다음 M줄에 걸쳐 자를 수 있는 지점을 나타내는 정수 Si가 주어진다. (1 ≤ Si < L)\n다음 N줄에 걸쳐 자르는 횟수를 나타내는 정수 Qi가 주어진다. (1 ≤ Qi ≤ M)\nSi는 오름차순으로 주어지고 중복되는 수는 없으며, Qi도 마찬가지이다.\n",
        "output_text": "N개 줄에 걸쳐 각 목록에 있는 횟수대로 롤 케이크를 잘랐을 때 가장 작은 조각의 길이의 최댓값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 32.0,
        "length_median": 870.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "523": {
        "problem_text": "$N$개의 돌이 일렬로 나열 되어 있다. $N$개의 돌에는 왼쪽부터 차례대로 수 $A_{1} A_{2} ... A_{i} ... A_{N}$로 부여되어 있다. 가장 왼쪽에 있는 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너가려고 한다.\n\n항상 오른쪽으로만 이동할 수 있다.\n$i$번째 돌에서 $j(i < j)$번째 돌로 이동할 때 $(j - i)$ × (1 + |$A_{i} - A_{j}$|) 만큼 힘을 쓴다.\n돌을 한번 건너갈 때마다 쓸 수 있는 힘은 최대 $K$이다.\n\n가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 $K$의 최솟값을 구해보자.\n",
        "input_text": "첫 번째 줄에 돌의 개수 $N$이 공백으로 구분되어 주어진다.\n두 번째 줄에는 $N$개의 돌의 수 $A_i$가 공백으로 구분되어 주어진다.\n",
        "output_text": "가장 왼쪽 돌에서 출발하여 가장 오른쪽에 있는 돌로 건너갈 수 있는 모든 경우 중 가능한 $K$의 최솟값을 출력한다.\n",
        "memory_median": 2178.0,
        "time_median": 34.0,
        "length_median": 621.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "524": {
        "problem_text": "문자열 A가 문자열 B의 줄임말이라는 것은 B의 순서를 바꾸지 않고 0 또는 그 이상 개수의 문자를 지워 A를 만들 수 있다는 뜻이다. 정의에 의해서 B는 자기 자신의 줄임말임에 유의하라. 예를 들어, ac, ab, aa, aabc는 aabc의 줄임말이고, d, aaa, ba는 aabc의 줄임말이 아니다.\n영문 알파벳 소문자로만 이루어진 두 문자열 S와 T가 주어진다. T를 자연수 n번 반복해서 이어쓴 문자열을 T n이라고 하자. S가 T n의 줄임말이 되는 최소의 n을 구하라.\n예를 들어, T = ac, S = caa라고 하면, T1 = T = ac, T2 = acac, T3 = acacac이고 n = 3일 때 처음으로 S가 Tn의 줄임말이 된다.\n",
        "input_text": "첫째 줄에 문자열 S가 주어진다.\n둘째 줄에 문자열 T가 주어진다.\n",
        "output_text": "S가 Tn의 줄임말이 되는 최소의 n을 출력한다. 단, 어떤 n에 대해서도 Tn이 S의 줄임말이 되지 못할 때에는, -1을 출력한다.\n",
        "memory_median": 4916.0,
        "time_median": 64.0,
        "length_median": 801.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "525": {
        "problem_text": "정래는 김밥가게 “그르다 김가놈”에 납품할 김밥을 만드는 김밥 공장을 운영한다. 정래는 김밥 양쪽 끝을 “꼬다리”라고 부른다. 그리고 꼬다리를 잘라낸 김밥을 “손질된 김밥”이라고 부른다. \n공장에서는 김밥 N개에 대해서, 김밥 꼬다리를 잘라내고 손질된 김밥을 김밥조각으로 만드는 작업을 한다. 꼬다리를 잘라낼 때에는 양쪽에서 균일하게 K cm만큼 잘라낸다. 만약 김밥의 길이가 2K cm보다 짧아서 한쪽밖에 자르지 못한다면, 한쪽만 꼬다리를 잘라낸다. 김밥 길이가 K cm이거나 그보다 짧으면 그 김밥은 폐기한다.\n손질된 김밥들은 모두 일정한 길이 P로 잘라서 P cm의 김밥조각들로 만든다. P는 양의 정수여야 한다. 정래는 일정한 길이 P cm로 자른 김밥조각을 최소 M개 만들고 싶다. P를 최대한 길게 하고 싶을 때, P는 얼마로 설정해야 하는지 구하시오.\n",
        "input_text": "첫 번째 줄에 손질해야 하는 김밥의 개수 N, 꼬다리의 길이 K, 김밥조각의 최소 개수 M이 주어진다. (1 ≤ N ≤ 106, 1 ≤ K, M ≤ 109, N, K, M은 정수)\n두 번째 줄부터 김밥의 길이 L이 N개 주어진다. (1 ≤ L ≤ 109, L은 정수)\n",
        "output_text": "김밥조각의 길이 P를 최대로 할 때, P를 출력한다. 만족하는 P가 없는 경우, -1을 출력한다.\n",
        "memory_median": 8176.0,
        "time_median": 246.0,
        "length_median": 820.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "526": {
        "problem_text": "소싯적 호석이는 골목 대장의 삶을 살았다. 호석이가 살던 마을은 N 개의 교차로와 M 개의 골목이 있었다. 교차로의 번호는 1번부터 N 번까지로 표현한다. 골목은 서로 다른 두 교차로를 양방향으로 이어주며 임의의 두 교차로를 잇는 골목은 최대 한 개만 존재한다. 분신술을 쓰는 호석이는 모든 골목에 자신의 분신을 두었고, 골목마다 통과하는 사람에게 수금할 것이다. 수금하는 요금은 골목마다 다를 수 있다.\n당신은 A 번 교차로에서 B 번 교차로까지 C 원을 가지고 가려고 한다. 호석이의 횡포를 보며 짜증은 나지만, 분신술을 이겨낼 방법이 없어서 돈을 내고 가려고 한다. 하지만 이왕 지나갈 거면, 최소한의 수치심을 받고 싶다. 당신이 받는 수치심은 경로 상에서 가장 많이 낸 돈에 비례하기 때문에, 결국 갈 수 있는 다양한 방법들 중에서 최소한의 수치심을 받으려고 한다. 즉, 한 골목에서 내야 하는 최대 요금을 최소화하는 것이다.\n\n예를 들어, 위의 그림과 같이 5개의 교차로와 5개의 골목이 있으며, 당신이 1번 교차로에서 3번 교차로로 가고 싶은 상황이라고 하자. 만약 10원을 들고 출발한다면 2가지 경로로 갈 수 있다. 1번 -> 2번 -> 3번 교차로로 이동하게 되면 총 10원이 필요하고 이 과정에서 최대 수금액을 5원이었고, 1번 -> 4번 -> 5번 -> 3번 교차로로 이동하게 되면 총 8원이 필요하며 최대 수금액은 6원이 된다. 최소한의 수치심을 얻는 경로는 최대 수금액이 5인 경로이다. 하지만 만약 8원밖에 없다면, 전자의 경로는 갈 수 없기 때문에 최대 수금액이 6원인 경로로 가야 하는 것이 최선이다.\n당신은 앞선 예제를 통해서, 수치심을 줄이고 싶을 수록 같거나 더 많은 돈이 필요하고, 수치심을 더 받는 것을 감수하면 같거나 더 적은 돈이 필요하게 된다는 것을 알게 되었다. 마을의 지도와 골목마다 존재하는 호석이가 수금하는 금액을 안다면, 당신이 한 골목에서 내야하는 최대 요금의 최솟값을 계산하자. 만약 지금 가진 돈으로는 절대로 목표 지점을 갈 수 없다면 -1 을 출력하라.\n",
        "input_text": "첫 줄에 교차로 개수 N, 골목 개수 M, 시작 교차로 번호 A, 도착 교차로 번호 B, 가진 돈 C 가 공백으로 구분되어 주어진다. 이어서 M 개의 줄에 걸쳐서 각 골목이 잇는 교차로 2개의 번호와, 골목의 수금액이 공백으로 구분되어 주어진다. 같은 교차로를 잇는 골목은 최대 한 번만 주어지며, 골목은 양방향이다.\n",
        "output_text": "호석이가 지키고 있는 골목들을 통해서 시작 교차로에서 도착 교차로까지 C 원 이하로 가는 경로들 중에, 지나는 골목의 요금의 최댓값의 최솟값을 출력하라. 만약 갈 수 없다면 -1을 출력한다.\n",
        "memory_median": 36004.0,
        "time_median": 1110.0,
        "length_median": 1433.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "527": {
        "problem_text": "도현이는 홍익 투어리스트가 되어 홍익대학교를 견학하려고 한다. 홍익대학교는 $N$개의 구역이 원형으로 배치된 모습이다. $1$번 구역에서 시계 방향으로 각각 $2$번, ... , $N$번 구역이 존재하고, $N$번 구역에서 시계 방향으로 한 칸 더 갈 경우 $1$번 구역으로 도착한다. \n홍익대학교에는 명소가 존재한다. 도현이는 알찬 투어를 위해 명소만을 방문하려 한다. 도현이는 $1$번 구역에 서있다.\n도현이를 위해 다음과 같은 쿼리를 수행하는 프로그램을 작성해보자.\n\n$1$ $i$ : $i$번 구역이 명소가 아니었다면 명소로 지정되고, 명소였다면 지정이 풀리게 된다. ($1 \\leq i \\leq N$)\n$2$ $x$ : 도현이가 시계방향으로 $x$만큼 이동한다. ($1 \\leq x \\leq 10^9$)\n$3$ : 도현이가 명소에 도달하기 위해 시계방향으로 최소 몇 칸 움직여야 하는 지 출력한다. 명소가 존재하지 않는 경우 $-1$을 출력한다.\n\n",
        "input_text": "첫째 줄에 구역의 개수 $N$ ($1 \\leq N \\leq 500\\,000$)과 쿼리의 개수 $Q$ ($1 \\leq Q \\leq 100\\,000$)가 정수로 주어진다.\n둘째 줄에 길이 $N$의 수열 $A$가 주어진다. $i$번째 구역이 명소라면 $A_i$는 $1$, 그렇지 않다면 $0$이다.\n셋째 줄부터 $Q$줄에 걸쳐 본문의 쿼리가 주어진다. $3$번 쿼리는 하나 이상 존재한다.\n",
        "output_text": "$3$번 쿼리가 주어질 때마다 해당 쿼리의 값을 출력한다.\n",
        "memory_median": 20768.0,
        "time_median": 172.0,
        "length_median": 1020.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "528": {
        "problem_text": "인스타 빵타쿠들의 꾸준한 사랑을 받는 베이커리 <성싶당>은 수현이가 그동안 쌓아온 노하우를 바탕으로 밀키트 사업에도 진출했다! 이제 성싶당의 맛을 집에서도 즐길 수 있다!\n이 소식을 놓칠 리 없는 빵타쿠 한별이는 바로 성싶당에 달려가 밀키트를 사 왔다. 그러나 문제를 푸느라 바쁜 한별이는 깜빡 잊고 유통기한 안에 밀키트를 먹지 못했다. 눈물을 머금고 밀키트를 버리려고 포장을 뜯은 순간 한별이는 재료마다 유통기한이 다르다는 것을 발견했다. 밀키트의 유통기한은 모든 재료의 유통기한 중 가장 이른 것으로 결정되기 때문에 아직 유통기한이 지나지 않은 재료들이 남아 있었다.\n밀키트에는 $N$ 개의 재료가 들어 있다. $i$ 번째 재료의 유통기한은 밀키트를 구매한 후 $L_i$ 일까지이고, 부패 속도는 $S_i$이다. 이 때 구매 후 $x$ 일에 $i$ 번째 재료에 있는 세균수는\n\\[ S_i \\times \\max\\left( 1, x-L_i \\right) \\]\n마리이다. 단, $x$는 정수이다.\n모든 재료의 세균수의 합이 $G$ 마리 이하일 경우 안심하고 먹을 수 있다. 밀키트를 너무 먹어보고 싶은 한별이는 중요하지 않은 재료를 최대 $K$ 개까지 빼서 세균수가 $G$ 마리 이하가 된다면 그냥 먹기로 했다.\n한별이는 밀키트를 산 날부터 며칠 후까지 먹을 수 있을까?\n",
        "input_text": "첫 번째 줄에 $N, G, K$가 공백으로 구분되어 주어진다.\n두 번째 줄부터 $N$ 개의 줄 중 $i$ 번째 줄에는 $i$ 번째 재료에 대한 정보인 부패 속도 $S_i$, 유통기한 $L_i$와 중요한 재료인지를 나타내는 수 $O_i$가 주어진다. $O_i$는 $0$ 또는 $1$이며, $O_i=1$은 재료가 중요하지 않아서 뺄 수 있다는 의미이다.\n",
        "output_text": "중요하지 않은 재료를 최대 $K$ 개까지 뺐을 때, 밀키트를 구매 후 며칠 후까지 먹을 수 있는지 출력한다.\n",
        "memory_median": 10800.0,
        "time_median": 268.0,
        "length_median": 1176.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "529": {
        "problem_text": "세준이는 세준항공으로 돈을 무지막지하게 번 뒤, 레이스 대회를 개최했다. 레이스 트랙은 길이가 N인 직선이다.\n세준이는 심판 M명을 적절한 곳에 배치시키려고 한다. 심판은 아무 곳에나 배치시킬 수 있지 않다. 심판은 미리 정해진 K개의 곳에만 위치할 수 있다.\n세준이는 심판을 배치할 때, 가장 가까운 두 심판의 거리를 최대로 하려고 한다.\n심판을 어디에 배치시켜야 할지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N, M, K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, M은 K보다 작거나 같은 자연수이다. 또, K는 2보다 크거나 같고, 50보다 작거나 같다. 둘째 줄에 심판이 있을 수 있는 K개의 위치가 주어진다. K개의 위치는 N보다 작거나 같은 자연수 또는 0이며, 오름차순으로 주어진다.\n",
        "output_text": "첫째 줄에 심판을 어떻게 배치시켜야 가장 가까운 심판의 거리가 최대가 될 것이지 출력한다. 출력할 때는 예제와 같이 심판을 세울 곳에는 1을, 세우지 않을 곳에는 0을 출력한다. 만약 정답이 여러개일 경우에는 사전순으로 가장 늦는 것을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 979.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "530": {
        "problem_text": "정수 N개로 이루어진 배열 A가 주어진다. 상근이는 수열의 수 하나를 골라서 값을 1 감소시킬 수 있다. 단, 수는 1보다 작아질 수 없다.\n상근이는 위의 감소시키는 연산을 최대 T번 하려고 한다. 이때, 인접한 수의 차이의 최댓값을 최소로 하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 T가 주어진다. (2 ≤ N ≤ 100 000, 1 ≤ T ≤ 109)\n둘째 줄에는 배열 A에 들어있는 수 A1, A2, ..., AN이 주어진다. (1 ≤ Ai < 109)\n",
        "output_text": "첫째 줄에 인접한 수의 차이의 최댓값을 가장 작게한 배열 A의 A1, A2, ..., AN을 공백으로 구분하여 출력한다.\n",
        "memory_median": 3192.0,
        "time_median": 44.0,
        "length_median": 1102.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "531": {
        "problem_text": "정수 배열 A 와 B가 있다. A는 총 n개의 서로 다른 양의 정수를 포함하고 B는 총 m개의 서로 다른 양의 정수를 포함한다.\nA, B를 이용해서 길이가 n인 새로운 배열 C를 만들어보자.\n\nC[i] 는 배열 B에 있는 값 중 A[i] 에 가장 가까운 값 (절대값 차이가 가장 작은 값)으로 정의 된다. \n만약 이 조건을 만족하는 값들이 여럿 있는 경우, 그 중 가장 크기가 작은 값으로 정의 된다.\n\n예를 들어 A = [20, 5, 14, 9] 그리고 B = [16, 8, 12] 라고 해보자.\n\nC[1] = 16 이다 - 왜냐하면 B[1] = 16이 A[1] = 20에 가장 가깝기 때문이다.\nC[2] = 8 이다 - 왜냐하면 B[2] = 8이 A[2] = 5에 가장 가깝기 때문이다.\nC[3] = 12 이다 - 왜냐하면 B[1] = 16 와 B[3] = 12 모두 A[3] = 14에 가장 가깝지만, B[3]의 값이 더 작기 때문이다.\nC[4] = 8이다.\n\n이 예제의 경우 C = [16, 8, 12, 8]으로 정의된다.\n두 배열 A와 B가 주어졌을 때, 새로운 배열 C를 계산하여 배열 C에 포함된 값들의 합을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫 줄에 테스트 케이스의 수 T (1 <= T <= 10)가 주어진다.\n각 테스트 케이스는 세 줄에 걸쳐서 주어진다.\n첫 줄에는 n과 m이 공백으로 구분되어 주어진다 (1 <= n, m <= 10^6).\n두 번째 줄에는 공백으로 구분된 n개의 정수가 주어지며, A[1] 부터 A[n]을 나타낸다 (각각의 값은 1이상 10^9 이하이다).\n세 번째 줄에는 공백으로 구분된 m개의 정수가 주어지며, B[1] 부터 B[m]을 나타낸다 (각각의 값은 1이상 10^9 이하이다).\n앞서 언급한대로, A와 B는 각각 서로 다른 양의 정수들을 포함한 배열들이다.\n",
        "output_text": "각 테스트 케이스에 대해 배열 C를 구하고 해당 배열의 모든 원소 합을 한 줄에 출력하시오.\n",
        "memory_median": 9796.0,
        "time_median": 306.0,
        "length_median": 1086.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "532": {
        "problem_text": "\r\n\t어떤 양의 정수가 주어졌을 때, 이 수의 세제곱근을 구하는 프로그램을 작성하시오.\n",
        "input_text": "\r\n\t첫째 줄에 테스트 케이스의 개수 T가 주어진다. 테스트 케이스는 한 줄로 구성되어 있다. 세제곱근을 구하고자 하는 수가 한 줄에 하나씩 입력으로 주어지며, 이 수는 150자리 이하이다. 수는 0으로 시작할 수도 있다.\n",
        "output_text": "\r\n\t각 테스트 케이스에 대해서, 입력으로 주어진 수의 세제곱근을 소수점 10째짜리까지 출력한다. 이때, 반올림을 하는 것이 아니고, 버림을 해야 한다.\n",
        "memory_median": 2028.0,
        "time_median": 32.0,
        "length_median": 2542.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "533": {
        "problem_text": "Farmer John's cows have recently become fans of playing a simple number game called \"FizzBuzz\". The rules of the game are simple: standing in a circle, the cows sequentially count upward from one, each cow saying a single number when it is her turn. If a cow ever reaches a multiple of 3, however, she should say \"Fizz\" instead of that number. If a cow reaches a multiple of 5, she should say \"Buzz\" instead of that number. If a cow reaches a multiple of 15, she should say \"FizzBuzz\" instead of that number. A transcript of the first part of a game is therefore:\n1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16\nHaving a slightly more limited vocabulary, the version of FizzBuzz played by the cows involves saying \"Moo\" instead of Fizz, Buzz, and FizzBuzz. The beginning of the cow version of the game is therefore\n1, 2, Moo, 4, Moo, Moo, 7, 8, Moo, Moo, 11, Moo, 13, 14, Moo, 16\nGiven $N$ ($1 \\leq N \\leq 10^9$), please determine the $N$th number spoken in this game.\n",
        "input_text": "The input consists of a single integer, $N$.\n",
        "output_text": "Please print out the $N$th number spoken during the game.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 428.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0
        ]
    },
    "534": {
        "problem_text": "요즘 종수는 아두이노를 이용해 \"Robots\"이라는 게임을 만들었다. 종수는 아두이노 한대를 조정하며, 미친 아두이노를 피해다녀야 한다. 미친 아두이노는 종수의 아두이노를 향해 점점 다가온다. 하지만, 미친 아두이노의 움직임은 예측할 수 있다.\n게임은 R×C크기의 보드 위에서 이루어지며, 아래와 같은 5가지 과정이 반복된다.\n\n먼저, 종수가 아두이노를 8가지 방향(수직,수평,대각선)으로 이동시키거나, 그 위치에 그대로 놔둔다.\n종수의 아두이노가 미친 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되며, 종수는 게임을 지게 된다.\n미친 아두이노는 8가지 방향 중에서 종수의 아두이노와 가장 가까워 지는 방향으로 한 칸 이동한다. 즉, 종수의 위치를 (r1,s1), 미친 아두이노의 위치를 (r2, s2)라고 했을 때, |r1-r2| + |s1-s2|가 가장 작아지는 방향으로 이동한다.\n미친 아두이노가 종수의 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되고, 종수는 게임을 지게 된다.\n2개 또는 그 이상의 미친 아두이노가 같은 칸에 있는 경우에는 큰 폭발이 일어나고, 그 칸에 있는 아두이노는 모두 파괴된다.\n\n종수의 시작 위치, 미친 아두이노의 위치, 종수가 움직이려고 하는 방향이 주어진다. 입력으로 주어진 방향대로 종수가 움직였을 때, 보드의 상태를 구하는 프로그램을 작성하시오. 중간에 게임에서 지게된 경우에는 몇 번째 움직임에서 죽는지를 구한다.\n",
        "input_text": "첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 100)\n다음 R개 줄에는 C개의 문자가 주어지며, 보드의 상태이다. '.'는 빈 칸, 'R'은 미친 아두이노, 'I'는 종수의 위치를 나타낸다.\n마지막 줄에는 길이가 100을 넘지않는 문자열이 주어지며, 종수가 움직이려고 하는 방향이다. 5는 그 자리에 그대로 있는 것을 나타내고, 나머지는 아래와 같은 방향을 나타낸다.\n\n보드를 벗어나는 입력은 주어지지 않는다.\n",
        "output_text": "중간에 게임이 끝나는 경우에는 \"kraj X\"를 출력한다. X는 종수가 게임이 끝나기 전 까지 이동한 횟수이다. 그 외의 경우에는 보드의 상태를 입력과 같은 형식으로 출력한다.\n",
        "memory_median": 2308.0,
        "time_median": 12.0,
        "length_median": 2493.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "535": {
        "problem_text": "동아리방이 가지고 싶었던 병찬이는 LINK 사업단에 문의하여 N개의 방 중의 하나를 얻을 기회를 얻었다. 일자로 되어있는 건물에 N개의 방은 일직선상에 존재하며, 각 방에는 번호가 매겨져 있다. 맨 왼쪽 방의 번호는 1번이며, 순서대로 증가하여 맨 오른쪽 방의 번호가 N번이다. 각 방 사이에는 방을 구분하는 벽이 존재한다.\n물론 병찬이 외에도 많은 사람이 동아리방을 원한다. 다행히 방은 충분했기에 병찬이는 안심하고 있었지만…\n그때였다.\n빅-종빈빌런이 나타나 건물 벽을 허물기 시작한 것이다! 빅-종빈빌런은 다음과 같은 규칙으로 벽을 무너뜨린다.\n\nx < y 를 만족하는 두 방에 대해서 x번 방부터 y번 방 사이에 있는 모든 벽을 허문다.\n두 방 사이의 벽이 허물어지면 두 방은 하나의 방으로 합쳐진다.\n이미 허물어진 벽이 존재한다면 무시하고 다음 벽을 허문다.\n빅-종빈빌런은 건물이 무너지는 걸 원치 않기 때문에, 1번 방의 왼쪽 벽과 N번 방의 오른쪽 벽(즉, 바깥과 연결된 벽)은 허물지 않는다.\n\n동아리 방의 개수가 점점 줄어들자 병찬이는 초조해졌다. 이에 병찬이는 동아리방을 얻을 수 있는지에 대한 확률을 계산하기 위해 남는 동아리방의 수를 구하고 싶어 한다. 병찬이를 위해 빅-종빈빌런의 행동 횟수 M과 동방의 개수 N이 주어졌을 때, 남은 동아리방의 수를 구해주자.\n",
        "input_text": "첫 번째 줄에는 동아리방의 개수를 나타내는 양의 정수 N(2 ≤ N ≤ 100) 이 주어진다. 두 번째 줄에는 빅-종빈빌런의 행동 횟수를 나타내는 음이 아닌 정수 M(0 ≤ M ≤ 100) 이 주어진다. 세 번째 줄부터 M개의 줄에 걸쳐 빅-종빈빌런의 행동이 양의 정수 x, y(1 ≤ x < y ≤ N) 로 주어진다. 여기서 행동이란 x번 방부터 y번 방 사이의 벽을 무너뜨리는 것을 의미한다.\n빅-종빈빌런은 매우 허당이기 때문에 동일한 행동을 여러 번 할 수 있음에 유의하라.\n",
        "output_text": "빅-종빈빌런의 모든 행동이 끝난 후 남아있는 동방의 개수를 한 줄에 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 601.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "536": {
        "problem_text": "알고리즘 유치원 선생님인 영희는 간식시간이 되자 아이들에게 사탕을 나누어 주려고 하였다. 하지만 욕심 많고 제멋대로인 유치원 아이들은 차례대로 받으라는 선생님의 말을 무시한 채 마구잡이로 사탕을 집어 갔고 많은 사탕을 집어 간 아이가 있는가 하면 사탕을 거의 차지하지 못하고 우는 아이도 있었다. \n말로 타일러도 아이들이 말을 듣지 않자 영희는 한 가지 놀이를 제안했다. 일단 모든 아이들이 원으로 둘러 앉는다. 그리고 모든 아이들은 동시에 자기가 가지고 있는 사탕의 절반을 오른쪽 아이에게 준다. 만약 이 결과 홀수개의 사탕을 가지게 된 아이가 있을 경우 선생님이 한 개를 보충해 짝수로 만들어 주기로 했다. 흥미로워 보이는 이 놀이에 아이들은 참여 했고 이 과정을 몇 번 거치자 자연스럽게 모든 아이들이 같은 수의 사탕을 가지게 되어 소란은 종료되었다.\n자기가 가진 사탕의 반을 옆에 오른쪽에 앉은 아이에게 주는 과정과 선생님이 사탕을 보충해 주는 과정을 묶어서 1 순환이라고 할 때 몇 번의 순환을 거치면 모든 아이들이 같은 수의 사탕을 가지게 되는지 계산 해보자. 단, 처음부터 홀수개의 사탕을 가지고 있으면 선생님이 짝수로 보충을 먼저 해주며 이 경우 순환수에 들어가지 않는다. 선생님은 충분한 수의 사탕을 갖고 있다고 가정하자.\n",
        "input_text": "입력은 표준입력(standard input)을 통해 받아들인다. 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 각각의 테스트 케이스의 첫 줄에는 아이의 인원 N (1 ≤ N ≤ 10)이 주어지고 그 다음 줄에는 각 아이들이 초기에 가지고 있는 사탕의 개수 Ci ( 1 ≤ i ≤ N, 1 ≤ Ci ≤ 30)가 주어진다. 분배 시 C1의 오른쪽에는 C2가, C2의 오른쪽에는 C3가…… 같은 식으로 앉게 되며 CN의 오른쪽에는 C1이 앉게 된다.\n",
        "output_text": "출력은 표준출력(standard output)을 통하여 출력한다. 각 테스트 케이스에 대하여 모든 아이가 같은 개수의 사탕을 가질 때까지 몇 순환이 걸리는지 출력하시오.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 883.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "537": {
        "problem_text": "20XX년 도쿄에서 세계적인 스포츠 대회가 열린다. 프로그래밍 대회는 전세계적으로 인기있는 스포츠이고, 정식 종목으로 채택 될 가능성이 점점 높아지고 있다. 정식 종목으로 채택될 경기를 조직위원회에 문의해보니 다음과 같은 답변을 얻게 되었다.\n\n조직위원회는 정식 종목으로 채택할 후보 종목 N개를 재미있는 순서대로 나열한 리스트를 만들었다. 위에서부터 i번째에 적혀있는 경기는 i번째로 재미있는 경기이다. 이 경기를 i라고 했을 때, 개최하는데 필요한 비용은 Ai이다.\n조직위원회는 총 M명으로 구성되어 있고, 순서대로 1번 위원부터 M번 위원이다. 각각의 위원 j는 자신의 심사 기준 Bj를 가지고 있으며, 개최 비용이 Bj를 넘지 않는 경기 중 가장 재미있는 경기에 표를 던졌다.\n각 위원의 투표 기준에 해당하는 경기는 반드시 존재한다.\n가장 많은 표를 획득한 경기는 하나이다.\n\n경기 목록과 위원의 정보가 주어졌을 때, 가장 많은 표를 획득한 경기의 번호를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 경기의 수 N과 위원의 수 M이 주어진다. (1 ≤ N, M ≤ 1000)\n다음 N개의 줄에는 경기 i를 개최하는데 필요한 비용 Ai가 주어진다. (1 ≤ Ai ≤ 1000)\n다음 M개의 줄에는 위원 j의 심사 기준 Bj가 주어진다. (1 ≤ Bj ≤ 1000)\n",
        "output_text": "가장 많은 표를 획득한 경기의 번호를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 549.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "538": {
        "problem_text": "욱제는 매일 세계사에 한 획을 그을만한 심각한 비결정론적 문제에 직면한다. 그렇다. 바로 저녁메뉴를 고르는 것이다. 매일 반복되는 중대한 선택에 지친 욱제는 N일 동안의 저녁메뉴를 미리 골라두기로 했다.\n욱제는 N개의 중복되지 않는 메뉴들과 커다란 돌림판을 준비했다. 그러고는 돌림판을 N개의 칸으로 균일하게 나눈 뒤, N개의 메뉴를 각각 한 번씩 써넣었다. 하나의 칸에는 정확히 하나의 메뉴만 적히며, 하나의 메뉴는 정확히 하나의 칸에만 적힌다.\n'돌려돌려~ 돌림판~'\n\n돌림판을 돌리고 돌림판에 걸린 칸을 확인한다.\n걸린 칸에 스티커가 붙어있지 않다면, 스티커를 하나 붙인다.\n걸린 칸에 스티커가 붙어있다면, 식단표에 해당하는 메뉴를 적어넣고 그 칸을 제거한다. (스티커도 떼어낸다) 욱제의 돌림판은 특별해서 어떤 칸이 제거되면 다음부터는 그 칸에 절대로 멈추지 않는 마법이 걸려있다. (!)\n모든 칸이 제거될 때 까지 (0, 1, 2)을 반복한다.\n\n따라서 욱제는 2N번 돌림판을 돌리면 N일 동안의 메뉴를 모두 정할 수 있게 된다! 욱제가 돌림판을 돌린 결과가 순서대로 주어진다. 돌림판에는 최대 몇 개의 스티커가 붙어있을 수 있을까?\n",
        "input_text": "첫째 줄에 메뉴의 개수 N이 주어진다. (1 ≤ N ≤ 100,000)\n둘째 줄에 욱제가 뽑은 순서대로 해당 칸에 적힌 메뉴 번호가 주어진다. 메뉴는 1부터 N까지의 자연수로 주어진다. (1 ≤ 메뉴 ≤ N)\n",
        "output_text": "돌림판에 붙어있을 수 있는 스티커의 최대 개수를 출력한다.\n",
        "memory_median": 2288.0,
        "time_median": 32.0,
        "length_median": 385.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "539": {
        "problem_text": "가로 길이와 세로 길이가 모두 2L + 1인 2차원 격자판이 있다. 이 격자판의 각 칸을 그 좌표에 따라 (x, y)로 표현하기로 한다. 격자판의 가운데 칸의 좌표는 (0, 0)이고, 맨 왼쪽 맨 아래 칸의 좌표는 (−L, −L), 그리고 맨 오른쪽 맨 위 칸의 좌표는 (L, L)이다. x좌표는 왼쪽에서 오른쪽으로 갈수록, y좌표는 아래에서 위로 갈수록 증가한다.\n\n이 격자판의 (0, 0) 칸에 한 마리의 뱀이 자리를 잡고 있다. 처음에는 뱀의 크기가 격자판의 한 칸의 크기와 같으며, 뱀의 머리는 격자판의 오른쪽을 바라보고 있다. 이 뱀은 자신이 바라보고 있는 방향으로 1초에 한 칸씩 몸을 늘려나가며, 뱀의 머리는 그 방향의 칸으로 옮겨가게 된다. 예를 들어 위의 그림과 같이 L = 3인 경우를 생각해 보자. 뱀은 처음에 (0, 0)에 있으며, 그 크기는 격자판 한 칸 만큼이고, 뱀의 머리가 바라보고 있는 방향은 오른쪽이다. 1초가 지나고 나면 이 뱀은 몸을 한 칸 늘려서 (0, 0)과 (1, 0)의 두 칸을 차지하게 되며, 이때 (1, 0) 칸에 뱀의 머리가 놓이게 된다. 1초가 더 지나고 나면 (0, 0), (1, 0), (2, 0)의 세 칸을 차지하게 되고, 뱀의 머리는 (2, 0)에 놓이게 된다.\n이 뱀은 자신의 머리가 향하고 있는 방향을 일정한 규칙에 따라 시계방향, 혹은 반시계방향으로 90도 회전한다. 1번째 회전은 뱀이 출발한지 t1 초 후에 일어나며 i(i > 1)번째 회전은 i − 1번째 회전이 끝난 뒤 ti 초 후에 일어난다. 단, 뱀은 ti 칸 만큼 몸을 늘린 후에 머리를 회전하며 머리를 회전하는 데에는 시간이 소요되지 않는다고 가정한다.\n만일 뱀의 머리가 격자판 밖으로 나가게 되면, 혹은 뱀의 머리가 자신의 몸에 부딪히게 되면 이 뱀은 그 즉시 숨을 거두며 뱀은 숨을 거두기 직전까지 몸을 계속 늘려나간다.\n뱀이 머리를 회전하는 규칙, 즉 ti 와 그 방향에 대한 정보가 주어졌을 때, 뱀이 출발한지 몇 초 뒤에 숨을 거두는지를 알아내는 프로그램을 작성하라.\n",
        "input_text": "첫 번째 줄에 정수 L(1 ≤ L ≤ 108)이 주어진다. 두 번째 줄에는 머리의 방향을 몇 번 회전할 것인지를 나타내는 정수 N(0 ≤ N ≤ 103)이 주어진다. 다음 N 개의 줄에 뱀이 머리를 어떻게 회전하는지에 대한 정보가 주어진다. i(1 ≤ i ≤ N)번째 줄에 정수 ti(1 ≤ ti ≤ 2 · 108)와 diri 가 차례로 주어지며 diri 는 문자 L, 또는 R 중 하나이다. 뱀은 i = 1인 경우 출발, 그 외의 경우엔 i − 1번째 회전으로부터 ti 초 후에 diri 의 방향으로 머리를 회전하며, 만일 diri 가 L 이라면 왼쪽 (반시계방향)으로, R 이라면 오른쪽 (시계방향)으로 90도 회전한다.\n",
        "output_text": "첫 번째 줄에 답을 나타내는 값을 하나 출력한다. 이 값은 뱀이 출발한지 몇 초 후에 숨을 거두는지를 나타낸다.\n",
        "memory_median": 1996.0,
        "time_median": 0.0,
        "length_median": 3305.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "540": {
        "problem_text": "상근이는 은행에 가서 통장을 만들고 N원을 저금했다. 상근이는 이 통장에 입금이나 출금을 하지 않았다.\n은행은 통장을 만든지 1년이 지날때마다 상근이의 통장에 저금되어 있는 돈의 B%만큼을 이자로 적립해준다.\n상근이는 몇 년이 지나면 통장에 저금되어 있는 돈이 M원을 넘을지 궁금해졌다. \nN,M,B가 주어졌을 때, 몇 년이 지나야 하는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트는 한 줄로 이루어져 있고, N, B, M이 주어진다. M은 항상 N보다 크다. N과 M은 항상 백만보다 작거나 같은 수이고, 음수 또는 0이 아니다. B는 50보다 작거나 같으며, 양수이다. 모든 수는 소수점 둘째자리까지 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해서, M원을 넘게 만들려면 몇 년이 걸리는지 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 12.0,
        "length_median": 284.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "541": {
        "problem_text": "W대학교 미술대학 조소과에서는 지루한 목판화 작업을 하는 학생들을 돕기 위해 판화 기계를 제작하였다.\n기계는 로봇 팔이 쥔 조각도를 상하좌우 네 방향으로 움직일 수 있는 구조로서, 조각도 아래에 목판을 놓으면 그 위에 선들을 자동으로 그어주는 기능을 가지고 있다.\n목판에는 N2개의 점들이 일정한 간격으로 N행 N열의 격자모양을 이루며 찍혀있다. 처음 로봇의 조각도를 올려놓는 위치는 항상 이 점들 중 맨 왼쪽 맨 위의 꼭짓점이다.\n로봇 팔을 움직이는 명령의 순서가 주어졌을 때, 목판 위에 패인 조각도의 혼적을 출력하는 프로그램을 작성하시오.\n판화 기계는 작동 도중 로봇 팔이 격자 바깥으로 나가도록 하는 움직임 명령을 만나면, 무시하고 그 다음 명령을 진행한다.\n",
        "input_text": "첫째 줄에 목판의 크기 N (2 ≤ N ≤ 10)이 주어진다. 행 열의 점들이 찍혀 있다는 의미이다. 둘째 줄에 로봇팔의 움직임이 한 줄로 공백 없이 입력된다. 위쪽으로 이동은 'U', 아래쪽으로 이동은 'D', 왼쪽으로 이동은 'L', 오른쪽으로 이동은 'R'로 표시된다. 로봇팔의 움직임을 나타내는 이 문자열의 길이는 최대 250이다.\n",
        "output_text": "로봇팔이 지나지 않은 점은 '.'으로, 로봇팔이 수직 방향으로만 지난 점은 '|'으로, 로봇팔이 수평 방향으로만 지난 점은 '-'으로, 수직과 수평 방향 모두로 지난 점은 '+'로 표기하도록 한다. 네 문자의 ASCII 코드는 각각 46, 124, 45, 43이다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1305.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "542": {
        "problem_text": "시험이 끝난 준서는 친구들과 술을 마시고 있다.\n\n두~~부 두부 두부 으쌰 으쌰 으쌰 두~~부 두부 두부 으쌰 으쌰 으쌰\n\n어디선가 어깨를 주체할 수 없는 신명 나는 노랫소리가 들려오기 시작한다. 친구들은 홀린 듯 어깨춤을 추며 노래를 따라부르기 시작한다.\n준서를 포함하여 $N$명의 사람이 함께 노래를 부르며 게임을 진행하고 있다. 이름처럼 여러 글자를 말하기 힘들어진 사람들은 $1$~$N$번으로 서로를 구분한다. 화목한 친구들은 반시계방향으로 번호가 증가하도록 둥글게 앉아있다.\r\n이때 노래를 부르던 $M$번 사람이 두부 $K$모를 외쳤다.\r\n또또 나만 모르는 술 게임을 하는 걸 본 준서는 옆자리 준우 형에게 몰래 게임의 룰을 물어보았다.\n\n자신의 차례인 사람은 하나의 정수 $K$를 외친다.\n번호를 부른 사람이 기준인 $3$모가 된다.\n반시계방향으로 옆 사람의 모 수는 $1$이 증가하고, 시계방향으로 $1$이 감소한다.\n모 수가 $K$인 사람이 다음 차례가 되어 게임을 반복한다.\n만약 자신의 차례가 아닌데 $K$를 외치거나, 자신의 차례에 $K$를 부르지 않으면 술을 마셔야 한다.\n\n설명을 들었지만 술에 취한 준서는 너무나도 어지러워 다음 차례가 누구인지 도저히 모르겠다. 준서가 마시면서 배우는 술 게임에 당하지 않도록 다음 차례인 사람의 번호를 알려주자!\n",
        "input_text": "첫 번째 줄에 게임을 하는 사람의 수 $N$ ($1 \\le N \\le 100\\,000$), 현재 차례인 사람의 번호 $M$ ($1 \\le M \\le N$), 부른 두부의 모 수를 나타내는 정수 $K$ ($-100\\,000 \\le K \\le 100\\,000$)가 주어진다.\n",
        "output_text": "첫째 줄에 다음 차례인 사람의 번호를 출력하라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 302.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "543": {
        "problem_text": "JOI 君は明日から新たにソーシャルゲームを始めることにした．\nこのソーシャルゲームでは，1 日につき 1 回までログインすることができ，ログインするたびに A 枚のコインが得られる．\nまた，月曜日から日曜日まで 7 日連続でログインすると，そのたびに，追加で B 枚のコインが得られる．\nこれ以外にコインがもらえることはない．\n明日は月曜日である．JOI 君が少なくとも C 枚のコインを得るためにログインしなければならない回数の最小値を求めよ．\n",
        "input_text": "入力は以下の形式で標準入力から与えられる．\n\r\nA B C\n",
        "output_text": "JOI 君が少なくとも C 枚のコインを得るためにログインしなければならない回数の最小値を出力せよ．\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 281.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "544": {
        "problem_text": "To pass the time, Bessie the cow and her friend Elsie like to play a version of a game they saw at the county fair.\nTo start, Bessie puts three inverted shells on a table and places a small round pebble under one of them (at least she hopes it is a pebble -- she found it on the ground in one of the pastures). Bessie then proceeds to swap pairs of shells, while Elsie tries to guess the location of the pebble.\nThe standard version of the game the cows saw being played at the county fair allowed the player to see the initial location of the pebble, and then required guessing its final location after all the swaps were complete.\nHowever, the cows like to play a version where Elsie does not know the initial location of the pebble, and where she can guess the pebble location after every swap. Bessie, knowing the right answer, gives Elsie a score at the end equal to the number of correct guesses she made.\nGiven the swaps and the guesses, but not the initial pebble location, please determine the highest possible score Elsie could have earned.\n",
        "input_text": "The first line of the input file contains an integer $N$ giving the number of swaps ($1 \\leq N \\leq 100$). Each of the next $N$ lines describes a step of the game and contains three integers $a$, $b$, and $g$, indicating that shells $a$ and $b$ were swapped by Bessie, and then Elsie guessed shell $g$ after the swap was made. All three of these integers are either 1, 2, or 3, and $a \\neq b$.\n",
        "output_text": "Please output the maximum number of points Elsie could have earned.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 607.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "545": {
        "problem_text": "모노미노도미노는 아래와 같이 생긴 보드에서 진행되는 게임이다. 보드는 빨간색 보드, 파란색 보드, 초록색 보드가 그림과 같이 붙어있는 형태이다. 게임에서 사용하는 좌표 (x, y)에서 x는 행, y는 열을 의미한다. 빨간색, 파란색, 초록색 보드가 사용하는 좌표는 그 색으로 그림에 적혀있다.\n\n<그림 1> 모노미노도미노 게임 보드\n이 게임에서 사용하는 블록은 타일 하나 또는 두 개가 가로 또는 세로로 붙어있는 형태이다. 아래와 같이 세 종류가 있으며, 왼쪽부터 순서대로 크기가 1×1, 1×2, 2×1 이다.\n\n<그림 2> 모노미노도미노 게임에서 사용하는 블록\n블록을 놓을 위치를 빨간색 보드에서 선택하면, 그 위치부터 초록색 보드로 블록이 이동하고, 파란색 보드로 블록이 이동한다. 블록의 이동은 다른 블록을 만나거나 보드의 경계를 만나기 전까지 계속해서 이동한다. 예를 들어, 크기가 1×1인 블록을 (1, 1)에 놓으면, 보드의 상태는 <그림 3>과 같이 변한다.\n\n<그림 3>\n여기서 크기가 1×2인 블록을 (3, 0)과 (3, 1)에 놓으면 <그림 4>와 같이 보드의 상태가 변한다.\n\n<그림 4>\n다시 이 상태에서 크기가 2×1인 블록을 (2, 2), (3, 2)와 (2, 3), (3, 3)에 놓으면 <그림 5>와 같이 변한다.\n\n<그림 5>\n초록색 보드의 4번 행은 모든 칸이 타일로 가득 차있다. 이렇게 초록색 보드에서 어떤 행이 타일로 가득 차 있다면, 그 행의 타일은 모두 사라진다. 사라진 이후에는 초록색 보드에서 각 블록이 다른 블록을 만나거나 경계를 만나기 전까지 아래로 이동한다. 파란색의 경우는 열이 타일로 가득 차 있으면, 그 열의 타일이 모두 사라지며, 사라진 이후에는 파란색 보드에서 각 블록이 다른 블록을 만나거나 경계를 만나기 전까지 오른쪽으로 이동한다. 이렇게 한 행이나 열이 타일로 가득 차서 사라지면 1점을 획득한다. 점수는 사라진 행 또는 열의 수와 같다. 만약, 두 개의 행이 사라지면 2점을 획득하게 되고, 한 행과 한 열이 사라져도 2점을 획득하게 된다. 위의 보드는 아래와 같이 변하고, 1점을 얻는다.\n\n<그림 6>\n여기서 크기가 2×1인 블록을 (1, 3), (2, 3)에 놓으면 보드는 <그림 7>과 같이 변한다.\n\n<그림 7>\n초록색 보드의 0, 1번 행과 파란색 보드의 0, 1번 열은 그림에는 연한색으로 표현되어 있는 특별한 칸이다. 초록색 보드의 0, 1번 행에 블록이 있으면, 블록이 있는 행의 수만큼 아래 행에 있는 타일이 사라지고, 초록색 보드의 모든 블록이 아래로 경계를 만나기 전까지 이동하고, 파란색 보드의 0, 1번 열에 블록이 있으면, 블록이 있는 열의 수만큼 오른쪽 열에 있는 타일이 사라지고, 파란색 보드의 모든 블록이 오른쪽으로 경계를 만나기 전까지 이동하게 된다. 위의 그림은 파란색 보드의 1번 열에 블록이 있기 때문에, 5번 열에 있는 블록이 모두 사라지고, 파란색 보드의 모든 블록이 오른쪽으로 한 칸 이동하게 된다. 따라서, 보드는 <그림 8>과 같이 변하게 된다.\n\n<그림 8>\n위의 보드에서 1×2인 블록을 (0, 0), (0, 1)에 놓으면 <그림 9>와 같다.\n\n<그림 9>\n여기서 크기가 2×1인 블록을 (2, 0), (3, 0)에 놓으면 <그림 10>과 같이 변한다. 파란색 보드는 1번 열에 블록이 생겨서 오른쪽으로 한 칸씩 이동한 상태이다.\n\n<그림 10>\n크기가 2×1인 블록을 (1, 2), (2, 2)에 놓으면, <그림 11>과 같이 변한다.\n\n<그림 11>\n파란색 보드는 1번 열에 블록이 있기 때문에, 5번 열의 타일이 사라지고 모든 블록이 오른쪽으로 한 칸씩 이동하게 된다. 초록색 보드는 4번 행의 모든 칸에 타일이 있기 때문에, 1점을 얻으면서, 4번 행의 모든 타일이 사라진다.\n\n<그림 12>\n<그림 12>는 <그림 11>의 상태에서 파란색 보드는 모든 블록이 오른쪽으로 한 칸 이동했고, 초록색 보드의 4번 행이 모두 사라진 상태이다. 이제, 초록색 보드에서 나머지 블록이 아래로 경계나 다른 블록을 만나기 전까지 내려와야 한다. 여기서 다시 <그림 13>과 같이 5번 행의 모든 칸에 타일이 가득차게 된다.\n\n<그림 13>\n블록의 이동 때문에, 다시 행이나 열이 타일로 가득차는 경우가 또 발생할 수도 있다. 이 경우에도 1점을 얻고, 그 행이나 열의 모든 타일을 제거하고 다시 나머지 블록을 이동하면 된다. 따라서, <그림 11>의 최종 결과는 <그림 14>가 된다.\n\n<그림 14>\n행이나 열이 타일로 가득찬 경우와 연한 칸에 블록이 있는 경우가 동시에 발생할 수 있다. 이 경우에는 행이나 열이 타일로 가득 찬 경우가 없을 때까지 점수를 획득하는 과정이 모두 진행된 후, 연한 칸에 블록이 있는 경우를 처리해야 한다.\n블록은 보드에 놓인 이후에 다른 블록과 합쳐지지 않는다. 나누어지는 경우는 행이나 열이 타일로 가득찬 경우에 발생할 수 있다. 초록색 보드에서는 2×1 블록에서 일부가 사라져서 1×1 블록이 될 수 있고, 파란색 보드에서는 1×2 블록에서 일부가 사라져서 1×1 블록이 될 수 있다.\n블록을 놓은 위치가 순서대로 주어졌을 때, 얻은 점수와 초록색 보드와 파란색 보드에 타일이 있는 칸의 개수를 모두 구해보자.\n",
        "input_text": "첫째 줄에 블록을 놓은 횟수 N(1 ≤ N ≤ 10,000)이 주어진다.\n둘째 줄부터 N개의 줄에 블록을 놓은 정보가 한 줄에 하나씩 순서대로 주어지며, t x y와 같은 형태이다.\n\nt = 1: 크기가 1×1인 블록을 (x, y)에 놓은 경우\nt = 2: 크기가 1×2인 블록을 (x, y), (x, y+1)에 놓은 경우\nt = 3: 크기가 2×1인 블록을 (x, y), (x+1, y)에 놓은 경우\n\n블록이 차지하는 칸이 빨간색 칸의 경계를 넘어가는 경우는 입력으로 주어지지 않는다.\n",
        "output_text": "첫째 줄에 블록을 모두 놓았을 때 얻은 점수를 출력한다.\n둘째 줄에는 파란색 보드와 초록색 보드에서 타일이 들어있는 칸의 개수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 8.0,
        "length_median": 4642.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "546": {
        "problem_text": "해빈이는 로봇을 좋아한다. 로봇을 가지고 놀던 해빈이는 로봇에게 계속해서 명령을 내려 움직이는 대신 이동할 방향을 미리 지정하여 로봇이 알아서 움직이도록 하였다.  이 로봇은 다음과 같은 규칙을 가지고 움직인다.\n\n로봇은 사용자가 지정한 방향을 일직선으로 움직인다.\n이동 중 벽이나 방문한 지역, 장애물을 만날 경우 로봇은 사용자가 지정한 다음 방향으로 움직인다.\n사용자가 지정한 다음 방향이 없다면 맨 처음 방향으로 돌아가서 위의 과정을 반복한다.\n로봇이 움직일 수 없을 경우 동작을 멈춘다. \n\n\n\n\n\n* * *\nx 0 *\n* * *\n<초기 상태>\n\n\n* 1 *\nx 0 *\n* * *\n<1번 째 이동>\n\n\n2 1 *\nx 0 *\n* * *\n<2번 째 이동>\n\n\n방 크기가 3* 3이고\n장애물이 (1, 0)에 있으며\n시작 위치는 (1,1)\n해빈이가 지정한 방향이 (상, 하, 좌, 우) 일 때,\n로봇의 마지막 위치는 (0, 0)이다.\n\n\n\n\n2 번째 이동이 끝난 후, 로봇은 움직일 수 없으므로 동작을 멈춘다.\n로봇은 (1, 1) → (0, 1) → (0, 0)로 이동하였다.\n\n\n\n\n입력으로 방의 크기와 장애물의 개수, 각 장애물들의 위치, 로봇의 시작 위치, 이동 방향의 순서가 주어졌을 때 로봇이 멈추는 위치를 출력하시오. 위치 (0, 0)은 왼쪽 위를 가리키며 방의 크기가 R * C일 때 오른쪽 아래 위치는 (R - 1, C - 1)이 된다. (R은 세로의 크기를 C은 가로의 크기를 말한다.)\n",
        "input_text": "첫 번째 줄에는 방의 크기 R, C(3 ≤ R, C ≤ 1,000)가 입력된다. 두 번째 줄에는 장애물의 개수 k(0 ≤ k ≤ 1,000)가 입력된다. 다음 k개의 줄에는 각 장애물 위치 br(0 ≤ br ≤ R – 1), bc(0 ≤ bc ≤ C - 1)가 주어진다. 그 다음 순서대로 로봇의 시작 위치 sr(0 ≤ sr ≤ R – 1), sc(0 ≤ sc ≤ C - 1)와 이동 방향의 순서(총 4개가 입력되는데 1은 위 방향, 2은 아래 방향, 3은 왼쪽 방향, 4는 오른쪽 방향을 나타낸다)가 한 줄씩 입력된다. 로봇의 시작위치에 장애물이 있는 경우는 없다.\n",
        "output_text": "로봇의 마지막 위치 r, c를 출력한다.\n",
        "memory_median": 5056.0,
        "time_median": 0.0,
        "length_median": 1107.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "547": {
        "problem_text": "틱택토(Tic-Tac-Toe)는 오목과 아주 유사한 형태의 보드게임이다.\n\n게임 방법은 아래와 같다.\n\n종이 위에 가로줄 2줄 세로줄 2줄을 그린다.\n이렇게 생긴 9칸 위의 빈칸에 플레이어 1은 O, 플레이어 2는 X를 번갈아가며 그린다.\n먼저 O 또는 X를 3개가 직선으로 이어지게 하면 승리하고 게임이 끝난다.\n이어지는 직선이 없고, 더는 그릴 빈칸이 없으면 무승부로 게임이 종료된다.\n\n남녀노소 모두 즐길 수 있는 아주 쉬운 게임이지만, 중간에 끝났는지 눈치를 못 채고 계속하는 경우가 있다. 그래서 당신은 제3의 공정하고 자비 없는 냉정한 심판을 두고 싶었다.\n각 플레이어가 교대로 O 또는 X를 그린 위치가 입력되면 누가 언제 이기는지를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 게임을 먼저 시작할 플레이어의 번호가 입력된다. 플레이어의 번호는 1 또는 2이다.\n다음 9개의 줄에 게임이 끝날 때까지 번갈아가며 어느 위치에 그렸는지 좌표가 입력된다. 좌표는 가로 행, 세로 열의 순으로 입력된다. 가장 왼쪽 위는 (1, 1), 가장 오른쪽 아래는 (3, 3)이다.\n이미 입력된 좌표가 주어지는 경우는 없으며, 항상 게임이 끝나는 입력만 주어진다.\n",
        "output_text": "승자가 결정되는 즉시 이긴 플레이어의 번호를 출력한다. 플레이어의 번호는 1 또는 2이다. 무승부라면 0을 출력한다.\n",
        "memory_median": 2018.0,
        "time_median": 0.0,
        "length_median": 1021.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "548": {
        "problem_text": "시내 주차장은 1부터 N까지 번호가 매겨진 N개의 주차 공간을 가지고 있다. 이 주차장은 매일 아침 모든 주차 공간이 비어 있는 상태에서 영업을 시작하며, 하룻동안 다음과 같은 방식으로 운영된다. 차가 주차장에 도착하면, 주차장 관리인이 비어있는 주차 공간이 있는지를 검사한다. 만일 비어있는 공간이 없으면, 차량을 빈 공간이 생길 때까지 입구에서 기다리게 한다. 만일 빈 주차 공간이 하나만 있거나 또는 빈 주차 공간이 없다가 한 대의 차량이 주차장을 떠나면 곧바로 그 장소에 주차를 하게 한다. 만일 빈 주차 공간이 여러 곳이 있으면, 그 중 번호가 가장 작은 주차 공간에 주차하도록 한다. 만일 주차장에 여러 대의 차량이 도착하면, 일단 도착한 순서대로 입구의 대기장소에서 줄을 서서 기다려야 한다. 대기장소는 큐(queue)와 같이, 먼저 대기한 차량부터 주차한다.\n주차료는 주차한 시간이 아닌 차량의 무게에 비례하는 방식으로 책정된다. 주차료는 차랑의 무게에다 주차 공간마다 따로 책정된 단위 무게당 요금을 곱한 가격이다.\n주차장 관리원은 오늘 M대의 차량이 주차장을 이용할 것이라는 것을 알고 있다. 또한, 차량들이 들어오고 나가는 순서도 알고 있다.\n주차 공간별 요금과 차량들의 무게와 출입 순서가 주어질 때, 오늘 하룻동안 주차장이 벌어들일 총 수입을 계산하는 프로그램을 작성하라.\n",
        "input_text": "반드시 표준 입력으로부터 다음의 데이터를 읽어야 한다.\n\n첫 번째 줄에는 정수 N과 M이 빈칸을 사이에 두고 주어진다.\n그 다음 N개의 줄에는 주차 공간들의 단위 무게당 요금을 나타내는 정수들이 주어진다. 그 중 s번째 줄에는 주차 공간 s의 단위 무게당 요금 Rs가 들어있다.\n그 다음 M개의 줄에는 차량들의 무게를 나타내는 정수들이 주어진다. 차량들은 1 부터 M 까지 번호로 구분되고, 이 번호는 출입 순서와는 상관없다. 이 M개의 줄 중 k번째 줄에는 차량 k의 무게를 나타내는 정수 Wk가 들어있다.\n그 다음 2*M 개의 줄에는 차량들의 주차장 출입 순서를 나타내는 정수들이 한 줄에 하나씩 주어진다. 양의 정수 i는 차량 i가 주차장에 들어오는 것을 의미하고, 음의 정수 -i는 차량 i가 주차장에서 나가는 것을 의미한다. 주차장에 들어오지 않은 차량이 주차장에서 나가는 경우는 없다. 1 번부터 M 번까지 모든 차량은 정확하게 한 번씩 주차장에 들어오고, 한 번씩 주차장에서 나간다. 또한 입구에서 대기 중인 차량이 주차를 하지 못하고 나가는 경우는 없다.\n\n\n1 ≤ N ≤ 100 주차 공간의 수\n1 ≤ M ≤ 2,000 차량의 수\n1 ≤ Rs ≤ 100 주차 공간 s의 단위 무게당 요금\n1 ≤ Wk ≤ 10,000 차량 k의 무게\n\n",
        "output_text": "출력은 반드시 표준 출력으로 하여야 하며, 하나의 줄에 한 개의 정수를 출력한다. 이 정수는 오늘 하룻동안 주차장이 벌어들인 총 수입이다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1191.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "549": {
        "problem_text": "오늘도 서준이는 선택 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\nN개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 선택 정렬로 배열 A를 오름차순 정렬할 경우 K 번 교환이 발생한 직후의 배열 A를 출력해 보자.\n크기가 N인 배열에 대한 선택 정렬 의사 코드는 다음과 같다.\n\r\nselection_sort(A[1..N]) { # A[1..N]을 오름차순 정렬한다.\r\n    for last <- N downto 2 {\r\n        A[1..last]중 가장 큰 수 A[i]를 찾는다\r\n        if (last != i) then A[last] <-> A[i]  # last와 i가 서로 다르면 A[last]와 A[i]를 교환\r\n    }\r\n}\n",
        "input_text": "첫째 줄에 배열 A의 크기 N(5 ≤ N ≤ 10,000), 교환 횟수 K(1 ≤ K ≤ N)가 주어진다.\n다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)\n",
        "output_text": " K 번 교환이 발생한 직후의 배열 A를 한 줄에 출력한다. 교환 횟수가 K 보다 작으면 -1을 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 44.0,
        "length_median": 739.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "550": {
        "problem_text": "\n디지털시계는 일반적으로 시각을 “hh:mm:ss”의 형태로 표현한다. hh는 00 이상 23 이하의 값을, mm과 ss는 00 이상 59 이하의 값을 가질 수 있다. 이러한 형태의 시각에서 콜론(“:”)을 제거하면 “hhmmss”라는 정수를 얻을 수 있는데, 이러한 정수를 시계 정수라고 한다. 예를 들어, 오후 5시 5분 13초, 즉 17:05:13의 시계 정수는 170513이고, 오전 0시 7분 37초, 즉 00:07:37의 시계 정수는 737이다.\n이 문제에서 시간이란 시각의 구간을 나타낸다. 예를 들어 [00:59:58, 01:01:24]와 같이 시작하는 시각과 끝나는 시각으로 이루어진 구간을 우리는 시간이라고 부른다. (이러한 구간에는 시작하는 시간과 끝나는 시간도 포함된다)\n이렇게 시간이 구간으로 주어지면, 그 구간에 포함되는 시계 정수들을 나열할 수 있다. 예를 들어 [00:59:58, 01:01:24]에 포함되는 시계 정수는 5958, 5959, 다음으로 10000 이상 10059 이하, 마지막으로 10100 이상 10124 이하로 총 87개가 된다. 우리는 이처럼 특정한 시간에 포함되는 시계 정수들 중, 3의 배수인 것이 몇 개나 있는지를 알고 싶다.\n시간은 자정을 포함할 수도 있다. 즉 [23:59:03, 00:01:24]처럼 시작하는 시각의 시계 정수(235903)가 끝나는 시각의 시계 정수(124)보다 클 수도 있다. 물론 이 경우 이 구간에 포함되는 시계 정수는 235903 이상 235959 이하, 0 이상 59 이하, 100 이상 124 이하가 된다. 모든 구간이 포함하는 시간은 만 하루, 즉 24시간보다는 항상 작다고 가정해도 좋다.\n시간이 시작하는 시각과 끝나는 시각으로 주어졌을 때, 이 구간에 포함되는 시계 정수들 중, 3의 배수인 것의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "세 개의 입력이 주어진다. 첫째 줄부터 세 줄에 걸쳐 시작하는 시각과 끝나는 시각이 “hh:mm:ss”의 형태로 주어진다. 시작하는 시각과 끝나는 시각 사이에는 빈 칸이 하나 있어서, 한 줄마다 (빈 칸을 포함하여) 총 17글자가 입력으로 주어진다. 시작하는 시각과 끝나는 시각은 항상 다르다.\n",
        "output_text": "첫째 줄부터 세 개의 줄에 걸쳐 입력된 구간에 포함되는 시계 정수들 중, 3의 배수인 것의 개수를 출력한다. 입력된 순서대로 각 줄에 한 개씩 차례로 출력하면 된다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 976.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "551": {
        "problem_text": "용태와 유진이가 재미있는 젓가락 게임을 하려고 한다. 게임의 진행은 다음과 같다.\n\n용태가 한 손에 펴고 시작할 손가락의 개수 $A(1 \\le A \\le 4)$를 정한다.\n유진이가 한 손에 펴고 시작할 손가락의 개수 $B(1 \\le B \\le 4)$를 정한다.\n용태부터 시작해서 서로 번갈아가면서 상대를 공격해서 손가락을 더 펴게 한다. 만약 $x$개의 손가락을 펴고 있는 사람이 상대를 공격하면, 상대는 $x$개의 손가락을 더 펴야 한다.\n다섯 손가락 이상을 펴야 하는 사람이 패배한다. 게임은 한 손만을 사용해 진행하는 것에 유의한다.\n\n예를 들어 용태가 $1$개, 유진이가 $2$개의 손가락을 편 채로 게임을 시작한다면 게임의 진행은 다음과 같다.\n\n$(1, 2) → (1, 3)$ 용태가 선공이므로 유진이를 공격하면 유진이는 $1$개의 손가락을 더 편다.\n$(1, 3) → (4, 3)$ 유진이가 용태를 공격하면 용태는 $3$개의 손가락을 더 편다.\n$(4, 3) → (4, 7)$ 용태가 유진이를 공격하면 유진이는 $7$개의 손가락을 펴야 하고, 유진이가 패배한다.\n\n용태와 유진이가 한 손에 펴고 시작하는 손가락의 개수가 주어졌을 때, 그대로 게임을 플레이한다면 누가 이기게 될까?\n",
        "input_text": "첫째 줄에 용태가 한 손에 펴고 시작할 손가락의 개수 $A(1 \\le A \\le 4)$와 유진이가 한 손에 펴고 시작할 손가락의 개수 $B(1 \\le B \\le 4)$가 주어진다.\n",
        "output_text": "용태와 유진이가 게임을 플레이했을 때 용태가 이기게 된다면 yt 를, 유진이가 이긴다면 yj 를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 339.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "552": {
        "problem_text": "세계적으로 유명한 커플 상근이와 나예는 2016년 4월 3일이 사귀기 시작한지 200일이 되는 날이었다. 상근이는 그 날이 200일인줄 몰라서 나예한테 혼났다. 이런 일이 다시는 없도록 하기 위해서 기념하려고 하는 날 수가 양의 정수로 주어지면 기념일 날짜를 출력하는 프로그램을 작성하여 다시는 혼나는 일이 없도록 하려 한다. 이 커플의 사귀기 시작한 날짜는 2015년 9월 17일이다. 하지만, 알 수 없는 이유에 의해서 문제를 풀 때는 사귀기 시작한 날짜를 2014년 4월 2일로 처리해야 한다.\n2월이 28일까지 있는 년을 평년이라 하고, 29일까지 있는 년을 윤년이라 한다. 윤년은 연도가 4의 배수이면서, 100의 배수가 아닐 때 또는 400의 배수일 때이다. 예를들어 1900년은 4의 배수이지만 100의 배수이기 때문에 윤년이 아니다. 하지만 2000년은 400의 배수이기 때문에 윤년이다.\n",
        "input_text": "첫째 줄에 기념하려는 날이 양의 정수 N (1 ≤ N ≤ 10,000)으로 주어진다.\n",
        "output_text": "첫째 줄에 기념일의 날짜를 YYYY-MM-DD 의 형식으로 출력한다.\n",
        "memory_median": 1536.0,
        "time_median": 0.0,
        "length_median": 788.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "553": {
        "problem_text": "수많은 토너먼트를 거쳐 최종 플레이어 \\(N\\)명이 남아있다. 각 플레이어는 \\(M\\)장씩의 숫자가 적힌 카드를 가지고 있으며, 이들은 매 턴 자신이 가진 카드 중 가장 큰 카드를 두고 비교를 하는데, 그 카드들 중 가장 큰 수를 가진 플레이어가 1점을 획득한다. 그 턴에 사용된 카드는 버리기로 한다. 가장 큰 수를 가진 플레이어는 여러 명일 수 있다. \\(M\\)번의 경기 후 가장 많은 점수를 획득한 플레이어는 몇 번 플레이어인가?\n",
        "input_text": "입력의 첫 줄에 플레이어의 수 \\(N\\)과 가진 카드 수 \\(M\\)이 입력 된다. \\(( 2 \\le N \\le100, 1 \\le M \\le 100 )\\) 그 다음 \\(N\\)줄에 걸쳐 각 플레이어가 들고 있는 카드에 적힌 숫자들이 입력된다. \\(( 1 \\le\\) 카드에 적힌 숫자 \\(\\le 100 )\\)\n",
        "output_text": "최종 승자의 번호를 출력한다. 플레이어의 번호는 1번부터 \\(N\\)번까지 입력받은 순서로 주어진다고 가정한다. 가장 많은 점수를 획득한 플레이어가 여러 명일 경우, 빈칸을 사이에 두고 플레이어들의 번호를 오름차순으로 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 0.0,
        "length_median": 855.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "554": {
        "problem_text": "선영이는 다가오는 COCI에 사용할 데이터를 만드느라 삼일동안 깨어있었다. 더 이상 데이터를 만들 수 없는 상황에 이르렀고, 심지어 선영이는 신경쇠약에 걸려 아무것도 제대로 보지 못하는 상황이 되었다.\n선영이가 무엇인가를 읽다가 눈을 한 번 깜박하면 단어의 뒷 부분 절반이 앞 부분과 섞이게 된다. (길이가 홀수인 경우에는 뒷 부분의 길이가 짧다) 섞이는 방법은 아래와 같다.\n\n마지막 글자가 첫 번째 글자와 두 번째 글자 사이로 이동한다.\n뒤에서 두 번째 글자가 두 번째 글자와 세 번째 글자 사이로 이동한다.\n뒤에서 k번째 글자는 앞에서부터 k번째와 k+1번째 글자 사이로 이동한다.\n\n예를 들어, 선영이가 \"abcdef\"란 단어를 보다가 눈을 한 번 깜박이면, 단어가 \"afbecd\"가 된다. 여기서 한 번 더 깜박이면 \"adfcbe\"가 된다.\n선영이는 한 단어를 쓰고난 이후에 눈을 X번 깜박였고, 처음에 작성한 단어가 무엇인지 궁금해졌다. X와 눈을 X번 깜박인 후에 선영이가 보고 있는 단어가 주어졌을 때, 원래 단어가 무엇이었는지 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 X(1 ≤ X ≤ 1,000,000,000) 가 주어지고, 둘째 줄에 X번 깜박인 후의 단어가 주어진다. 단어는 알파벳 소문자로만 이루어져 있고, 길이는 구간 [3,1000]에 포함된다.\n",
        "output_text": "첫째 줄에 X번 깜박이기 전 단어를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 4.0,
        "length_median": 829.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "555": {
        "problem_text": "2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다. 이 링크를 누르면 게임을 해볼 수 있다.\n이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)\n\n\n\n\n\n\n\n\n\n\n<그림 1>\n<그림 2>\n<그림 3>\n\n\n\n<그림 1>의 경우에서 위로 블록을 이동시키면 <그림 2>의 상태가 된다. 여기서, 왼쪽으로 블록을 이동시키면 <그림 3>의 상태가 된다.\n\n\n\n\n\n\n\n\n\n\n\n<그림 4>\n<그림 5>\n<그림 6>\n<그림 7>\n\n\n\n<그림 4>의 상태에서 블록을 오른쪽으로 이동시키면 <그림 5>가 되고, 여기서 다시 위로 블록을 이동시키면 <그림 6>이 된다. 여기서 오른쪽으로 블록을 이동시켜 <그림 7>을 만들 수 있다.\n\n\n\n\n\n\n\n\n\n<그림 8>\n<그림 9>\n\n\n\n<그림 8>의 상태에서 왼쪽으로 블록을 옮기면 어떻게 될까? 2가 충돌하기 때문에, 4로 합쳐지게 되고 <그림 9>의 상태가 된다.\n\n\n\n\n\n\n\n\n\n\n\n<그림 10>\n<그림 11>\n<그림 12>\n<그림 13>\n\n\n\n<그림 10>에서 위로 블록을 이동시키면 <그림 11>의 상태가 된다. \n<그림 12>의 경우에 위로 블록을 이동시키면 <그림 13>의 상태가 되는데, 그 이유는 한 번의 이동에서 이미 합쳐진 블록은 또 합쳐질 수 없기 때문이다.\n\n\n\n\n\n\n\n\n\n<그림 14>\n<그림 15>\n\n\n\n마지막으로, 똑같은 수가 세 개가 있는 경우에는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 예를 들어, 위로 이동시키는 경우에는 위쪽에 있는 블록이 먼저 합쳐지게 된다. <그림 14>의 경우에 위로 이동하면 <그림 15>를 만든다.\n이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다. 보드의 크기와 보드판의 블록 상태가 주어졌을 때, 최대 10번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다. 0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 블록은 적어도 하나 주어진다.\n",
        "output_text": "최대 10번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 716.0,
        "length_median": 3614.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            1,
            0
        ]
    },
    "556": {
        "problem_text": "우주 어딘가에는 시간을 셈으로써 시간이 흐르도록 만들어 주는 존재들이 있습니다. 영겁의 시간을 살아온 그들은 더 재미있게 시간을 세기 위해 시간을 세는 게임을 만들어 냈답니다. 그게 바로 《크레이지 타임》이죠!\n《크레이지 타임》을 시작하기 전에, 시간 카드를 잘 섞은 후 플레이어들이 최대한 비슷한 수량의 카드를 받도록 나눠 가집니다. 시간 카드는 앞면과 뒷면이 구분된 카드로, 앞면에는 시계 그림과 시각이 적혀 있습니다. 시계의 그림은 총 세 가지로, 벽시계, 손목시계, 그리고 모래시계입니다. 그렇게 받은 카드를 뒷면이 보이도록 자기 앞에 쌓아서 개인 더미를 만듭니다.\n게임의 진행은 아래과 같습니다.\n\n플레이어는 자기 차례가 되면 개인 더미의 가장 윗장 카드를 펼치며 이번 순서의 시각을 외칩니다. 첫 플레이어는 \"1시\"로 시작합니다.\n시계 방향으로 돌아가며 각자의 차례를 가집니다. 다른 방해 요소가 없다면 방금 전에 불린 시각을 기준으로 $1$시간씩 더해서 외칩니다. 전에 외친 시각이 \"12시\"라면 다음 사람은 \"1시\"를 외칩니다.\n\n단, 펼쳐진 카드에 따라 색다른 방식으로 외치거나 행동해야 할 수 있습니다. 다양한 시간의 법칙이 게임에 영향을 미치게 되는데, 기본적으로 다음 $2$가지 종류의 시간의 법칙을 지켜야 합니다.\n\n시간 역행의 법칙: 누군가 모래시계 카드를 펼치면 시간이 거꾸로 흐르기 시작합니다. \"2시\", \"1시\", \"12시\" 순으로 외쳐야 합니다. 모래시계 카드가 펼쳐질 때마다 시간의 흐름은 반전됩니다.\n동기화의 법칙: 플레이어가 외친 시각과 펼쳐진 카드에 적힌 시각이 일치하면, 모든 플레이어들은 즉시 손바닥으로 게임판 중앙을 내리쳐야 합니다.\n\n\n그림 C.1: 시간 역행의 법칙 - 모래시계 카드를 펼치면 시간이 거꾸로 흐르기 시작합니다.\n\n그림 C.2: 동기화의 법칙 - 외친 시각과 펼쳐진 카드에 적힌 시각이 일치하면 게임판 중앙을 내리칩니다.\n또한 게임에서 반드시 지켜져야 하는 하나의 원칙이 존재합니다.\n\n과부하의 원칙: 펼쳐지는 카드가 동시에 2개 이상의 법칙을 발동시킨다면, 그 어떤 법칙도 적용하지 않습니다. 예를 들어, 시간 역행의 법칙과 동기화의 법칙이 동시에 발동되면, 그 어떠한 법칙도 적용하지 않습니다.\n\n잘못된 시각을 외치거나 손바닥을 가장 늦게 내리친 플레이어는 벌점 토큰을 받아 자기 카드 더미 옆에 놓습니다. 벌점 토큰이 주어지고 나면, 플레이어들은 펼쳐진 카드들을 다시 각자의 카드 더미 밑으로 넣습니다. 그런 다음 벌점을 받은 플레이어가 \"1시\"를 외치며 경기를 재개합니다.\n《크레이지 타임》을 너무나도 좋아하는 한별이는 은하에게 이기기 위해 여러분에게 도움을 청했습니다. 한별이는 마법을 써서 다음 차례의 플레이어가 펼칠 카드를 전부 알아냈습니다. 뛰어난 《크레이지 타임》 플레이어인 은하는 절대로 잘못된 시각을 외치지 않기 때문에, 해당 방법으로 벌점 토큰이 주어지지는 않습니다. 또한 동기화의 법칙이 적용되었을 때 모든 플레이어는 정확히 같은 순간에 손바닥을 내리치게 되는데, 누가 마지막으로 내리쳤는지 알기 어렵기 때문에 실제 게임과는 다르게 아무도 벌점 토큰을 받지 않고 게임을 진행하기로 결정하였습니다. 펼쳐질 카드들의 순서가 주어졌을 때, 각 차례의 플레이어가 외쳐야 하는 시각과 해야 하는 행동을 알려주세요.\n",
        "input_text": "첫 번째 줄에 펼쳐질 카드의 개수 $N$이 주어집니다.\n두 번째 줄부터 $N$개의 줄에 걸쳐 한 줄에 하나씩 카드의 정보가 주어집니다.\n카드의 정보는 공백으로 구분된, 카드에 그려진 시계의 종류를 나타내는 문자열 $S$와 카드에 적힌 시간을 나타내는 양의 정수 $X$로 이루어져 있습니다. \n$S$는 CLOCK, WATCH, HOURGLASS 중 하나입니다.\nCLOCK은 벽시계를, WATCH는 손목시계를, HOURGLASS는 모래시계를 의미합니다.\n",
        "output_text": "$N$줄에 걸쳐 해당 카드를 펼쳤을 때 차례를 진행하는 플레이어가 외쳐야 하는 시각과 해야 하는 행동을 공백으로 구분하여 출력해주세요.\n시각은 $1$부터 $12$ 사이의 정수로, 해야 하는 행동은 게임판 중앙을 내리쳐야 한다면 YES를, 아니면 NO를 출력해주세요.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 746.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "557": {
        "problem_text": "$P_1, P_2, \\cdots , P_N$의 수가 적혀 있는 $N$개의 카드가 있다.\n1부터 N까지 수가 하나씩 존재하는 수열 $D_1, D_2, \\cdots , D_i , \\cdots , D_N$이 있다. 이때 각 $i$에 대해 $D_i$번째 카드를 $i$번째로 가져오는 작업을 셔플이라고 부른다.\n예를 들어, $P_1, P_2, \\cdots , P_N$이 1, 4, 5, 3, 2이고, $D_1, D_2, \\cdots , D_N$가 4, 3, 1, 2, 5라고 가정해보자. 이 카드를 한번 섞으면 3, 5, 1, 4, 2가 된다. 아래 그림에서 $S$는 카드를 한 번 섞은 후를 의미한다.\n\n위 방식을 그대로 $K$번 셔플한 카드의 정보와 $D$의 정보를 알고 있다고 할 때, 원래 카드는 어떤 배치를 이루고 있었는지 구해보자.\n",
        "input_text": "첫번째 줄에는 카드의 개수 $N$과 카드를 섞은 횟수인 $K$가 공백으로 구분되어 주어진다.\n두번째 줄에는 $K$번 카드를 섞은 후 카드의 배치를 의미하는 $S_i$가 공백으로 구분되어 총 $N$개 주어진다.\n세번째 줄에는 총 $N$개의 $D_i$이 공백으로 구분되어 주어진다.\n",
        "output_text": "원래 카드의 배치인 $P_1$부터 $P_N$까지의 값들을 공백으로 구분해서 출력한다.\n",
        "memory_median": 2180.0,
        "time_median": 20.0,
        "length_median": 585.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "558": {
        "problem_text": "사람을 화나게 하는 법은 다양하다. 그 중에서도 악질은 바로 열심히 세워놓은 도미노를 넘어뜨리는 것이다. 이번에 출시된 보드 게임인 \"너 죽고 나 살자 게임\"은 바로 이 점을 이용해서 2명이 공격과 수비를 하는 게임이다. 공격수는 도미노를 계속 넘어뜨리고 수비수는 도미노를 계속 세우려고 한다. 본 게임은 다음과 같이 진행된다.\n\nN 행 M 열의 2차원 격자 모양의 게임판의 각 격자에 도미노를 세운다. 각 도미노는 1 이상 5 이하의 높이를 가진다.\n매 라운드는 공격수가 먼저 공격하고, 수비수는 공격이 끝난 뒤에 수비를 한다.\n공격수는 특정 격자에 놓인 도미노를 동, 서, 남, 북 중 원하는 방향으로 넘어뜨린다. 길이가 K인 도미노가 특정 방향으로 넘어진다면, 그 방향으로 K-1 개의 도미노들 중에 아직 넘어지지 않은 것들이 같은 방향으로 연달아 넘어진다. 이 때, 당연히 도미노의 특성상, 연쇄적으로 도미노가 넘어질 수 있다. 이미 넘어진 도미노가 있는 칸을 공격한 경우에는 아무 일이 일어나지 않는다.\n수비수는 넘어져 있는 도미노들 중에 원하는 것 하나를 다시 세울 수 있다. 넘어지지 않은 도미노를 세우려고 하면 아무 일이 일어나지 않는다.\n총 R 번의 라운드동안 3, 4번 과정이 반복된다. 매 라운드마다 공격수가 해당 라운드에 넘어뜨린 도미노의 개수를 세고, R 라운드에 걸친 총합이 곧 공격수의 점수가 된다.\n\n\n도미노 공격에 대한 예시 그림이다. 그림의 빨간 숫자들은 넘어진 도미노들을 의미한다.\n예를 들어 {3, 1, 2, 2, 2} 높이의 도미노가 일렬로 서 있는 과정에서 3번을 오른쪽으로 밀면 왼쪽의 3개가 오른쪽으로 넘어지게 된다. 이에 따라 새롭게 넘어진 도미노들의 연쇄작용이 발생하는데, 이 과정에서 4번째에 위치한 길이 2짜리 도미노도 넘어지게 된다. 이어서 마지막 도미노까지 쓰러지게 되는 것이다.\n인내를 빼면 시체라고 자부하는 호석이는 당신의 공격을 이겨내고자 수비수를 자처했다. 초기 도미노 판의 상태와, 각 라운드에서 둘의 행동의 기록을 받아서 공격수의 점수와 게임판의 최종 상태를 출력하는 프로그램을 작성하라.\n",
        "input_text": "첫 번째 줄에는 게임판의 행 개수 N, 열 개수 M, 라운드 횟수 R 이 주어진다.\n이어서 N개의 줄에 게임판의 상태가 주어진다. 1행부터 주어지며, M 개의 숫자는 각 격자에 놓인 도미노의 길이를 의미한다.\n이어서 R×2 개의 줄에 걸쳐서 공격수와 수비수의 행동이 주어진다. 각 라운드는 두 줄로 이뤄지며, 첫 줄은 공격수, 두번째 줄은 수비수의 행동이 주어진다. 공격수의 행동은 \"X Y D\"로 주어진다. 이는 X행 Y열의 도미노를 D 방향으로 민다는 뜻이다. D는 E, W, S, N 중 하나이며 각각 동, 서, 남, 북 방향을 의미한다. 수비수의 행동은 \"X Y\"로 주어진다. 이는 X행 Y열의 도미노를 다시 세운다는 뜻이다.\n만약 이미 넘어진 격자의 도미노를 공격수가 넘어뜨리려 할 때에는 아무 일도 일어나지 않는다. 또한 만약 넘어지지 않은 도미노를 수비수가 세우려고 할 때에도 아무 일도 일어나지 않는다.\n",
        "output_text": "첫 줄에 공격수의 점수를 출력한다.\n이어서 게임판의 상태를 N 줄에 걸쳐서 출력한다. 각 격자마다 넘어진 것은 F, 넘어지지 않은 것은 S 를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2076.0,
        "time_median": 4.0,
        "length_median": 1570.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "559": {
        "problem_text": "아래 그림 1은 수족관을 앞에서 본 모양이다. 이 수족관에는 물이 가득 차 있다. 만약 수족관 밑바닥(수평선분)에 구멍을 하나 뚫으면, 구멍을 통해 수족관의 물이 빠지게 된다.\n\n그림 1. 수족관과 구멍.\n그림 1의 수족관의 경계는 4개의 꼭짓점으로 표현된다. 각 꼭짓점의 위치는 세로줄 번호와 가로줄 번호로 나타낸다. 세로줄은 왼쪽에서 오른쪽으로 0번부터 차례로 증가하는 번호를 붙이고, 가로줄은 위부터 아래로 0번부터 차례로 증가하는 번호를 붙인다. 이웃한 두 세로줄 사이의 거리와 이웃한 두 가로줄 사이의 거리는 모두 1이다. 그래서 왼쪽 위에 있는 꼭짓점의 위치는 (세로줄 번호, 가로줄 번호) = (0, 0)이 되고, 이 꼭짓점부터 시계반대방향으로 수족관의 경계를 따라가면서 만나는 꼭짓점들의 위치는 차례로 (0, 5), (8, 5), (8, 0)이 된다.\n수족관의 바닥을 나타내는 수평선분에 구멍이 있다면, 그 수평선분이 위치한 가로줄보다 위쪽에 있으면서 중력에 따라 구멍으로 흘러 들어갈 수 있는 위치에 있는 물은 모두 그 구멍을 통해 외부로 배출된다. 따라서 그림 1의 물은 바닥의 구멍을 통해 남김없이 모두 빠진다.\n수족관에 담긴 물의 양은 물이 차지하는 면적과 일치하는 양이다. 물의 양의 단위는 L(리터)이다. 따라서 그림 1에서 가득 담긴 물의 양은 물이 차지하는 면적과 동일한 40L이다.\n그림 2처럼 수족관의 바닥이 복잡할 수도 있다.\n수족관의 바닥은 수평선분과 수직선분이 번갈아 여러 번 나타나는 형태이다. 또한 그림 2처럼 수족관 위에서 수직방향으로 수족관 바닥을 보았을 때, 수족관의 바닥이 모두 보이는 (즉, 모든 수평선분이 보이는) 형태이다. \n\n그림 2. 가득 찬 물의 양은 26L, 구멍은 2개.\n구멍은 항상 수평선분에만 존재하며, 수평선분의 한 가운데에 위치한다. 그리고 하나의 수평선분에는 최대 하나의 구멍만 존재할 수 있다. 그림 2에는 2개의 구멍(1번 구멍과 2번 구멍)이 있다. 이 구멍들을 통해 물을 빼면, 그림 3과 같이 빠져나가지 못한 물이 7L 남게 된다\n\n그림 3. 마지막에 남은 물의 양은 7L.\n물이 가득 찬 수족관의 바닥 모양과 구멍이 뚫려 있는 수평선분들이 주어지면, 구멍을 통해 물이 빠져 나간 후 수족관에 남아 있는 물의 양이 몇 리터인지 계산하는 프로그램을 작성하시오.\n",
        "input_text": "입력의 첫 줄은 수족관의 경계에 있는 꼭짓점의 개수 N(1 ≤ N ≤ 5,000)이 주어진다. N은 짝수이다. 수족관의 경계는 항상 꼭짓점 (0, 0)부터 시작한다. 그리고 마지막 꼭짓점은 (A, 0)의 형태로 끝난다. 즉, 시작 꼭짓점과 마지막 꼭짓점의 가로줄 번호는 항상 0이다. 수족관의 경계를 이루는 변은 꼭짓점 (0, 0)부터 시작하는 데, 수직선분으로 시작하여 수평선분과 수직선분이 번갈아가며 반복되다 수직선분으로 끝난다. 따라서 수직선분이 수평선분보다 항상 하나 더 많다. 두 번째 줄부터 N개의 줄에는 수족관 경계에 있는 N개의 꼭짓점의 세로줄 번호와 가로줄 번호가 빈칸을 사이에 두고 각 줄에 하나씩, 첫 꼭짓점 (0, 0)부터 시계반대방향을 따라 차례로 주어진다. 세로줄과 가로줄 번호의 범위는 0 이상 40,000 이하의 정수이다. 다음 줄에는 수족관의 수평선분에 위치한 구멍의 개수 K (1 ≤ K ≤ N/2)가 자연수로 주어진다. 다음 K개의 줄에는 각 구멍이 존재하는 수평선분의 양 끝 꼭짓점 위치를 나타내는 네 개의 값이 빈 칸을 사이에 두고 차례로 주어진다. 즉, 어떤 구멍이 위치한 수평선분의 정보가 a b c b로 주어졌다면, 구멍이 위치한 수평선분은 꼭짓점 (a, b)와 꼭짓점 (c, b)를 연결한 선분이라는 의미이다. 항상 a < c 이다.\n",
        "output_text": "출력은 단 한 줄이며, 구멍을 통해 물이 빠져 나간 후, 수족관에 남아 있는 물의 양을 0 이상의 정수로 출력한다.\n",
        "memory_median": 2236.0,
        "time_median": 12.0,
        "length_median": 1355.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "560": {
        "problem_text": "\"피아의 아틀리에 ~신비한 대회의 연금술사~\"는 가난한 연금술사 피아의 성장스토리를 담은 게임이다. 이 게임의 가장 중요한 부분은 \"대회\"인데, 연금술로 높은 품질의 물건을 만들어 상금을 타야만 피아가 먹고 살 수 있기 때문이다. 스토리는 매우 길지만 여백이 없어 생략하기로 하고, 여러분은 이 게임의 대회 기능을 확인해달라는 요청을 받았다. 여러분이 확인해야 하는 대회는 다음과 같다.\n여러분은 5×5 격자 모양 가마에 서로 다른 재료 3개를 순서대로 넣어 최고 품질의 폭탄을 만들어야 한다. 재료는 대회에서 준비해주며, 넣을 수 있는 재료의 후보는 10개 이하이다. 주어진 재료 중 3개를 고른 뒤, 순서를 정해 가마에 잘 넣어야 한다.\n가마의 각 칸에는 품질을 나타내는 숫자와 원소를 나타내는 색이 칠해져 있다. 초기에는 모든 칸의 품질은 0, 원소는 흰색이다. 재료는 4×4 모양으로 생겼으며, 재료의 i행 j열에는 2가지 정보가 있다.\n\n효능: 가마 한 칸의 품질을 바꾸는 -9 이상 9 이하의 정수 xi,j\n원소: 가마 한 칸의 원소를 바꿀 수 있는 색 ci,j (빨강 'R', 파랑 'B', 초록 'G', 노랑 'Y', 흰색 'W' 중 하나이다)\n\n재료를 가마에 넣을 때는 5×5 격자를 벗어날 수 없다. 회전은 가능하나, 격자에 맞지 않게 기울여 넣을 수는 없다. 재료를 가마에 넣을 때, 가마의 상태는 다음과 같이 바뀐다.\n\n재료가 위치하지 않는 가마의 격자칸은 아무런 변화가 생기지 않는다.\n재료가 위치한 가마의 격자칸에 있는 품질과 원소값은 바뀔 수 있다.\r\n\t\n격자의 품질은 재료의 효능이 더해진다. 더한 뒤의 값이 음수인 경우 0으로, 9 초과인 경우 9로 바뀐다.\n격자의 색은 재료의 원소가 흰색인 경우 그대로, 아닌 경우 재료의 원소와 같은 색으로 칠해진다.\n\n\n\n재료 3개를 모두 넣어야만 폭탄이 만들어지며, 폭탄의 품질은 다음과 같이 계산된다. 가마의 최종 상태에서 빨강, 파랑, 초록, 노랑으로 칠해진 부분의 품질 합을 각각 R, B, G, Y라고 했을 때,\n(폭탄의 품질) = 7R + 5B + 3G + 2Y\n폭탄을 만들기 위한 재료의 후보가 주어졌을 때, 재료를 적절히 선택하고 배치하여 만들 수 있는 폭탄의 최대 품질을 구하자.\n",
        "input_text": "첫 번째 줄에 재료의 개수를 나타내는 자연수 n이 주어진다. (3 ≤ n ≤ 10)\n두 번째 줄부터 n개의 재료 정보가 순서대로 주어진다. 각 재료의 정보는 다음과 같다. 먼저 4개의 줄에 효능을 나타내는 수 4개가 공백을 사이에 두고 주어진다. 다음 4개의 줄에 원소를 나타내는 글자 4개가 공백을 사이에 두고 주어진다. 이 글자는 R, B, G, Y, W 중 하나임이 보장된다.\n",
        "output_text": "첫 번째 줄에 품질의 최댓값을 출력한다.\n",
        "memory_median": 1992.0,
        "time_median": 824.0,
        "length_median": 3231.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "561": {
        "problem_text": "에어팟에 여러 개의 핸드폰을 다음과 같은 방법으로 연결하고자 한다. \n\n에어팟은 한 번에 하나의 핸드폰에만 연결이 가능하다.\n에어팟을 새로운 핸드폰에 연결할 때마다, 기존 핸드폰과의 연결이 끊어지고, 에어팟 배터리 2퍼센트를 소모한다.\n이미 연결되어 있는 핸드폰에 다시 연결을 시도할 때, 직전 배터리 소모량의 2배만큼 배터리를 소모하게 된다.\n누적 배터리 소모량이 100퍼센트 이상이 될 경우, 에어팟을 충전시켜야 하기 때문에 현재 핸드폰과 에어팟의 연결을 해제한다. 이 경우 에어팟의 배터리 소모량은 0이 되고, 다음 핸드폰부터는 새로운 에어팟에 연결한다.\n\n핸드폰의 종류는 $1$부터 $9$ 사이의 숫자로 나타내어지고, 에어팟에 연결한 순서대로 주어진다. 에어팟을 핸드폰에 연결한 횟수 $N$과 각 차례에 연결한 핸드폰 종류 $A_i$가 주어질 때, 현재 에어팟 배터리의 소모량을 퍼센트 단위로 출력하시오.\n",
        "input_text": "첫 번째 줄에는 에어팟에 핸드폰의 연결한 횟수 $N$이 주어진다. ($1 \\le N \\le 1\\,000$)\n두 번째 줄에는 정수 $A_1, A_2, \\dots, A_N$이 공백으로 구분되어 주어진다. ($1 \\le A_i \\le 9$)\n핸드폰의 종류는 에어팟에 연결을 시도한 순서대로 주어진다.\n",
        "output_text": "현재 에어팟의 배터리 소모량을 출력하시오.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 549.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "562": {
        "problem_text": "During the Olympiad finals we usually serve pizza for the contestants. When the food arrives, the contestants to queue to get some pizza. Each student will be given a single slice of pizza when his/her turn arrives. The problem is that some people need more than one slice of pizza to be well fed so they need to queue again for more pizza after they get the first one.\nGiven a list of slices needed to fed each of the contestants, compute how long it will take to fed all of them. We can give a slice of pizza every second and when a contestant is well fed he does not return to the queue.\n",
        "input_text": "The first line will contain an integer N. The number of contestants.\nThe second line will contain N integers separated by spaces. The number of slices of pizza needed to feed each contestant.\nN <= 1000\nThe numbers in the sequence will be between 1 and 1000.\nEach contestant will need at least 1 and at most 100 slices of pizza.\n",
        "output_text": "A line containing N integers separated by spaces. The time in which each of the contestant get all the slices he/she needs.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 614.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "563": {
        "problem_text": "\n19x19크기의 바둑판에, 돌을 놓을 좌표가 주어지면 이 게임이 몇 수만에 끝나는 지를 알아보려고 한다. 사용하고자 하는 바둑판의 모양은 위의 그림과 같으며, (1, 1)이 가장 왼쪽 위의 좌표이고 (19, 19)가 가장 오른쪽 아래의 좌표이다. 오목은 흑 또는 백이 5개의 돌을 가로, 세로, 혹은 대각선으로 연속으로 놓았을 경우 게임이 끝나게 된다. 즉, 다음 그림과 같은 경우를 말한다.\n\n게임은 흑이 먼저 시작하며, 한수씩 서로 번갈아 가며 두게 된다. 다음 좌표들과 같이 차례로 돌을 놓으며 게임을 진행한다고 하자. (홀수번째는 흑, 짝수번째는 백)\n\n1 - (3,3)\n2 - (2,3)\n3 - (3,4)\n4 -  (2,2)\n5 - (3,2)\n6 - (3,1)\n7 - (3,5)\n8 - (2,4)\n9 - (2,5)\n10 - (2,1)\n11 - (1,5)\n12 - (4,1)\n13 - (4,5)\n14 - (5,5)\n15 - (1,4)\n16 - (5,1)\n17 - (1,3)\n18 - (1,1)\n19 - (5,3)\n20 - (5,2)\n21 - (1,2)\n22 - (5,4)\n23 - (4,2)\n24 - (4,4)\n25 - (4,3)\n\n위의 순서대로 바둑판에 돌을 놓으면 아래의 왼쪽 그림과 같이 된다.\n\n그런데 생각해보면, 위의 좌표대로 돌을 놓았을 때 오른쪽 그림처럼 18번째의 돌을 놓는 것으로서 게임이 끝나 버리는 것을 알 수 있다. 이 경우, 답은 18이다.\n바둑판에 돌을 놓는 좌표가 입력될 때, 몇 번째 수에서 오목이 끝나는지를 찾는 프로그램을 작성하시오. 오목을 두다 보면 다음과 같이 돌이 5개를 거치지 않고 6개 이상의 돌이 나란히 놓이는 경우가 발생할 수 있다. 이런 경우에는 승리를 인정하지 않고 오목이 계속된다는 것에 주의하라.\n\n",
        "input_text": "첫째 줄에 바둑판에 놓이는 돌의 개수 N(1 ≤ N ≤ 100)이 주어진다. 그 다음 N줄에는 놓이는 돌의 좌표들이 차례로 주어진다. (홀수번째는 흑, 짝수번째는 백) 돌을 놓은 곳에 또 돌을 놓는 경우는 없다.\n",
        "output_text": "첫째 줄에 몇 번째 수에서 승패가 갈리는지를 출력한다. 승패가 갈리지 않는 경우에는 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1395.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "564": {
        "problem_text": "Farmer John has lost his prize cow Bessie, and he needs to find her!\nFortunately, there is only one long path running across the farm, and Farmer John knows that Bessie has to be at some location on this path. If we think of the path as a number line, then Farmer John is currently at position \\(x\\) and Bessie is currently at position \\(y\\) (unknown to Farmer John). If Farmer John only knew where Bessie was located, he could walk directly to her, traveling a distance of \\(|x - y|\\). Unfortunately, it is dark outside and Farmer John can't see anything. The only way he can find Bessie is to walk back and forth until he eventually reaches her position.\nTrying to figure out the best strategy for walking back and forth in his search, Farmer John consults the computer science research literature and is somewhat amused to find that this exact problem has not only been studied by computer scientists in the past, but that it is actually called the \"Lost Cow Problem\" (this is actually true!).\nThe recommended solution for Farmer John to find Bessie is to move to position \\(x+1\\), then reverse direction and move to position \\(x-2\\), then to position \\(x+4\\), and so on, in a \"zig zag\" pattern, each step moving twice as far from his initial starting position as before. As he has read during his study of algorithms for solving the lost cow problem, this approach guarantees that he will at worst travel 9 times the direct distance \\(|x-y|\\) between himself and Bessie before he finds her (this is also true, and the factor of 9 is actually the smallest such worst case guarantee any strategy can achieve).\nFarmer John is curious to verify this result. Given \\(x\\) and \\(y\\), please compute the total distance he will travel according to the zig-zag search strategy above until he finds Bessie.\n",
        "input_text": "The single line of input contains two distinct space-separated integers \\(x\\) and \\(y\\). Both are in the range \\(0 \\ldots 1,000\\).\n",
        "output_text": "Print one line of output, containing the distance Farmer John will travel to reach Bessie.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 536.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "565": {
        "problem_text": "상근이는 가위 바위 보를 할 수 있는 로봇을 가지고 있다. 게임은 총 k번의 연속적인 라운드로 이루어져 있다.\n각 로봇은 길이가 k인 문자열을 가지고 있고, 이 문자열에 의해서 게임을 하게 된다. 각 라운드에서 패배한 로봇은 더 이상 게임을 참여할 수 없고, 남은 로봇끼리 게임을 하게 된다. 로봇이 하나만 남은 경우에는 그 로봇이 게임을 승리하게 되고, 게임이 끝난다. k 라운드가 지난 후에 남아있는 로봇이 하나보다 많다면, 게임은 무승부로 끝난다.\n가위는 S, 바위는 R, 보는 P로 나타낼 수 있다. 만약, 로봇이 가지고 있는 문자열이 RSPSRSSP 라면, 첫 라운드에서 로봇은 주먹을 내고, 둘째 라운드에서는 가위를 낸다. 여덟번째 라운드까지 그 로봇이 살아있다면 보를 낸다.\n가위 바위 보 게임에 참여하는 로봇의 수와 각 로봇의 문자열이 주어졌을 때, 게임의 승자를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 참여하는 로봇의 수 N이 주어진다. 다음 N개 줄에는 각 로봇에 저장되어 있는 문자열이 주어진다. 모든 로봇의 문자열의 길이는 k이다. (2 ≤ N ≤ 10, 3 ≤ k ≤ 30) 로봇은 주어지는 순서대로 1번부터 번호를 매긴다. \n",
        "output_text": "각 테스트 케이스마다, 게임을 승리한 로봇의 번호를 출력한다. k 라운드가 지난 후에도 승자가 없는 경우 (무승부) 에는 0을 출력한다.\n",
        "memory_median": 1536.0,
        "time_median": 0.0,
        "length_median": 1474.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "566": {
        "problem_text": "위병소에서 근무하는 헌병은 오늘 근무를 끝마치고 보안 점검을 위해 출입 기록을 살펴보던 중, 오늘 출입 기록의 일부가 누락되었다는 사실을 깨달았다!\n오늘 기록된 출입 기록은 총 $N$개이며, 출입 기록은 반드시 출입자가 출입한 시간순으로 기록된다.\n$i$번째 출입 기록은 두 개의 정수 $a_i, b_i$로 기록되는데, $a_i$는 출입하는 사람의 번호를 의미하며, $b_i$가 $1$이면 부대로 들어갔다는 뜻이고 $b_i$가 $0$이면 부대에서 나왔다는 뜻이다. 또한, 출입 기록을 시작하기 전과 출입 기록을 끝낸 후에는 부대 내에 아무도 없었다고 한다.\n오늘의 출입 기록을 토대로 오늘 하루동안 누락된 출입 기록의 최소 개수를 구하여라.\n",
        "input_text": "첫 번째 줄에 출입 기록의 개수 $N$이 주어진다. $(1\\leq N\\leq 200\\,000)$\n두 번째 줄부터 $N+1$번째 줄까지, $i$번째 출입 기록을 나타내는 정수 $a_i$와 $b_i$가 공백으로 구분되어 주어진다. $(1\\leq a_i\\leq 200\\,000;$ $0\\leq b_i\\leq 1)$\n",
        "output_text": "오늘 하루 동안 누락된 출입 기록의 최소 개수를 출력한다.\n",
        "memory_median": 2800.0,
        "time_median": 52.0,
        "length_median": 536.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "567": {
        "problem_text": "여러분은 가변 배열에 대하여 아는가? 아직 잘 모른다면, 아마 여러분은 배열을 고정된 크기로 선언할 것이다. 그래서 한 번쯤은 배열의 크기가 부족해 원하지 않는 채점 결과를 마주했던 기억이 있을 것이다. 가변 배열은 선언한 배열의 크기가 부족할 경우 배열의 크기를 자동으로 늘려준다! 어떻게 이것이 가능한지 알아보도록 하자.\n가변 배열은 다음과 같이 동작한다.\n\n초기 크기를 원하는 만큼 지정하여 가변 배열을 생성한다. 이때 가변 배열은 비어있는 상태이다.\n원소를 저장해야 하는데 가변 배열이 꽉 차 있는 경우, 현재 가변 배열의 크기의 $2$배에 해당하는 새로운 가변 배열을 선언한다.\n새로 생성한 $2$배 크기의 가변 배열의 맨 앞에 기존 가변 배열에 있는 원소를 모두 복사한 후, 기존 가변 배열을 지우고 새로운 가변 배열로 대체한다. 이후 2번에서 저장하려고 했던 원소를 그 뒤에 저장한다.\n\n이러한 동작을 위하여 가변 배열에서는 $2$개의 변수를 관리해야 한다. 하나는 가변 배열의 현재 최대 크기를 의미하는 $S$이고, 다른 하나는 가변 배열에서 현재 사용 중인 크기를 의미하는 $U$이다.\n이 설명을 참조하여 가변 배열의 초기 크기와, 일련의 원소 저장 또는 삭제 명령이 주어졌을 때, 명령들을 모두 수행한 후 가변 배열의 최대 크기를 출력해 보자.\n",
        "input_text": "첫 번째 줄에 가변 배열의 초기 최대 크기를 의미하는 정수 $S_0$와 배열에 원소를 저장하는 명령의 개수를 의미하는 정수 $N$, 배열에서 원소를 삭제하는 명령의 개수를 의미하는 정수 $M$이 공백으로 구분되어 주어진다. $(1 \\le S_0 \\le 10;$ $1 \\le N \\le 100\\,000;$ $0 \\le M \\le N)$\n두 번째 줄부터 $N + M + 1$번째 줄까지 한 줄에 하나씩 1 혹은 0이 주어진다. 1은 배열에 원소를 저장하는 명령이고, 0은 배열의 끝에서 원소를 삭제하는 명령이다.\n가변 배열에 저장된 원소가 없을 때 삭제 명령이 주어지는 경우는 없다.\n",
        "output_text": "모든 명령을 처리한 후 가변 배열의 최대 크기를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 16.0,
        "length_median": 363.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0
        ]
    },
    "568": {
        "problem_text": "You are required to print a value of $c$ which is not equal to the sum of two given numbers $a$ and $b$.\n",
        "input_text": "First line contains an integer $t$ --- number of tests. Next $t$ lines contain two integers $a$ and $b$ each.\n",
        "output_text": "You are required to output an integer $c$ for each test in a separate line. If there are multiple solutions, you may output any of them.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 228.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "569": {
        "problem_text": "$N \\times M$ 크기의 $2$차원 배열이 있다. 당신은 배열의 각 칸에 $1$ 이상 $K$ 이하의 정수를 채워 넣어 배열을 증가 상태로 만들고자 한다.\n배열이 증가 상태라는 것은 $\\left(1, 1\\right)$에서 출발해서 $\\left(N, M\\right)$을 향해 오른쪽이나 아래쪽으로 이동할 때 가능한 모든 경로에 대해, 각 경로에서 방문한 칸의 수를 처음부터 일렬로 나열한 수열이 오름차순임을 의미한다.\n\n오른쪽이나 아래쪽으로 이동한다는 것은, $\\left(i, j\\right)$에서 $\\left(i, j + 1\\right)$와 $\\left(i + 1, j\\right)$로 움직인다는 것이다. 단, 배열 밖으로는 이동할 수 없다.\n수열 $A_{1}, A_{2}, \\dots, A_{k}$ 가 오름차순이라는 것은 $A_{1} \\lt A_{2} \\lt \\cdots \\lt A_{k}$ 임을 의미한다.\n\n",
        "input_text": "첫째 줄에 $N$, $M$, $K$가 주어진다. $\\left(1 \\le N , M \\le 1\\,000,1 \\le K \\le 100\\,000 \\right)$\n",
        "output_text": "조건에 맞는 배열이 존재하면 첫 번째 줄에 YES를 출력하고 두 번째 줄부터 $N$개의 각 줄에 $1$ 이상 $K$ 이하의 수 $M$개를 공백으로 구분하여 출력하라. 조건에 맞는 배열이 여러 개일 경우 그중 하나만 출력한다.\n그런 배열이 존재하지 않으면 NO를 출력하라.\n",
        "memory_median": 2020.0,
        "time_median": 84.0,
        "length_median": 432.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "570": {
        "problem_text": "m × n 직사각 그리드(rectangular grid)는, x-좌표의 범위가 0부터 n-1까지인 정수이고 y-좌표의 범위가 0부터 m-1까지 정수인 평면상의 점들에 대응하는 정점들을 가지고, 두 정점에 대응하는 두 점 사이의 거리가 1 일 때에만 그 둘을 잇는 에지가 있는 그래프다. 예를 들어, 4 × 6 직사각 그리드가 그림 1 에 있다. 이 그리드는 m개 행 각각에 n개의 정점이 있고, n개 열 각각에 m 개의 정점이 있다. 행 i와 열 j에 있는 정점을 (i,j)라고 나타낸다. 여기서 0 ≤ i ≤ m-1이고 0 ≤ j ≤ n-1이다.\nm × n 직사각 그리드의 모든 행 i ∈ {0, … , m-1}에 대하여 두 정점 (i, 0)과 (i, n-1)을 잇는 에지를 추가하고, 또한 모든 열 j ∈ {0, … , n-1} 에 대하여 두 정점 (0, j) 와 (m-1, j) 을 잇는 에지를 추가하면, 그림 2 에 보인 것과 같이 각 행은 길이 n인 사이클을 이루고 각 열은 길이 m인 사이클을 이루게 된다. 이렇게 만들어진 그래프를 종종 m × n 토로이드 그리드(toroidal grid) 라고 부르는데, 왜냐하면 이 그래프를 토러스(torus)에 에지가 교차하지 않도록 그릴 수 있기 때문이다.\n\n주어진 m × n 토로이드 그리드에 대하여, 모든 정점을 정확히 한번씩 지나는 사이클을 찾는 프로그램을 작성하시오. 문제에서 요구하는 사이클은 그래프에 있는 서로 다른 mn개 정점들의 열 (v1, v2, … , vmn)로 나타낼 수 있는데, 이때 모든 k ∈ {1, … , mn-1}에 대하여 vk와 vk+1은 인접하며 또한 vmn과 v1도 인접하여야 한다.\n",
        "input_text": "표준입력에서 데이터를 읽는다. 입력은 T개의 의 테스트 데이터로 구성되어 있다. 입력의 첫째 줄에 입력 데이터의 개수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 두 정수 m과 n을 포함하는 한 줄로 구성되어 있는데, 입력 그래프가 m × n 토로이드 그리드임을 가리킨다. 여기서 3 ≤ m, n ≤ 100이다.\n",
        "output_text": "표준출력으로 데이터를 출력한다. 각 테스트 데이터에 대해, 출력의 첫째 줄에는 조건을 만족하는 해가 존재하는지 아닌지를 나타내는 정수를 출력해야 한다. 만약 해가 존재하면, 그 정수는 1 이어야 한다; 그렇지 않으면 -1 이다. 첫째 줄이 1 일 경우에만 추가로 문제에서 요구한 사이클의 정점 열(sequence)을 mn 개의 줄에 출력한다. 복수의 해가 가능하면, 그 중 임의의 하나를 출력하면 된다. 어떤 줄에도 공백 문자(빈칸이나 탭)는 허용되지 않는다.\n",
        "memory_median": 1524.0,
        "time_median": 56.0,
        "length_median": 841.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "571": {
        "problem_text": "n개의 정수로 된 순서 S= (s1, s2, ..., sn)가 있다. 여기서 si ≠ sj이고, 1 ≤ si ≤ n이다. S로부터 새로운 순서 R = (r1, r2, ..., rn)을 얻을 수 있는데, 여기서 ri는 S의 부분 순서 {s1, s2, ..., si-2, si-1} 중에서 si보다 작은 수의 개수이다.\nn = 10인 경우의 예를 보자. S = (6, 4, 3, 5, 1, 2, 7, 8, 9, 10)이라면 R = (0, 0, 0, 2, 0, 1, 6, 7, 8, 9)이 된다. 어떤 순서 R이 주어질 때, 여러분은 R을 이용하여 S를 찾는 프로그램을 작성하어야 한다. 경우에 따라서는 R로부터 S를 찾는 것이 불가능할 수 있다. 예를 들어, 만약 n = 5이고, R = (0, 2, 2, 0, 1)이라면 이런 R에 대응하는 S는 존재하지 않는다.\n",
        "input_text": "입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 S에 있는 정수의 개수 n (1 ≤ n ≤ 100)이 주어진다. 그 다음 줄에는 n개의 정수로 된 R이 주어진다. \n",
        "output_text": "출력은 표준출력을 사용한다. 주어진 각 순서 R 에 대해, 대응하는 순서 S 를 찾아 한 줄에 출력하여야 한다. 만약 R로부터 S를 찾는 것이 불가능할 경우에 “IMPOSSIBLE”을 출력한다.\n",
        "memory_median": 1536.0,
        "time_median": 0.0,
        "length_median": 829.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "572": {
        "problem_text": "신수동 최고의 인싸 환주는 오늘도 인기가 많다. 그 인기는 정말 대단해서 대나무숲에서는 매일 환주의 이름이 쏟아진다.\n환주에게는 그 인기의 비결이 있었는데, 바로 자신이 원하는 두 명을 그렇고 그런 사이로 만들 수 있는 것이다!\n환주가 그렇고 그런 사이를 만드는 방법은 다음과 같다.\n\n$1$번 사람부터 $N$번 사람까지 $N$명을 일렬로 세운다.\n모든 사람에게 $1$부터 $N$까지 양의 정수 중 하나가 적힌 쪽지를 나눠준다. 쪽지에 적힌 정수는 중복되지 않는다.\n서로 다른 두 사람을 골랐을 때, 왼쪽에 있는 사람이 오른쪽에 있는 사람보다 쪽지에 적힌 정수가 더 크다면, 이 두 사람은 그렇고 그런 사이가 된다.\n놀랍게도 한 사람이 여러 사람과 그렇고 그런 사이일 수도 있다.\n\n21세기의 큐피드 환주는 썸과 연애 상담이 너무 많이 와서 힘들다. 그래서 환주는 한 번에 여러 개의 그렇고 그런 사이를 만들려 한다. 하지만 너무 많이 만들면 미풍양속에 저해되고, 너무 적게 만들면 솔로들이 많아지기 때문에, 정확히 $K$개의 그렇고 그런 사이를 만들려 한다. \n환주는 저 멀리서 달려오는 $N$명의 친구들을 보았다. 재빨리 $K$개의 그렇고 그런 사이를 만들어 주지 않으면, 저들은 환주의 안티팬이 될지도 모른다!\n",
        "input_text": "정수 $N$, $K$가 주어진다. ($2 \\leq N \\leq 4\\,242$, $0 \\leq K \\leq \\frac{N(N-1)}{2}$)\n",
        "output_text": "$N$개의 정수 $v_1, v_2, \\cdots, v_N$을 공백 단위로 출력한다.\n$v_i$는 $i$번째 사람이 받은 쪽지에 적힌 정수를 의미하고, 정확히 $K$개의 그렇고 그런 사이가 만들어져야 한다.\n정확히 $K$개의 그렇고 그런 사이를 만들 방법은 항상 존재하고, 만약 여러 가지 방법이 있다면 그중 하나를 출력한다.\n",
        "memory_median": 2036.0,
        "time_median": 0.0,
        "length_median": 606.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "573": {
        "problem_text": "백준이는 2580번 스도쿠 문제를 풀기 위해 아래와 같은 코드를 작성했다.\n\r\n#include <iostream>\r\nusing namespace std;\r\nint a[10][10];\r\nbool c[10][10];\r\nbool c2[10][10];\r\nbool c3[10][10];\r\nint n=9;\r\nint cnt=0;\r\nint square(int x, int y) {\r\n    return (x/3)*3+(y/3);\r\n}\r\nbool go(int z) {\r\n    cnt += 1;\r\n    if (cnt >= 10000000) {\r\n        return true;\r\n    }\r\n    if (z == 81) {\r\n        for (int i=0; i<n; i++) {\r\n            for (int j=0; j<n; j++) {\r\n                cout << a[i][j] << ' ';\r\n            }\r\n            cout << '\\n';\r\n        }\r\n        return true;\r\n    }\r\n    int x = z/n;\r\n    int y = z%n;\r\n    if (a[x][y] != 0) {\r\n        return go(z+1);\r\n    } else {\r\n        for (int i=1; i<=9; i++) {\r\n            if (c[x][i] == 0 && c2[y][i] == 0 && c3[square(x,y)][i]==0) {\r\n                c[x][i] = c2[y][i] = c3[square(x,y)][i] = true;\r\n                a[x][y] = i;\r\n                if (go(z+1)) {\r\n                    return true;\r\n                }\r\n                a[x][y] = 0;\r\n                c[x][i] = c2[y][i] = c3[square(x,y)][i] = false;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nint main() {\r\n    for (int i=0; i<n; i++) {\r\n        for (int j=0; j<n; j++) {\r\n            cin >> a[i][j];\r\n            if (a[i][j] != 0) {\r\n                c[i][a[i][j]] = true;\r\n                c2[j][a[i][j]] = true;\r\n                c3[square(i,j)][a[i][j]] = true;\r\n            }\r\n        }\r\n    }\r\n    go(0);\r\n    return 0;\r\n}\r\n\n변수 cnt에 저장된 값이 가장 큰 스도쿠 퍼즐을 출력하는 프로그램을 작성하시오. 문제의 점수는 cnt에 저장된 값이다.\n",
        "input_text": "입력은 없다.\n",
        "output_text": "총 9개의 줄에 스도쿠 퍼즐을 출력한다. 빈 칸은 0으로 출력한다. (2580번 문제의 입력을 출력한다)\n만약, 풀 수 없는 스도쿠 퍼즐을 출력한 경우에는 틀렸습니다를 받게 된다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 390.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "574": {
        "problem_text": "계산은 사람에게나 컴퓨터에게나 상당히 번거로운 일인 것 같다. 특히 \\(n\\)개의 행렬 \\(\\textbf{M}_{1}, \\textbf{M}_{2}, \\cdots, \\textbf{M}_{n}\\)의 곱, 즉 \\(\\textbf{M}_{1} \\textbf{M}_{2} \\cdots \\textbf{M}_{n}\\)같은 것은 정말이지 계산하기 귀찮다.\n행렬과 그 곱셈이 익숙하지 않은 사람들을 위해 설명을 해 보자면, 먼저 행렬은 여러 수나 기호, 문자, 수식 같은 것을 직사각형 모양으로 적절히 배열한 후 이를 괄호로 묶은 것을 말한다. 편의상 이 문제에서는 행렬에 정수만 배열한다고 가정한다. 예를 들어 아래와 같은 것이 행렬의 한 예이다.\n\\[\\begin{pmatrix} 2 & 0 & 1 & 6 \\\\ 0 & 5 & 2 & 8 \\\\ 1 & 4 & -1 & 7 \\end{pmatrix}\\]\n행렬에 배열된 수를 성분이라고 한다. 행렬의 가로줄은 행이라고 부르며, 위에서부터 차례로 제1행, 제2행, 제3행, … 식으로 이름을 붙인다. 또한 행렬의 세로줄은 열이라고 부르며, 왼쪽에서부터 차례로 제1열, 제2열, 제3열, … 식으로 이름을 붙인다. \\(m\\)개의 행과 \\(n\\)개의 열로 이루어진 행렬은 \\(m \\times n\\) 행렬이라고 한다. 마지막으로 제\\(i\\)행 제\\(j\\)열에 위치한 성분을 행렬의 \\((i, j)\\) 성분이라고 하며, 어떤 행렬 \\(\\textbf{A}\\)의 \\((i, j)\\) 성분을 \\(A_{ij}\\)와 같이 표기한다고 한다.\n\n그러면 행렬을 어떻게 곱한다는 것일까? 실수에서의 곱셈과 같이, 행렬의 곱셈도 두 개의 행렬을 가지고 할 수 있다. \\(\\textbf{A}\\)가 \\(m \\times n\\) 행렬이고, \\(\\textbf{B}\\)가 \\(n \\times p\\) 행렬일 때, \\(\\textbf{A}\\)와 \\(\\textbf{B}\\)의 곱 \\(\\textbf{AB}\\)는 아래와 같은 \\(m \\times p\\) 행렬로 정의된다고 한다.\n\\[\\mathbf{AB} = \\begin{pmatrix} \\sum_{k=1}^n A_{1k}B_{k1} & \\sum_{k=1}^n A_{1k}B_{k2} & \\cdots & \\sum_{k=1}^n A_{1k}B_{kp} \\\\ \\sum_{k=1}^n A_{2k}B_{k1} & \\sum_{k=1}^n A_{2k}B_{k1} & \\cdots & \\sum_{k=1}^n A_{2k}B_{kp} \\\\ \\vdots & \\vdots & & \\vdots \\\\ \\sum_{k=1}^n A_{mk}B_{k1} & \\sum_{k=1}^n A_{mk}B_{kp} & \\cdots & \\sum_{k=1}^n A_{mk}B_{kp} \\end{pmatrix}\\]\n\\(\\mathbf{AB}\\)의 각 성분을 계산하기 위해 \\(n\\)회의 정수 곱셈이 필요하고, \\(\\mathbf{AB}\\)이 \\(m \\times p\\) 행렬이므로, 모든 성분을 계산하기 위해 총 \\((m \\times p) \\times n = m \\times n \\times p\\)회의 정수 곱셈이 필요함을 알 수 있다.\n\\(\\textbf{A}\\)의 열의 수와 \\(\\textbf{B}\\)의 행의 수가 같을 때에만 행렬의 곱셈이 정의된다. 예를 들어 \\(3 \\times 2\\) 행렬과 \\(4 \\times 5\\) 행렬을 곱할 수는 없다는 것이다.\n그렇다면 우리가 처음 생각했던 행렬 \\(n\\)개의 곱은 어떨까? 실수에서 곱셈을 할 때 곱셈의 여러 성질들을 활용하듯이, 행렬을 곱할 때에도 이러한 곱셈의 성질을 활용할 수 있다.\n일반적으로 행렬의 곱셈은 교환법칙이 성립하지 않지만, 결합법칙은 성립하는 것으로 알려져 있다. 다시 말해, \\(m \\times n\\) 행렬 \\(\\textbf{A}\\), \\(n \\times p\\) 행렬 \\(\\textbf{B}\\), \\(p \\times q\\) 행렬 \\(\\textbf{C}\\)에 대해 일반적으로\n\n\\(\\textbf{AB} \\neq \\textbf{BA}\\)\n\\(\\textbf{ABC} = (\\textbf{AB})\\textbf{C} = \\textbf{A} (\\textbf{B}\\textbf{C})\\)\n\n임이 알려져 있다는 것이다. 즉 행렬 여러 개를 곱할 때 행렬이 나열된 순서를 바꿀 수는 없지만, 곱하는 순서는 상관이 없음을 알 수 있다. 그런데 행렬을 곱하는 순서를 바꾼다고 실제로 정수 곱셈의 수가 바뀔까? 실제 예시를 통해 이를 확인해보자.\n\\(\\textbf{A}\\)가 \\(2 \\times 4\\) 행렬이고, \\(\\textbf{B}\\)가 \\(4 \\times 3\\) 행렬, \\(\\textbf{C}\\)가 \\(3 \\times 5\\) 행렬이라고 하자. 행렬의 곱 \\(\\textbf{ABC}\\)를 계산하기 위해 필요한 정수 곱셈의 수를 분석해 보면 아래와 같다.\n\n\\((\\textbf{A}\\textbf{B})\\textbf{C}\\)와 같이 계산한다면\r\n\t\n\\(2 \\times 4\\) 행렬 \\(\\textbf{A}\\)와 \\(4 \\times 3\\) 행렬 \\(\\textbf{B}\\)를 곱할 때 \\(2 \\times 4 \\times 3 = 24\\)회의 정수 곱셈이 필요하며, 그 결과 \\(2 \\times 3\\) 행렬이 만들어진다.\n\\(2 \\times 3\\) 행렬 \\(\\textbf{A}\\textbf{B}\\)와 \\(3 \\times 5\\) 행렬 \\(\\textbf{C}\\)를 곱할 때 \\(2 \\times 3 \\times 5 = 30\\)회의 정수 곱셈이 필요하며, 그 결과 \\(2 \\times 5\\) 행렬이 만들어진다.\n따라서 총 \\(24 + 30 = 54\\)회의 정수 곱셈이 필요함을 알 수 있다.\n\n\n\\(\\textbf{A}(\\textbf{B}\\textbf{C})\\)와 같이 계산한다면\r\n\t\n\\(4 \\times 3\\) 행렬 \\(\\textbf{B}\\)와 \\(3 \\times 5\\) 행렬 \\(\\textbf{C}\\)를 곱할 때 \\(4 \\times 3 \\times 5 = 60\\)회의 정수 곱셈이 필요하며, 그 결과 \\(4 \\times 5\\) 행렬이 만들어진다.\n\\(2 \\times 4\\) 행렬 \\(\\textbf{A}\\)와 \\(4 \\times 5\\) 행렬 \\(\\textbf{B}\\textbf{C}\\)를 곱할 때 \\(2 \\times 4 \\times 5 = 40\\)회의 정수 곱셈이 필요하며, 그 결과 \\(2 \\times 5\\) 행렬이 만들어진다.\n따라서 총 \\(60 + 40 = 100\\)회의 정수 곱셈이 필요함을 알 수 있다.\n\n\n\n3개의 행렬을 곱할 때에도 행렬을 곱하는 순서에 따라 정수 곱셈의 횟수가 달라질 수 있으니, \\(n\\)개의 행렬을 곱할 때 역시 마찬가지임을 쉽게 짐작할 수 있을 것이다. 행렬의 수가 많아지면 많아질수록 행렬을 곱하는 방법의 수는 다양하게 존재한다. 예를 들어 \\(n = 4\\)일 때,  4개의 행렬 \\(\\textbf{M}_{1}, \\textbf{M}_{2}, \\textbf{M}_{3}, \\textbf{M}_{4}\\)을 곱하는 방법에는 아래 5가지가 있다.\n\n\\(\\big((\\textbf{M}_{1}\\textbf{M}_{2})\\textbf{M}_{3}\\big)\\textbf{M}_{4}\\)\n\\(\\big(\\textbf{M}_{1}(\\textbf{M}_{2}\\textbf{M}_{3})\\big)\\textbf{M}_{4}\\)\n\\((\\textbf{M}_{1}\\textbf{M}_{2})(\\textbf{M}_{3}\\textbf{M}_{4})\\)\n\\(\\textbf{M}_{1}\\big((\\textbf{M}_{2}\\textbf{M}_{3})\\textbf{M}_{4}\\big)\\)\n\\(\\textbf{M}_{1}\\big(\\textbf{M}_{2}(\\textbf{M}_{3}\\textbf{M}_{4})\\big)\\)\n\n이렇게 많은 방법들 가운데 어떤 것을 택하더라도 그 결과가 같으므로, 이 방법들 가운데 필요한 정수 곱셈의 수가 가장 적은 것을 택하면 행렬을 곱하는 데 필요한 시간이 최소화될 것이다.\n계산을 좋아하는 승현이는 최근 이와 같은 \\(n\\)개의 행렬의 곱에 대해 배웠는데, 보통 사람은 이해할 수 없는 일이지만 몇몇 예제를 계산해 보더니 곱셈의 매력에 푹 빠지고 말았다. 성분끼리 곱한 것을 모두 더하는 것이 참 아름답다고 하는데, 이해하긴 어렵지만 일단 그렇다고 하자.\n승현이가 정수 곱셈을 하는 데에는 0의 시간이 걸리기 때문에, 승현이는 '행렬을 곱할 때 필요한 정수 곱셈 횟수를 굳이 최소화할 필요가 있을까?' 하는 생각을 하게 되었다. 승현이는 이러한 의문을 품고 선생님께 질문을 하였고, 이에 선생님은 최악의 정수 곱셈 횟수와 최적의 정수 곱셈 횟수 사이의 차가 상당히 커지는 경우가 있기 때문에, 정수 곱셈에 상당한 시간이 걸리는 일반인들에게는 곱셈 횟수를 최소화하는 것이 중요하다고 대답해 주셨다. \"최악/최적의 정수 곱셈 횟수\"라는 것은 행렬을 곱하는 모든 방법들 가운데 필요한 정수 곱셈 횟수가 가장 많은/적은 방법의 정수 곱셈 횟수를 의미한다.\n일반인들의 심정에 전혀 공감할 수 없었던 승현이는 질문을 이어나갔고, 승현이의 질문 공세에 지친 선생님은 결국 모든 자연수 \\(K\\)에 대해, 행렬을 곱하기 위해 필요한 최악의 정수 곱셈 횟수와 최적의 정수 곱셈 횟수의 차이가 정확히 \\(K\\)가 되는 어떤 행렬들 \\(\\textbf{M}_{1}, \\textbf{M}_{2}, \\cdots, \\textbf{M}_{n}\\)이 항상 존재한다고 대답해 주셨다.\n충격을 받은 승현이는 당신에게 혹시 임의의 \\(K\\)를 줄 때 그런 행렬들을 아무 것이나 하나 찾아줄 수 있는지 부탁해왔다.  최악의 곱셈 횟수와 최적의 곱셈 횟수의 차가 \\(K\\)인 어떤 행렬들을 찾아내는 프로그램을 작성하자. \n",
        "input_text": "첫 줄에 정수 K (1 ≤ K ≤ 109)가 주어진다.\n",
        "output_text": "첫 줄에 K를 만족시킬 수 있는 데이터의 행렬 개수 정수 N(1 ≤ N ≤ 100)을 출력한다. 둘째 줄에는 해당 행렬의 정보를 (N+1)개의 정수 a0, a1, .., an로 나타내어 출력한다. 행렬의 크기는 a0 x a1, a1 x a2, .., an-1 x an 이다.\n",
        "memory_median": 1524.0,
        "time_median": 0.0,
        "length_median": 143.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "575": {
        "problem_text": "다음 조건을 만족하는 길이 $N$의 수열 $A=\\left\\{A_{1},A_{2},\\dots,A_{N}\\right\\}$를 출력하시오.\n$1\\leq i<j \\leq N$을 만족하는 모든 정수 $i$와 $j$에 대해서 다음 조건을 만족한다.\n\n$A_{i}\\neq A_{j}$이고 수열 $A$의 모든 원소는 $1$ 이상 $10^{9}$ 이하의 정수이다.\n$A_{i}+A_{j}$는 $A_{i}\\times A_{j}$의 약수가 아니다.\n\n",
        "input_text": "첫째 줄에 수열 $A$의 길이를 나타내는 정수 $N$이 주어진다. $(2\\leq N \\leq 5\\,000)$\n",
        "output_text": "첫째 줄에 조건을 만족하는 수열 $A$의 원소들을 공백으로 구분하여 출력한다.\n위 조건을 만족하는 수열이 여러 개라면 그중 아무거나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 381.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "576": {
        "problem_text": "\r\n\t8*8 체스보드에 8개의 퀸을 서로 공격하지 못하게 놓는 문제는 잘 알려져 있는 문제이다. 퀸은 같은 행, 열, 또는 대각선 위에 있는 말을 공격할 수 있다. 이 문제의 한가지 정답은 아래 그림과 같다.\n\n\n\r\n\t이 문제의 조금 더 일반화된 문제는 Franz Nauck이 1850년에 제기했다.\n\r\n\tN*N 보드에 N개의 퀸을 서로 다른 두 퀸이 공격하지 못하게 놓는 경우의 수는 몇 가지가 있을까?\n\r\n\t이 문제는 N>3인 경우에 경우의 수가 적어도 1개 라는 것이 증명되어 있다. 예를 들어, N=26인 경우에 22317699616364044가지 방법이 있다.\n\r\n\tN이 주어졌을 때, N*N 보드에 N개의 퀸을 서로 다른 두 퀸이 공격하지 못하게 놓는 한가지 경우를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "\r\n\t첫째 줄에 N이 주어진다. N은 8, 26, 213, 2012, 99991, 99999중 하나이다.\n",
        "output_text": "\r\n\tN개의 줄을 출력해야 한다. i번째 줄에는 하나의 정수를 출력해야 하고, 이 정수는 i번째 행에 있는 퀸이 있는 열의 번호이다.\n",
        "memory_median": 2020.0,
        "time_median": 12.0,
        "length_median": 740.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "577": {
        "problem_text": "쿠는 수를 가지고 놀다가 재미있는 계산법이 떠올랐다.\n\n양의 정수 $A$에 대해서, $A$를 $A$의 모든 자릿수에 적힌 수들의 곱으로 바꾼다.\n\n쿠는 위 연산을 어떤 양의 정수 $P$가 한 자리 수가 될 때까지 반복했고, 그 수를 $P$의 바닥수라고 정의했다. 예를 들어, $1234$의 바닥수는 $8$이다. 바닥수를 구하는 과정은 다음과 같다.\n\\[1234\\rightarrow 24(=1\\times 2\\times 3\\times 4)\\rightarrow 8(=2\\times 4)\\]\n\n쿠는 바닥수를 계산하는 데 몰두한 나머지 $P$를 잊고 말았다. 그에게 주어진 단서는 $P$의 자릿수와 $P$의 바닥수이다. 쿠를 대신해 원래 수 $P$를 구해 주자.\n",
        "input_text": "$P$의 바닥수를 나타내는 정수 $N$과, $P$의 자릿수 $L$이 공백으로 구분되어 주어진다. $\\left( 0\\leq N\\leq 9;\\ 2\\leq L\\leq 18 \\right)$\n",
        "output_text": "바닥수가 $N$이 되기 위한 $L$자리 양의 정수 $P$를 출력한다. $P$는 $0$으로 시작하지 않아야 한다. 답이 여러 가지라면 아무거나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 266.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "578": {
        "problem_text": "$N$개의 정점으로 이루어진 트리의 모든 정점 쌍에 대하여, 두 정점 사이의 거리의 합을 최소화하시오. 정점에는 $1$부터 $N$까지 번호가 매겨져 있다.\n즉, 정점 $i$와 정점 $j$ 사이의 거리를 $\\textrm {dist}(i,\\, j)$라 할 때  $\\sum_{1 \\leq i < j \\leq N}^{} \\textrm {dist}(i,\\, j)$가 최소인 트리를 구성해야 한다.\n",
        "input_text": "첫째 줄에 정점의 개수 $N$이 주어진다. $(2\\leq N \\leq 100\\,000)$\n",
        "output_text": "첫째 줄에 모든 정점 쌍에 대하여 두 정점 사이 거리의 합의 최솟값을 출력한다.\n둘째 줄부터 $N-1$개의 줄에 걸쳐, 트리를 이루는 간선의 정보를 출력한다. 각 줄에 간선이 연결하는 두 정점의 번호를 공백을 사이에 두고 출력한다.\n조건을 만족하는 트리가 여럿이라면 아무거나 하나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 16.0,
        "length_median": 295.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "579": {
        "problem_text": "지구이는 std::sort에 무한한 신뢰를 가지고 있다. 빠른 정렬 알고리즘을 직접 구현하기 위해서는 적어도 20줄 넘게 코딩해야 하지만, std::sort는 한 줄이면 끝나기 때문이다. 구조체 배열에 쓰기 위해서는 부등호 연산을 정의하는 등의 추가 구현이 필요하지만, 그 정도의 단점은 직접 구현해야하는 것에 비하면 아무것도 아니었다.\n그런 이유에서 S.M.T를 매일 외치며 코딩을 하는 지구이는 어느 날 이유를 알 수 없는 “틀렸습니다”를 받게 되었다. 문제는 매우 간단하다.\n“평면의 x ≥ 0, y ≥ 0 부분에 점 N개가 있다. 이 점들을 다음과 같은 조건을 만족하도록 정렬하시오. 모든 i < j에 대해, i번째 점 (xi, yi)와 j번째 점 (xj, yj)는 xi * yj ≤ xj * yi 를 만족한다.”\n지구이는 문제의 조건을 오퍼레이터로 정의하여 std::sort로 정렬했지만, 틀리고 말았다. 코드에 std::sort밖에 없는데도 계속 틀리는 지구이는 데이터를 열심히 넣어봤지만, 결국 반례데이터를 찾지 못했다.\n지구이를 도와 코드의 반례데이터를 찾아주자!\n지구이의 코드는 여기에 있다.\n",
        "input_text": "입력은 없다.\n",
        "output_text": "첫 번째 줄에 점의 개수 N (2 ≤ N ≤ 1000)을 출력한다.\n두 번째 줄부터 N개의 줄에 x좌표, y좌표를 각각 출력한다. (0 ≤ x ≤ 1000, 0 ≤ y ≤ 1000)\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 417.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "580": {
        "problem_text": "코코는 $0$부터 $9$까지의 숫자가 새겨진 초콜릿을 많이 갖고 있다. 코코는 이 초콜릿을 가지고 큰 수를 만들어서 한별이에게 선물하려고 한다.\n코코는 한별이가 팰린드롬 수, 특히 $11$을 좋아한다는 사실을 알고 있기 때문에, $11$의 배수인 팰린드롬 수를 만들고 싶다. 팰린드롬 수는 왼쪽에서 오른쪽으로 읽은 것과 오른쪽에서 왼쪽으로 읽은 것이 서로 같은 수를 말한다. 예를 들어, $9$, $11$, $4774$, $13531$은 팰린드롬 수이고, $1232$, $1100$은 팰린드롬 수가 아니다.\n코코를 도와 $11$의 배수이면서 팰린드롬인 $N$자리의 음이 아닌 정수를 하나 찾아주자. 각 숫자가 새겨진 초콜릿은 충분히 많다고 가정한다. $0$을 제외한 수는 숫자 $0$으로 시작할 수 없다.\n",
        "input_text": "첫 번째 줄에는 테스트 케이스의 개수 $T$가 주어진다. $(1\\le T\\le 100)$\n각 테스트 케이스에 대해, 양의 정수 $N$이 한 줄에 주어진다. $(1\\le N\\le 10\\, 000)$\n",
        "output_text": "각 테스트 케이스에 대해, $11$의 배수이면서 팰린드롬인 $N$자리의 음이 아닌 정수를 한 줄에 출력한다. 답이 여러 가지라면 아무거나 출력한다. 그러한 수가 없으면 -1을 대신 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 28.0,
        "length_median": 581.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "581": {
        "problem_text": "길이가 \\(N\\)인 SW 수열은 다음 두 조건에 맞는 수열이다.\n\nSW 수열은 \\(1\\) 이상 \\(N\\) 이하의 정수로 이루어져 있고, 모든 원소는 서로 다르다.\n수열 \\(A\\)가 SW 수열이라고 하자. \\(2 \\leq i \\leq N - 1\\)인 정수 \\(i\\)에 대해, \\(\\left|A_i - A_{i-1}\\right| > \\left|A_{i+1} - A_i\\right|\\)이다.\n\n길이가 \\(N\\)인 SW 수열을 아무거나 하나 구해보자. 주어지는 모든 입력에 대해 SW 수열은 항상 존재한다.\n",
        "input_text": "첫째 줄에 구하고자 하는 SW 수열의 길이 \\(N\\)이 주어진다. \\((3 \\leq N \\leq 5\\ 000)\\)\n",
        "output_text": "첫째 줄에 길이가 \\(N\\)인 SW 수열을 아무거나 하나 출력한다. SW 수열은 공백으로 구분해서 출력해야 한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 357.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "582": {
        "problem_text": "일직선으로 다양한 높이의 건물들이 N개 존재합니다. 가희는 건물들의 왼쪽에, 단비는 건물들의 오른쪽에 있습니다. 일직선 상에 가희와 단비, 건물들은 아래와 같은 순서로 배치되어 있습니다.\n\n가희의 오른쪽에는 1번 건물이 있습니다.\nx가 1이상 N-1이하의 정수일 때, x번 건물의 오른쪽에는 x+1번 건물이 있습니다.\nN번 건물의 오른쪽에는 단비가 있습니다.\n\n가희와 단비가 볼 수 있는 건물은 아래와 같습니다.\n\n가희는 1번 건물을 볼 수 있습니다.\nk번 건물보다 왼쪽에 있는 건물들이 모두 k번 건물보다 높이가 낮다면, 가희는 k번 건물을 볼 수 있습니다.\n단비는 N번 건물을 볼 수 있습니다.\nk번 건물보다 오른쪽에 있는 건물들이 모두 k번 건물보다 높이가 낮다면, 단비는 k번 건물을 볼 수 있습니다.\n\n예를 들어, N이 3이고, 1번 건물의 높이가 1, 2번 건물의 높이가 3, 3번 건물의 높이가 2라고 하겠습니다.\n\n[그림 1] 가희와 단비, 그리고 건물들의 배치\n가희가 볼 수 있는 건물과 단비가 볼 수 있는 건물의 수는 각각 2개입니다. 이를 각각 노란색, 연보라색으로 표시하겠습니다.\n  \n[좌] 가희가 볼 수 있는 건물 [우] 단비가 볼 수 있는 건물\n가희가 3번 건물을 볼 수 없는 이유는 3번 건물 왼쪽에 있는 2번 건물의 높이가 3번 건물보다 높기 때문입니다. 그리고, 단비가 1번 건물을 볼 수 없는 이유는 1번 건물보다 오른쪽에 있는 2번 건물과 3번 건물이 1번 건물보다 높기 때문입니다.\n가희와 단비 사이에 있는 건물의 개수 N과 가희가 볼 수 있는 건물의 개수 a, 단비가 볼 수 있는 건물의 개수 b가 주어집니다. 사전 순으로 가장 앞서는 N개의 건물 높이 정보를 출력해 주세요.\n",
        "input_text": "첫째 줄에 건물의 개수 N, 가희가 볼 수 있는 건물의 개수 a, 단비가 볼 수 있는 건물의 개수 b가 공백으로 구분해서 주어집니다.\n",
        "output_text": "문제의 조건에 맞는 건물들의 높이 정보가 1개 이상 존재하는 경우 N개의 건물 높이 정보 중 사전순으로 가장 앞선 것을 출력해 주세요. 출력 형식은 다음을 만족해야 합니다.\n\n1번 건물, ... , N번 건물의 높이를 공백으로 구분해서 출력해 주세요. 출력하는 수들이 모두 다를 필요는 없습니다.\n높이는 1보다 크거나 같은 정수여야 합니다.\n\n문제의 조건에 맞는 건물들의 높이 정보가 존재하지 않으면 첫 줄에 -1을 출력해 주세요.\n",
        "memory_median": 2420.0,
        "time_median": 12.0,
        "length_median": 878.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "583": {
        "problem_text": "그린-타오 정리(Green–Tao theorem)[1]는 소수 집합이 임의 길이의 등차수열을 포함한다는 정리로, 2004년에 Ben Green과 Terence Tao가 증명했다. 실제로는 이보다 조금 더 강력한 다음 명제를 증명한다:\n소수 집합의 부분집합인 $A$가\n$$\\limsup\\limits_{N\\rightarrow\\infty} \\frac{\\left| A \\cap [1, N] \\right|}{\\pi(N)} > 0$$\n을 만족한다면, 모든 양의 정수 $k$에 대해 $A$가 길이 $k$인 등차수열을 무한히 많이 포함한다. 특히 $A$를 소수 집합 전체로 놓으면 소수 집합이 임의 길이의 등차수열을 포함한다.\n그린-타오 정리는 세메레디의 정리(Szemerédi's theorem)[2]의 확장이라고 할 수 있다. 세메레디의 정리는 다음과 같다:\n자연수 집합의 부분집합인 $A$가\n$$\\limsup\\limits_{N\\rightarrow\\infty} \\frac{\\left| A \\cap [1, N] \\right|}{N} > 0$$\n을 만족한다면, 모든 양의 정수 $k$에 대해 $A$가 길이 $k$인 등차수열을 무한히 많이 포함한다.\n그린-타오 정리를 세메레디의 정리로부터 바로 유도할 수는 없다. 소수의 집합은 자연수에 대해 밀도가 $0$이기 때문이다. 하지만 세메레디의 정리를 확장하여 자연수 집합을 유사 난수와 관련된 특정 조건을 만족하는 집합으로 확장할 수 있고, 이 조건을 만족하면서 소수 집합을 조밀 집합(dense subset)으로 갖는 집합을 구성하여 그린-타오 정리를 증명하게 된다.\n하지만 그린-타오 정리는 실제로 임의 길이의 소수 등차수열을 어떻게 구성하는지는 알려주지 않는다. 이 문제에서는 임의 길이의 소수 등차수열을 직접 구성해야 한다.\n[1] Green, Ben, and Terence Tao. \"The primes contain arbitrarily long arithmetic progressions.\" Annals of mathematics (2008): 481-547.\n[2] Szemerédi, Endre. \"On sets of integers containing no k elements in arithmetic progression.\" Acta Arith 27.299-345 (1975): 21.\n",
        "input_text": "첫째 줄에 자연수 $n$이 주어진다.\n",
        "output_text": "첫째 줄에 길이가 $n$이고 $3\\,825\\,123\\,056\\,546\\,413\\,051$ 이하의 소수로만 이루어진 등차수열을 출력한다.\n만약 그러한 등차수열이 없으면 대신 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 187.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "584": {
        "problem_text": "다음 두 조건에 맞는 길이가 $N$인 수열을 아무거나 하나 구해서 출력해보자. \n\n수열의 모든 원소는 서로 다르고, 수열의 원소는 $1$ 이상 $100\\,000$ 이하인 정수다.\n수열의 연속한 부분 수열 중에, 길이가 $k$인 모든 연속한 부분 수열의 합은 $k$로 나누어떨어진다. \n\n",
        "input_text": "첫째 줄에 수열의 길이 $N$($1 \\le N \\le 5\\,000$)이 주어진다.\n",
        "output_text": "첫째 줄에 문제 조건에 맞는 길이 $N$인 수열을 아무거나 하나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 226.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "585": {
        "problem_text": "Alongside being a palindrome, Nadan is also a successful businessman who finances young software developers when they start working on their projects. This year, he decided to distribute K kunas (Croatian currency) to N projects in a way that each project gets at least one kuna and all projects get a different amounts of kunas. This will always be possible.\nWrite a program which will, for a given N and K, find one possible distribution of K kunas to N projects.\n",
        "input_text": "The first line contains a positive integer K (100 ≤ K ≤ 1 000 000), number from the task description. The second line contains a positive integer N (1 ≤ N ≤ 100), number from the task description.\n",
        "output_text": "For a chosen money distribution, output the amount of money the first project will get in the first line, the amount of money the second project will get in the second line and so on until the N-th line where you should output the amount of money the N-th project will get.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 269.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "586": {
        "problem_text": "길이가 $N$인 동가수열은 다음 두 조건을 만족하는 수열이다.\n\n동가수열은 $1$ 이상 $N$ 이하인 정수로 이루어져 있고, 모든 원소는 서로 다르다.\n동가수열의 서로 이웃한 원소의 차는 $\\lfloor \\frac{N}{2} \\rfloor$이상이다.\n\n길이가 $N$인 동가수열을 아무거나 하나 구해보자. 주어지는 모든 입력에 대해 동가수열은 항상 존재한다.\n",
        "input_text": "첫째 줄에 구하고자 하는 동가수열의 길이 $N$($1 \\le N \\le 5\\,000$)이 주어진다.\n",
        "output_text": "첫째 줄에 길이가 $N$인 동가수열을 아무거나 하나 출력한다. 동가수열은 공백으로 구분해서 출력해야 한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 383.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "587": {
        "problem_text": "수학과 전공과목인 조합론을 수강하는 정휘는 등차수열의 합 공식에 대해 배우고 있다. 2023 SCON 대회 개최가 일주일 남았지만, 아직 문제를 절반도 만들지 못해 발등에 불이 떨어진 정휘는 화장실에 가는 척을 하면서 정보과학관에 달려와 등차수열에 관한 문제를 만들었다.\n길이가 $N$인 수열 $A$가 주어졌을 때, $1\\le i\\le N$에 대해 $A_i=B_i+C_i$를 만족하고 길이가 $N$인 두 등차수열 $B,C$를 구하라.\n등차수열의 정의는 다음과 같다.\n\n어떤 수열 $A=\\left\\{ A_1,A_2,\\cdots ,A_N \\right\\}$이 등차수열이라는 것은, $2\\leq i\\leq N$인 모든 $i$에 대해 $A_i-A_{i-1}$이 모두 동일한 수열을 말한다. 정의에 따라 길이가 $2$ 이하인 수열은 항상 등차수열이다.\n\n",
        "input_text": "첫째 줄에 수열 $A$의 길이 $N$이 주어진다.\n둘째 줄에 수열 $A$의 원소 $A_1,A_2,\\cdots ,A_N$이 순서대로 공백으로 구분되어 주어진다.\n",
        "output_text": "만약 모든 $1\\leq i\\leq N$에 대해 $A_i=B_i+C_i$인 길이가 $N$인 두 등차수열 $B,C$가 존재하지 않으면 첫째 줄에 NO를 출력한다.\n그렇지 않으면 첫째 줄에 YES를 출력한다. 이후 둘째 줄에 $B$의 원소를, 셋째 줄에 $C$의 원소를 차례대로 공백으로 구분해서 출력한다. 가능한 수열 $B,C$가 여럿인 경우, 아무거나 하나만 출력한다. 수열 $B,C$가 존재할 경우, 문제의 제한을 만족하는 출력이 존재한다는 것을 증명할 수 있다.\n",
        "memory_median": 2412.0,
        "time_median": 40.0,
        "length_median": 647.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "588": {
        "problem_text": "당신은 $30 \\times 30$ 크기의 표에 0 이상 $10^6$ 이하의 정수를 채워야 한다.\n다음을 만족하는 정수 $i$를 찾을 수 있다고 하자. 표에 존재하는 $(\\frac{30 \\times 31}{2})^2$개의 직사각형 중, 그 안에 쓰인 수들의 합이 정확히 $i$인 것이 존재한다.\n당신의 목표는 1부터 50000까지의 수들을 찾을 수 있게 하는 것이다. 이 조건을 만족하는 표를 찾아 출력하자.\n",
        "input_text": "이 문제는 입력이 없다.\n",
        "output_text": "당신이 만든 표에 적힌 수를 한 줄에 30개씩, 30줄로 출력하여라. 정확한 형식은 예제 출력을 참고하자.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 479.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "589": {
        "problem_text": "승민이는 동물원의 원숭이들을 관리하는 사육사입니다. 이 동물원에는 N마리의 원숭이들이 있고 원숭이들에게 1번부터 N번까지 번호를 붙였습니다.\n7일간 동물원에서 원숭이들끼리 스포츠 경기를 진행하는 이벤트를 열게 되었습니다. 경기는 A팀과 B팀으로 나뉘어 하루에 한 번 진행되며 모든 원숭이는 경기에 참여해야 하지만 팀원의 수는 달라도 괜찮습니다. 단, 각 팀에는 최소 한 마리의 원숭이가 있어야 합니다.\n승민이는 원숭이들끼리 너무 친해지는 것을 막기 위해 모든 두 원숭이에 대해서 적어도 한번은 적으로 만나도록 대진표를 구성하고 싶어합니다. 승민이를 도와 경기 대진표를 짜주세요.\n",
        "input_text": "첫 번째 줄에 원숭이의 수를 나타내는 정수 N (2 ≤ N ≤ 99) 가 주어집니다.\n",
        "output_text": "일곱 개의 줄에 팀의 구성을 출력합니다.\ni (1 ≤ i ≤ 7) 번째 줄에는 길이가 N이고 문자 'A' 또는 문자 'B'로 만 구성된 문자열을 출력합니다. i번째 문자열의 j번째 문자는 i번째 날 j번 원숭이가 속한 팀을 나타냅니다. \n문제에서 설명한 방식대로 팀을 구성하는 대진표가 여러 개 있다면 그 중 한 개만 출력합니다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 725.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "590": {
        "problem_text": "정휘는 영어 시험에서 배점이 큰 서술형 문제의 답안을 apple 대신 aple이라고 써서 틀렸다. 한 글자 차이로 큰 점수를 잃은 정휘는 이런 채점 방식이 합리적이지 않다고 생각해서 선생님께 새로운 채점 기준을 제안하기로 했다.\n정휘는 응시자가 작성한 답안과 실제 정답의 \"최장 공통 부분 수열\"의 길이에 비례하게 점수를 주는 방식을 제안했다. 만약 정답이 apple인 문제에 aple을 적어서 내면 배점의 80%를 얻을 수 있고, apple을 적어서 내면 문제의 점수를 온전하게 받을 수 있다. 하지만 선생님은 정답을 구성하는 알파벳과 정답의 길이만 알면, 동일한 단어로 모든 문제를 풀 수 있는 문자열이 존재함을 지적하며 이 방식을 거절했다. 예를 들어 정답의 길이가 2이고 정답에 a와 b만 들어갈 수 있다면, abba를 이용해 모든 문제를 풀 수 있다.\n선생님이 거절하신 이유를 납득하지 못한 정휘는, 정답을 구성하는 알파벳들과 정답의 길이가 주어졌을 때 모든 답안에 대해 만점을 받을 수 있는 가장 짧은 문자열을 직접 만들어보기로 했다.\n최장 공통 부분 수열이 무엇인지 잘 모르는 친구들은 친절한 준서가 준비한 아래 정의를 읽어보도록 하자. 알파벳을 수라고 생각하면 문자열도 수열이다.\n\n부분 수열이란 주어진 수열에서 1개 이상의 원소를 골라 원래 순서대로 나열하여 얻은 수열을 말한다.\n두 수열 $A, B$의 공통 부분 수열이란 $A$의 부분 수열이면서 동시에 $B$의 부분 수열인 수열을 말한다.\n두 수열 $A, B$의 최장 공통 부분 수열이란 $A, B$의 공통 부분 수열 중 가장 긴 수열을 말한다.\n예를 들어, appl와 aple의 최장 공통 부분 수열은 apl이다.\n\n",
        "input_text": "첫째 줄에 정답의 길이 $N$이 주어진다. ($1 \\leq N \\leq 10\\,000$)\n둘째 줄에 정답을 구성하는 알파벳이 공백 없이 소문자로 주어진다. 각 알파벳은 최대 한 번 주어진다.\n",
        "output_text": "모든 답안에 대해 만점을 받을 수 있는 가장 짧은 문자열을 출력한다.\n가능한 가장 짧은 문자열이 여러 가지인 경우 아무거나 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 220.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "591": {
        "problem_text": "완전 이진 트리의 각 노드는 계측적인 구조로 이루어져 있다. 루트 노드의 레벨은 0이며, 레벨 1의 두 자식 노드를 가지고 있다. 또, 레벨 1의 자식 노드의 레벨은 2이다.\n보통 레벨이 N인 완전 이진 트리는 2N-1개의 노드를 가지고 있다. 레벨이 N-1이 아닌 모든 노드는 자식 노드를 두 개씩 가지고 있다.\n1부터 2N-1까지 숫자를 레벨이 N인 완전 이진 트리의 각 노드에 적을 수 있다. 이때, 레벨이 D인 각각의 노드에 대해서 왼쪽 서브트리에 쓰여 있는 숫자의 합과 오른쪽 서브트리에 쓰여 있는 숫자의 합의 차이는 2D라는 조건을 만족해야 한다.\n예를 들어, 루트의 왼쪽 서브 트리의 합과 오른쪽 서브 트리의 합의 차이는 1이어야 하며, 레벨이 1인 경우에는 2이어야 한다. 또, 모든 숫자는 한 번씩 사용해야 한다.\nN이 주어졌을 때, 문제의 조건에 맞게 완전 이진 트리의 각 노드에 숫자를 정하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 트리의 레벨인 N이 주어진다. (1 ≤ N ≤ 15)\n",
        "output_text": "첫째 줄에 문제의 조건에 맞게 숫자를 채운 완전 이진 트리를 프리오더로 순회한 결과를 출력한다.\n",
        "memory_median": 2172.0,
        "time_median": 4.0,
        "length_median": 819.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "592": {
        "problem_text": "UCPC가 작년에 이어 올해도 온라인으로 열리는 것이 아쉬웠던 청한이는 평행우주를 뒤져서 평소처럼 모두가 한 곳에 모여 대회를 치르는 세계를 찾아냈다. 청한이는 이 세계의 시상식에서 성대한 경품 추첨 행사를 열기로 했다.\n행사가 진행되는 무대에는 $K$개의 상자가 놓여 있고, 각 상자에는 수가 적혀 있는 공이 $N$개씩 들어 있다. 진행자는 우선 그중 두 개의 상자를 골라서 탁자 위에 올려놓는다. 그리고 두 상자에서 공을 하나씩 뽑고, 두 공에 적힌 수의 합을 당첨 번호로 부른다.\n청한이는 추첨을 할 때 당첨 번호가 되도록 다양하게 나와서 더 많은 참가자들에게 당첨 기회가 주어지기를 원한다. 따라서 진행자가 어떤 두 상자를 고르더라도, 두 개의 공을 뽑는 총 $N^2$가지의 모든 경우에 대해 두 공에 적힌 수의 합이 모두 다르게 나오도록 하려고 한다. 청한이를 도와서 이 조건이 만족되도록 상자들을 구성해 주자.\n",
        "input_text": "첫 번째 줄에 상자의 개수를 나타내는 정수 $K$($2 \\leq K \\leq 30$)와 각 상자에 들어 있는 공의 개수를 나타내는 정수 $N$($2 \\leq N \\leq 2\\ 000$)이 공백을 사이에 두고 주어진다.\n",
        "output_text": "$K$개의 줄에 걸쳐, 각 줄에 각 상자에 들어 있는 공들에 적을 $N$개의 정수를 공백으로 구분하여 출력한다.\n단, 공에는 $1$ 이상 $5\\ 000\\ 000$ 이하의 정수만을 적을 수 있으며, 가능한 모든 입력에 대해 조건을 만족하는 구성이 존재함이 보장된다.\n",
        "memory_median": 2020.0,
        "time_median": 8.0,
        "length_median": 641.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "593": {
        "problem_text": "도훈이네 부대의 전화기에는 착신 전환이라는 기능이 있다. 착신 전환이란 전화기에 걸려 오는 전화를 다른 전화기로 대신 연결하는 기능이다. 가령, 전화기 $A$가 전화기 $B$로 착신 전환을 했다면, 누군가가 전화기 $A$에 전화를 걸었을 때 전화기 $B$에 전화가 걸려 오게 된다. 착신 전환은 전화기마다 최대 하나의 전화기로만 설정할 수 있다.\n그러나 해당 기능에는 큰 문제가 있는데, 착신 전환이 꼬이게 되면 일부 전화기가 먹통이 된다는 것이다! 예를 들어, 전화기 $A$가 전화기 $B$로, 전화기 $B$가 전화기 $C$로 착신 전환을 걸어 둔 상태에서 전화기 $C$가 전화기 $A$에 착신 전환을 걸어 두면 세 전화기 중 어떤 전화기에 전화를 걸어도 신호 대기 상태가 무한히 유지되며, 세 전화기 모두 먹통이 된다.\n이 사실에 깊게 감명받은 도훈이는, 일부 전화기들의 착신 전환 상태를 바꿔 부대 내의 전화기 모두를 먹통으로 만들려는 사악한 계획을 세웠다! 부대 내에는 $1$번부터 $N$번까지 총 $N$대의 전화기가 있으며, 각 전화기는 $a_i$번 전화기로 착신 전환이 되어 있는 상태이다. 만약 $a_i = i$라면, $i$번 전화기에는 착신 전환이 걸려 있지 않은 상태임을 의미한다.\n하지만 전화기들의 착신 전환 상태를 너무 많이 바꾸면 간부님께 걸릴 것이 분명하므로, 착신 전환 상태를 바꿀 전화기 개수를 최소로 해야 한다. 도훈이를 위해, 착신 전환 상태를 바꿔야 하는 최소 전화기 개수와 착신 전환 상태를 어떻게 바꿔야 하는지 구해 주자. 만약 가능한 착신 전환 상태가 여러 가지라면, 그중 아무거나 구해 주자. 모든 전화를 먹통으로 만드는 것이 항상 가능함을 증명할 수 있다.\n",
        "input_text": "첫 번째 줄에 부대 내 전화기의 대수 $N$이 주어진다. $(2\\leq N\\leq 100\\,000)$\n두 번째 줄에 각 전화기가 착신 전환으로 연결되어 있는 전화기의 번호를 의미하는 $N$개의 정수 $a_1,\\cdots,a_N$이 공백으로 구분되어 주어진다. $(1\\leq a_i\\leq N)$\n이때, $a_i = i$라면 $i$번 전화기는 착신 전환이 되어 있지 않음을 의미한다.\n",
        "output_text": "첫 번째 줄에 모든 전화를 먹통으로 만들기 위해 착신 전환 상태를 바꿔야 하는 최소 전화기 개수를 출력한다.\n두 번째 줄에 착신 전환 상태를 바꾼 이후 각 전화기의 착신 전환 상태를 의미하는 $N$개의 정수 $b_1, \\cdots, b_N$을 출력한다. 만약 가능한 착신 전환 상태가 여러 가지라면, 그중 아무거나 출력한다.\n",
        "memory_median": 2416.0,
        "time_median": 20.0,
        "length_median": 594.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "594": {
        "problem_text": "지구이는 우연히 오일러 프로젝트에서 100억 정도의 매우 큰 숫자가 소수인지 판별해야만 풀리는 문제를 보게 되었다. 지구이는 2부터 sqrt(N) 까지 모든 숫자로 나누는 방법으로 코딩했지만, 1시간이 지나도 결과가 나오지 않았다. 결국 구글신에게 물어본 결과 “페르마 소정리”를 찾을 수 있었다. 페르마 소정리는 다음과 같다.\n“소수 p와 (a, p) = 1인 모든 자연수 a에 대하여, a(p-1) ≡ 1 (mod p)이다.”\n지구이는 이것을 응용해서 n이 소수인지 확인하기 위해 2(n-1) ≡ 1 (mod n)이면 소수라고 판별하기로 했다. 하지만 지구이의 코드는 561을 소수로 분류했고, 결국 또 틀리고 말았다. 이대로 포기할 수 없었던 지구이는 이것을 응용해서 2부터 500까지의 모든 숫자 a에 대하여 a(n-1) ≡ 1 (mod n)을 만족할 때만 소수로 판별하기로 했다. 백만까지 컴퓨터로 확인을 해본 지구이는 자신만만하게 답을 제출했지만, 빨간 X표시가 반겨줄 뿐이었다.\n지구이에게 반례 데이터를 알려주자!\n지구이의 소수판별 코드는 여기에 있다.\n",
        "input_text": "입력은 없다.\n",
        "output_text": "첫 번째 줄에 자연수 n(500 < n ≤ 1015)과 n의 소인수 m (1 < m < n)을 출력한다.\n출력 예시는 답이 아님에 주의하라.\n",
        "memory_median": 1782.0,
        "time_median": 0.0,
        "length_median": 127.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "595": {
        "problem_text": "화학 실험을 하던 윤이는 일렬로 나열해 놓은 $N$개의 시험관에서 재밌는 특징을 발견했다. 그 특징은 모든 이웃한 시험관 쌍에 대해, 두 시험관에 들어 있는 시약의 색깔이 서로 다르다는 점이었다. 흥미롭다고 느낀 윤이는 실험보고서에 이 사실과 함께 각 색깔별 시약의 수를 적었다. 하지만 보고서를 채점하던 조교 원이는 윤이가 색깔별 시약의 수를 제대로 적었는지 의문이 들었다. 윤이의 보고서와 일치하도록 시험관을 배열할 수 있는지 판별하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 시험관의 개수 $N$과 색깔의 종류 수 $K$가 공백을 사이에 두고 주어진다.\n두 번째 줄에 $K$개의 양의 정수 $c_i$가 공백을 사이에 두고 주어진다. 각 색깔에는 번호가 붙어 있으며, $c_i$는 $i$번 색깔의 시약이 담긴 시험관의 개수이다. $(1≤i≤K)$\n",
        "output_text": "조건을 만족하는 시험관 배열을 만들 수 있으면, 시험관의 색깔 번호를 공백으로 구분하여 순서대로 출력한다. 답이 여러 개이면 아무 거나 출력한다.\n조건을 만족하는 시험관 배열을 만들 수 없으면 $-1$을 출력한다.\n",
        "memory_median": 9480.0,
        "time_median": 80.0,
        "length_median": 937.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "596": {
        "problem_text": "체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. 다음 그림과 같은 $5\\times5$ 정사각형 체스판 위의 B라고 표시된 곳에 비숍이 있을 때, 비숍은 대각선 방향으로 움직여 X로 표시된 칸에 있는 다른 말을 잡을 수 있다.\n\n$N$-Maximum Bishop 문제는 $N \\times N$ 체스판 위에 최대한 많은 비숍을 서로 공격할 수 없도록 배치하는 문제다.\n$N$이 주어졌을 때, 최대한 많은 비숍을 서로 공격할 수 없도록 배치해보자.\n",
        "input_text": "첫째 줄에 N이 주어진다. ($1 \\leq N \\leq 524\\,288$)\n",
        "output_text": "배치할 수 있는 비숍의 최대 개수 $M$을 첫 번째 줄에 출력한다. 이후 $M$개의 줄에 걸쳐 비숍을 배치해야 하는 행의 번호와 열의 번호를 공백으로 구분해서 출력한다. 행과 열의 번호는 $1$부터 시작한다.\n답이 여러 개인 경우에는 그중 아무거나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 188.0,
        "length_median": 424.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "597": {
        "problem_text": "KOI 동물원에는 N마리의 원숭이가 있고, 이 원숭이들을 수용할 수 있는 두 개의 큰 우리가 있다. 모든 원숭이들은 1부터 N까지의 번호가 매겨져 있다.\n원숭이들 사이에는 유달리 서로 앙숙관계인 원숭이들이 있어서 같은 우리에 두었을 경우 서로 싸우는 경우가 많다. 두 원숭이 x와 y가 앙숙관계라는 것은 두 원숭이 x, y가 서로 싫어하는 관계임을 의미한다. 또한, 각각의 한 원숭이에 대해 앙숙관계에 있는 원숭이들의 수는 기껏해야 세 마리라고 가정한다. 동물원에서는 원숭이들의 앙숙관계를 조사하여 아래의 두 조건을 만족하도록 원숭이들을 두 개의 우리에 나누어 수용하려고 한다. \n(조건 1) 각 원숭이에 대해 같은 우리 안에 있으며 앙숙관계인 원숭이는 한 마리 이하이다.\n(조건 2) 비어있는 우리는 없다. (즉, 하나의 우리에 원숭이를 모두 수용 가능한 경우가 있더라도 각각의 우리에는 적어도 한 마리 이상의 원숭이를 수용하여야 한다.)\n예를 들어, N=5 인 경우에 1번 원숭이는 {2, 3, 4}와 2는 {1, 3, 5}와 앙숙관계이고, 그리고 3은 {1, 2, 4}와 4는 {1, 3, 5}, 그리고 5는 {2, 4}와 앙숙관계라고 하자. 위의 조건을 만족하도록 원숭이들을 두 개의 우리로 나누려면 {1, 3, 5}를 하나의 우리에, 그리고 {2, 4}를 다른 우리에 수용하면 된다.\n원숭이들의 수와 각 원숭이들의 앙숙관계가 입력으로 주어질 때, 위의 조건을 만족하도록 원숭이들을 두 개의 우리에 나누어 수용하는 프로그램을 작성하시오. \n",
        "input_text": "첫째 줄에는 원숭이들의 수를 나타내는 하나의 정수 N이 주어진다. 단, N은 3이상 100,000이하의 정수이다. 둘째 줄부터 N개의 줄에는 1번부터 번호순서대로 각 원숭이에 대해 앙숙관계에 있는 원숭이의 수 M이 주어지고, 이어서 각 원숭이 번호 M개가 오름차순으로 하나의 줄에 주어진다. 모든 정수들 사이에는 빈칸이 있다. 조건에 맞도록 원숭이들을 나누지 못하는 경우는 존재하지 않는다.\n",
        "output_text": "첫째 줄에는 하나의 우리에 수용되는 원숭이의 수와 원숭이들의 번호를 빈칸을 사이에 두고 임의의 순서대로 출력하고, 둘째 줄에는 또 다른 하나의 우리에 수용되는 원숭이의 수와 원숭이들의 번호를 빈칸을 사이에 두고 임의의 순서대로 출력한다. 만약, 조건에 맞게 원숭이들을 수용하는 경우가 여러 개일 경우에는 그 중의 하나를 출력한다. \n",
        "memory_median": 7872.0,
        "time_median": 80.0,
        "length_median": 1162.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "598": {
        "problem_text": "학교 프로그래밍 시간에 버블 정렬을 배운 정연이는 버블 정렬을 써먹기 위해 백준에서 정렬 문제를 도전했다. 문제는 아래와 같았다.\n”$N$개의 수를 담은 수열 $A_0$, $A_1$, $\\cdots$, $A_{N-1}$이 주어질 때 이를 오름차순으로 정렬하는 프로그램을 작성하시오.” \n정연이는 자신의 코드가 완벽하다고 생각한 후 제출했지만, 아쉽게도 ’틀렸습니다’를 받았다. 정연이가 작성한 버블정렬 코드는 다음과 같다.\n\r\nfor (int i = N - 1; i > 0; i--) {\r\n    for (int j = i - 1; j >= 0; j--) {\r\n        if (A[j] > A[j + 1]) {\r\n            int tmp = A[j];\r\n            A[j] = A[j + 1];\r\n            A[j + 1] = tmp;\r\n        }\r\n    }\r\n}\n수의 개수 $N$이 주어질 때, 정연이가 짠 코드의 반례가 될 입력을 만들어 보자. 구체적으로, 당신은 정연이가 짠 코드의 반례가 될 길이 $N$의 수열 $A$를 만들어야 한다. 이때, $A$의 모든 원소는 $0$ 이상 $10\\,000$ 이하의 정수여야 하고, 정연이가 작성한 코드가 여러분이 출력한 $N$개의 수를 올바르게 정렬할 수 없어야 한다.\n입력 조건을 만족하는 모든 $N$에 대해 이 조건을 만족하는 수열이 존재함을 증명할 수 있으며, 가능한 수열이 여러 가지라면 그 중 아무거나 출력한다.\n",
        "input_text": "첫째 줄에 정수 $N$이 주어진다.\n",
        "output_text": "첫째 줄에 문제의 조건을 만족시키는 $N$개의 정수 $A_{0}$, $A_{1}$, $\\cdots$, $A_{N-1}$을 공백으로 구분하여 출력하라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 232.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "599": {
        "problem_text": "승현이가 일하는 햄버거 가게에는 요리 재료로 사용할 햄버거 패티가 $A$개, 슬라이스 치즈가 $B$개 있다. 치즈버거를 만들기 위해서는 패티와 치즈를 각각 한 개 이상 고른 후 햄버거 빵 사이에 패티와 치즈를 번갈아 쌓아야 한다. 단, 패티의 개수는 치즈의 개수보다 정확히 한 개 더 많이 골라야 한다.\n승현이는 치즈버거를 몇 개 만들어서 가게의 요리 재료를 모두 사용하려고 한다. 패티와 치즈를 모두 사용하려면 치즈버거를 각각 어떻게 만들어야 하는지 구해보자.\n",
        "input_text": "첫째 줄에 패티의 개수 $A(2\\leq A\\leq 100)$와 치즈의 개수 $B(1\\leq B\\leq 100)$가 공백으로 구분되어 주어진다.\n",
        "output_text": "첫째 줄에 패티와 치즈 모두 사용하는 방법이 있다면 YES를, 그렇지 않다면 NO를 출력한다.\n패티와 치즈를 모두 사용하는 방법이 있다면 둘째 줄에 만들어야 하는 치즈버거의 개수 $K$를 출력한다. 그 후에, 셋째 줄부터 $K$개의 줄에 치즈버거를 각각 어떻게 만들어야 하는지를 의미하는 문자열 $S$를 출력한다. $i$번째 재료가 패티라면 $i$번째 문자를 a로, 치즈라면 b로 표현한다.\n가능한 정답이 여러 가지라면 아무 것이나 하나 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 535.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "600": {
        "problem_text": "영우는 나코더 신입생들을 환영하기 위해 정성스럽게 입부 환영 카드를 만들었다. 입부 환영 카드에서 소환된 기장 동현이의 환영이 신입생들을 환영할 것이다. 부기장인 이환이는 환영 카드의 색칠을 맡았다. 이환이는 각 카드를 일렬로 줄지어 놓고 빨간색, 초록색, 파란색 중 하나의 색으로 칠하려 한다. 그런데 그중 몇 개의 카드는 영우가 이미 색칠했다. 색칠은 다음 규칙에 따라야 한다.\n\n단조로움을 피하기 위해, 인접한 카드는 서로 다른 색으로 칠해야 한다.\n이미 색칠된 카드에 덧칠할 수 없다.\n카드의 순서를 바꿀 수 없다.\n\n하지만 이환이는 서울과학고등학교 동아리 '싸이컴'의 상훈이와 테트리스 대결을 해야 하기 때문에 환영 카드를 색칠할 시간 따위는 없다. 그러니까 신입생 환영 카드의 색칠은 여러분이 직접 하도록 하자.\n",
        "input_text": "첫째 줄에 카드의 개수를 나타내는 정수 N이 주어진다. 둘째 줄에 N 개의 정수가 공백으로 구분되어 주어진다. i 번째 정수 ai는 i 번째 카드의 색깔을 나타낸다. 1, 2, 3은 각각 빨간색, 초록색, 파란색을 의미하며, 0은 i 번째 카드가 색칠되어 있지 않음을 의미한다.\n",
        "output_text": "유일한 줄에 N 개의 정수를 공백으로 구분하여 출력한다. 각 정수는 1, 2, 3 중 하나여야 하며, 주어진 조건에 맞아야 한다. 가능한 방법이 여러 가지인 경우, 그중 아무거나 출력한다. 만약 모든 조건에 맞는 색칠이 불가능하다면, 유일한 줄에 –1만 출력한다.\n",
        "memory_median": 5928.0,
        "time_median": 142.0,
        "length_median": 807.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "601": {
        "problem_text": "준원이는 정수 $1,2,\\cdots ,N$을 가지고 있다. 준원이는 자신이 가지고 있는 정수를 하루에 하나씩 $N$일에 걸쳐서 현석이에게 선물해 주려고 한다. 그런데, 현석이는 소수를 싫어하기 때문에 현석이가 지금까지 선물 받은 수의 합이 소수가 되는 날이 없도록 해야 한다.\n준원이가 현석이를 만족시키면서 정수 $1,2,\\cdots ,N$을 선물하려면 어떤 순서로 선물해야 하는지 구해보자.\n",
        "input_text": "첫째 줄에 정수 $N(1\\le N\\le 5\\, 000)$이 주어진다.\n",
        "output_text": "첫째 줄에 현석이를 만족시키면서 정수 $1,2,\\cdots ,N$을 선물하는 방법이 있다면 YES를, 그렇지 않다면 NO를 출력한다.\n현석이를 만족시키면서 정수 $1,2,\\cdots ,N$을 선물하는 방법이 있다면 둘째 줄에 $i$번째 수가 $i$번째 날에 선물한 정수가 되도록, 선물 순서를 나타내는 정수 $N$개를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 469.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "602": {
        "problem_text": "링고는 1이상 N이하의 정수가 한 번씩 모두 등장하는 길이가 N인 순열 [p1, p2, ..., pN]을 좋아합니다.\n그 중에서 반전의 개수가 K인 순열을 제일 좋아합니다.\n순열에서 반전이란 i < j 이면서 pi > pj 를 만족하는 (i, j) 쌍을 말합니다.\n예를 들어 순열 [3, 1, 4, 5, 2] 는 길이가 5 이며 반전의 개수는 4개 {(1, 2), (1, 5), (3, 5), (4, 5)} 입니다.\n링고를 위해 링고가 제일 좋아하는 순열을 하나 찾아주세요.\n",
        "input_text": "첫 번째 줄에 N과 K (1 ≤ N ≤ 314,159, 0 ≤ K ≤ N×(N-1)/2) 가 공백을 두고 주어집니다.\n",
        "output_text": "첫 번째 줄에 문제의 조건을 만족하는 p1, p2, ..., pN 을 공백을 사이에 두고 출력합니다.\n만약 그러한 순열이 존재하지 않는다면 첫 번째 줄에 \"-1\" 하나만 출력하고 더 이상 아무것도 출력하지 않아야 합니다.\n만약 그러한 순열이 여러 가지인 경우 하나만 출력합니다.\n",
        "memory_median": 3248.0,
        "time_median": 36.0,
        "length_median": 547.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "603": {
        "problem_text": "순열은 $1$부터 $N$까지 $N$개의 정수가 각각 한 번씩 나오는 수열이다. 예를 들어, $[1]$, $[3, 5, 2, 1, 4]$, $[1, 3, 2]$는 순열이지만, $[2, 3, 2]$, $[4, 3, 1]$, $[0]$은 순열이 아니다.\n순열의 점수는 다음과 같은 방법으로 구한다.\n\n순열의 모든 연속 부분 수열 각각에 대해 원소의 합을 구한다.\n순열의 점수는 (1)에서 구한 모든 값의 합이다.\n\n길이가 $N$인 모든 순열 중에서 점수가 가장 높은 순열을 구해보자. 점수가 가장 높은 순열이 여러 가지라면 그 중 아무거나 하나를 출력한다.\n",
        "input_text": "첫째 줄에 구하고자 하는 순열의 길이 $N$이 주어진다. $(1 \\le N \\le 200\\,000)$\n",
        "output_text": "첫째 줄에 점수가 가장 높은 순열에 해당하는 $N$개의 정수를 공백으로 구분해서 출력한다.\n",
        "memory_median": 2804.0,
        "time_median": 20.0,
        "length_median": 440.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "604": {
        "problem_text": "KSA 학생들은 아래 조건을 만족하는 길이가 $N$인 수열을 좋아한다.\n\n$1, 2, \\cdots, N$이 $A$에 정확히 한 번씩 등장한다.\n임의의 인접한 세 수 $A_{i}$, $A_{i+1}$, $A_{i+2}$에 대해 $|A_{i+1}-A_{i}| = |A_{i+2}-A_{i+1}| \\times 2$ 또는 $|A_{i+1}-A_{i}| = |A_{i+2}-A_{i+1}| \\times 0.5$이다.\n\n정수 $N$이 주어졌을 때, 조건을 만족하는 수열이 존재하는지 판별하고 있다면 아무거나 찾아보자.\n",
        "input_text": "첫 번째 줄에 정수 $N$이 주어진다.\n",
        "output_text": "첫 번째 줄에 조건을 만족하는 수열이 존재한다면 YES, 아니라면 NO를 출력한다.\n만약 그러한 수열이 존재한다면, 두 번째 줄에 $N$개의 정수 $A_{1}, A_{2}, \\cdots, A_{N}$를 출력한다.\n정답이 여러 개 존재한다면 아무거나 출력해도 상관없다.\n",
        "memory_median": 2020.0,
        "time_median": 208.0,
        "length_median": 728.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "605": {
        "problem_text": "$1$부터 $N$까지 서로 다른 정수가 적혀있는 카드를 $N$장 가지고 있다. 각 카드에는 앞면과 뒷면이 존재한다. 카드의 앞면에는 숫자가 적혀있고, 뒷면에는 카드의 무늬가 그려져 있다.\n$N$장의 카드를 원하는 순서대로 앞면이 보이도록 일렬로 배열한다. 이제 아래의 규칙에 따라 카드를 뒤집을 것이다.\n\n 맨 먼저 한 장의 카드를 골라 뒷면으로 뒤집는다.\n 가장 마지막으로 뒤집은 카드에 적힌 번호를 $x$라 하자. 마지막으로 뒤집은 카드에서 왼쪽으로 $x$장 떨어진 앞면 카드 또는 오른쪽으로 $x$장 떨어진 앞면 카드를 뒤집는다. 만약 해당하는 카드가 없으면 뒤집는 과정을 종료한다.\n 2번 단계가 종료될 때까지 뒤집는 과정을 반복한다.\n\n카드의 장수 $N$이 주어질 때, 모든 카드를 뒤집을 수 있도록 배열할 수 있는지 알고 싶다. 따라서 모든 카드를 뒤집을 수 있는 배치가 존재하는지 여부를 출력하고, 그러한 배치가 존재한다면 카드를 배열하는 방법과 뒤집는 순서를 출력해야 한다.\n",
        "input_text": "첫 번째 줄에 카드의 장수 $N$이 주어진다. $(1 \\le N \\le 200\\ 000)$\n",
        "output_text": "첫 번째 줄에 모든 카드를 뒤집을 수 있도록 배열할 수 있는지를 출력해야 한다. 만약 가능하다면 YES, 불가능하다면 NO를 출력해야 한다.\n만약 모든 카드를 뒤집을 수 있도록 배열할 수 있다면, 두 번째 줄에 카드의 배열 $b_1, b_2, ..., b_n$을 출력한다. $b_i$는 $i$번째 카드에 적혀있는 숫자를 의미한다.\n이후 세 번째 줄에 카드를 뒤집는 순서 $c_1, c_2, ..., c_n$을 출력한다. $c_i$는 $i$번째로 뒤집을 카드의 위치를 의미한다.\n만약 가능한 배열 방법 또는 뒤집는 순서가 여러 가지일 경우 가능한 하나만 출력하면 된다.\n",
        "memory_median": 3584.0,
        "time_median": 40.0,
        "length_median": 694.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "606": {
        "problem_text": "Binary heap은 Heap을 구현하는 방법의 하나이며 Complete binary tree 형태로 만들어진다. Complete binary tree는 Binary tree의 종류 중 하나로, 마지막 레벨을 제외한 나머지 레벨에는 노드가 꽉 차 있고 마지막 레벨에는 노드들이 왼쪽으로 쏠려있는 모습을 하고 있다.\n\r\n<그림> Complete binary tree의 예\nComplete binary tree는 1차원 배열을 이용하면 쉽게 구현할 수 있다. Complete binary tree의 각 노드에 아래 그림과 같은 식으로 번호를 붙이고 이를 1차원 배열에서의 index로 삼으면 자연스럽게 구현할 수 있다.\n\r\n<그림> Complete binary tree에 번호를 붙인 모습\n이를 이용하면 Binary min-heap에 원소를 삽입하는 알고리즘을 간단하게 구현할 수 있다. 아래 코드는 삽입 알고리즘을 C++로 구현한 코드이다(코드의 자잘한 문제들은 신경 쓰지 않기로 한다). 코드의 insert_heap() 함수를 호출하면 우리가 만든 Binary min-heap에 원소가 적절히 삽입된다.\n\r\n<그림> Binary min-heap에 원소를 삽입하는 알고리즘을 구현한 코드\n비어있는 Binary min-heap에 1 이상 N 이하의 서로 다른 자연수 N개를 insert_heap() 함수를 이용해 삽입할 것이다. N개의 자연수를 전부 다 삽입한 후에, 자연수 k가 heap 배열의 p번째(배열의 맨 처음 공간을 0번째로 생각한다)에 위치하도록 하고 싶다. 이렇게 만드는 삽입 순서를 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 자연수 N(1 ≤ N ≤ 200,000)이 주어진다. 두 번째 줄에 자연수 k와 p(1 ≤ k, p ≤ N)가 공백으로 구분되어 주어진다.\n",
        "output_text": "자연수 k가 heap 배열의 p번째에 위치하도록 하는 삽입 순서가 존재한다면 i번째 줄에 i번째로 삽입할 수를 출력한다. 가능한 삽입 순서가 여러 가지라면 그중 아무거나 하나를 출력해도 된다. 만약 그렇게 만드는 삽입 순서가 존재하지 않는다면 첫 번째 줄에 -1을 출력한다.\n",
        "memory_median": 3730.0,
        "time_median": 24.0,
        "length_median": 1097.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "607": {
        "problem_text": "은기는 모바일 게임 개발자이다. 이번에 은기가 만드는 게임은 Chain Shot! 게임 (SameGame, Jawbreaker, Bubble Shot, ... 으로도 알려져 있다)을 응용한 \"한번 쏘면 멈출 수 없어\" 이다.\n게임은 직사각형 게임판에서 진행되며, 각 칸에는 색칠된 구슬이 채워져 있다. 플레이어는 각 턴마다 같은 색으로 이루어진 인접한 구슬 그룹을 선택한다. 선택한 구슬은 모두 게임판에서 제거된다. 구슬이 떠있는 경우에는 모두 바닥으로 떨어지게 되고, 빈 열은 제거된다.\n\n\n\n\n\n\n\n\n\n\n\n선택한 그룹\n바닥으로 떨어지는 구슬\n빈 열\n최종 상태\n\n\n\n각 턴마다 플레이어가 얻는 점수는 그룹을 구성하는 구슬 개수의 제곱이다. 예를 들어, 위의 그림에서 플레이어는 49점을 받게 된다.\n게임판에 구슬이 모두 없어지면 게임은 끝나게 되고, 플레이어의 점수는 각 턴마다 얻은 점수의 합이 된다.\n레벨의 설계도는 게임판의 크기와 각 구슬 색상의 수로 이루어져 있다.\n레벨의 설계도가 주어졌을 때, 설계도로 만들 수 있는 레벨 중 얻을 수 있는 점수가 가장 높은 것을 구하는 프로그램을 작성하시오. \n",
        "input_text": "입력으로 레벨의 설계도가 주어진다.\n첫째 줄에는 게임판의 행의 수 h와 열의 수 w, 색상의 수 c가 주어진다. (1 ≤ h, w ≤ 10, 1 ≤ c ≤ 9)\n둘째 줄에는 c개의 양의 정수가 주어지며, 각 정수는 그 색상 구슬의 개수이다. 구슬 개수의 합은 h·w가 된다.\n",
        "output_text": "만든 게임판을 출력한다. 첫 번째 색상은 1, 두 번째 색상은 2, ... 로 출력한다.\n",
        "memory_median": 1986.0,
        "time_median": 0.0,
        "length_median": 632.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "608": {
        "problem_text": "$1$ 이상 $10^9$ 이하의 서로 다른 정수 $N$개를 임의로 정하고 가능한 모든 쌍 $N(N-1)/2$개의 차를 구한다. 이때, 서로 다른 차의 개수의 최댓값과 최솟값을 구하고 각각 실례를 구성하여라.\n",
        "input_text": "첫 번째 줄에 $N$이 주어진다. $(2 \\leq N \\leq 30)$\n",
        "output_text": "첫 번째 줄에 서로 다른 차의 개수의 최댓값을 출력한다.\n두 번째 줄에 서로 다른 차의 개수가 최댓값이 되도록 하는 $1$ 이상 $10^9$ 이하의 서로 다른 정수 $N$개를 공백으로 구분하여 출력한다.\n세 번째 줄에 서로 다른 차의 개수의 최솟값을 출력한다.\n네 번째 줄에 서로 다른 차의 개수가 최솟값이 되도록 하는 $1$ 이상 $10^9$ 이하의 서로 다른 정수 $N$개를 공백으로 구분하여 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 434.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "609": {
        "problem_text": "경기과학고등학교에는 아주 무시무시한 부서 하나가 있다. 그 부서의 이름은 바로 '자치부'이다. '자치부'가 하는 주된 역할 중 하나는 아침에 지정된 기숙사에 들어가서 방의 정리 정돈 상태를 확인하고 검사하는 일이다. 은호는 자치부의 일원으로서 기숙사 호실들을 모두 점검하게 되었다. 근데, 은호가 점검하는 호실마다 옷들이 너저분하게 깔려있었고 심각하게 어질러져 있었다. 이에 은호는 기숙사 대청소 날을 만들어 기숙사 옷들을 모두 정리하려고 한다.\n은호가 경곽의 옷걸이 조사해 보았더니 총 세 가지 종류가 있었다. 하나는 상의만 걸 수 있는 옷걸이, 또 다른 하나는 하의만 걸 수 있는 옷걸이, 마지막 하나는 상의와 하의 모두 걸 수 있는 옷걸이다. 하나의 옷걸이에는 하나의 상의 또는 하의만 걸 수 있음을 유의하자.\n은호는 기숙사 옷들을 정리하기 전에 옷걸이가 모든 옷을 걸기에 부족하지는 않은지 조사하고자 한다. 은호는 경곽 기숙사에 있는 상의와 하의의 개수, 그리고 옷걸이의 개수와 그 종류를 모두 조사했다. 놀랍게도 옷걸이의 개수와 옷의 개수는 같았다. 다만, 옷이 너무 많았기 때문에 은호는 프로그램을 이용해 모든 옷을 정리할 수 있는지 없는지 구하고자 한다. 또 만약 정리할 수 있으면, 어떻게 걸면 옷을 모두 정리할 수 있는지 알고 싶어 한다.\n은호는 건표와 급한 약속이 있어서 이 프로그램 구현을 여러분에게 맡기고 갔다. 은호를 대신해서 프로그램을 짜주자.\n",
        "input_text": "첫째 줄에는 옷걸이의 개수 $N$이 주어진다.\n둘째 줄에는 $N$개의 정수가 주어진다. $i$번째 정수 $A_i$는 옷걸이의 종류를 나타낸다.\n1은 상의 걸이를, 2는 하의 걸이를, 3은 모두 걸 수 있는 옷걸이를 나타낸다.\n마지막 줄에는 두 정수 $U$, $D$가 주어진다. $U$는 상의의 개수, $D$는 하의의 개수이다. $U+D=N$ 임이 보장된다.\n",
        "output_text": "첫째 줄에 주어진 상의와 하의를 옷걸이에 모두 걸 수 있으면 'YES'를, 아니면 'NO'를 출력한다.\n만약 모두 걸 수 있다면 둘째 줄에 각 옷걸이에 어떻게 걸었는지를 길이가 $N$인 문자열 형태로 출력한다.\n문자열에서 $i$번째 문자는 $i$번째 옷걸이에 건 의상의 종류를 나타내며, 'U'인 경우 상의를, 'D'인 경우 하의를 걸었음을 나타낸다. (작은따옴표는 출력하지 않는다.)\n문자는 모두 대문자로 출력해야 한다.\n",
        "memory_median": 6904.0,
        "time_median": 96.0,
        "length_median": 844.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "610": {
        "problem_text": "$A+B$ is a problem used to test one's basic knowledge for competitive programming. Here is yet another boring variation of it.\nYou have two integers, $A$ and $B$. You want to make them equal. To do so, you can perform several steps, where each step is one of the following:\n\n$A$ += $A$\n$A$ += $B$\n$B$ += $A$\n$B$ += $B$\n\nUnfortunately, $A+B$ is a hard problem for us, so you are allowed to make at most 5000 steps.\n",
        "input_text": "In the first line, two space-separated integers $A$ and $B$ are given. These are the initial values of the variables $A$ and $B$.\n",
        "output_text": "In the first line, print a single integer $n$ ($0 \\le n \\le 5\\,000$) denoting the number of steps.\nIn the next $n$ lines, print one of the following strings to denote your desired operation: A+=A, A+=B, B+=A, B+=B.\nAny sequence of steps that yields the desired result will be judged correct.\n",
        "memory_median": 2058.0,
        "time_median": 0.0,
        "length_median": 819.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "611": {
        "problem_text": "\n길이가 $N$인 순열이란, $1$이상 $N$이하의 자연수 $N$개로 이루어진, 같은 수가 두 번 이상 등장하지 않는 수열을 의미한다. \n\n여기 길이가 $N$인 순열 $A$가 있다.\n이때 새로운 수열 $P$의 $i$번째 원소는 다음과 같이 정의된다. ($1 \\le i \\le N$)\r\n$$P_i = \\left(\\sum_{k=1}^{i}A_k\\right)\\ \\bmod N$$\r\n$P$의 원소들 중 서로 다른 값이 $\\frac{N}{2} + 1$개 이하가 되도록 하는 순열 $A$를 아무거나 하나 구해보자.\n",
        "input_text": "첫째 줄에 $N$ ($1 \\le N \\le 100\\,000$)이 주어진다.\n",
        "output_text": "$A_1$부터 $A_N$까지의 원소를 공백을 기준으로 출력한다.\n조건을 만족하는 순열 $A$가 항상 존재한다.\n",
        "memory_median": 2020.0,
        "time_median": 8.0,
        "length_median": 411.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "612": {
        "problem_text": "자연수로 이루어진 배열이 주어졌을 때, 수의 순서를 적절히 바꿔서 인접한 두 수의 합이 3으로 나누어 떨어지지 않는 배열을 만드는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 배열의 크기 N이 주어진다. (1 ≤ N ≤ 10000)\n둘째 줄에는 배열에 들어있는 수가 공백으로 구분되어 주어진다. 수는 1,000,000보다 작거나 같은 자연수이다.\n",
        "output_text": "만약, 3으로 나누어 떨어지지 않게 배열을 만들 수 있다면 첫째 줄에 출력한다. 불가능하다면 -1을 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 0.0,
        "length_median": 1139.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "613": {
        "problem_text": "가장 가까운 두 점 문제의 출력값을 최대한 크게 하는 입력을 만들어보자. 단, 다음과 같은 조건을 만족해야 한다.\n\nn = 814\nx, y좌표의 절댓값은 8140을 넘으면 안 된다.\n가장 가까운 두 점의 쌍이 여럿 있어서는 안 된다.\n\n",
        "input_text": "입력은 주어지지 않는다.\n",
        "output_text": "조건을 만족하는 입력을 하나 출력한다. n은 생략하고, 814개의 줄에 걸쳐 정수 x, y좌표를 공백 하나로 구분하여 출력하면 된다.\n점수는 주어진 점들 사이에서 가장 가까운 두 점의 거리가 된다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 385.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "614": {
        "problem_text": "이 문제는 특이한 수열 A를 찾는 문제이다. 특이한 수열의 성질은 다음과 같다.\n\n수열 A의 길이는 n\n1이상 n이하의 정수가 빠짐없이 모두 등장해야 하며, 각 수는 한번만 등장해야함\n1 ≤ i ≤ n 인 i에 대해 gcd(i, A[i]) > 1 을 만족하는 i가 정확히 k개여야함\n\nn, k 가 주어졌을 때, 특이한 수열을 아무거나 하나 구해보자.\n",
        "input_text": "첫째 줄에 n, k (1 ≤ n ≤ 105, 0 ≤ k ≤ n)가 주어진다.\n",
        "output_text": "첫째 줄에 문제의 조건을 만족하는 특이한 수열 A를 출력한다. 답이 여러 가지가 있다면 그 중 아무거나 출력해도 된다. 만약 조건을 만족하는 특이한 수열이 없다면 \"Impossible\" 을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 12.0,
        "length_median": 495.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "615": {
        "problem_text": "N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.\nN이 주어졌을 때, 퀸을 놓는 방법 한 가지를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N이 주어진다. (4 ≤ N ≤ 10,000)\n",
        "output_text": "N개의 줄을 출력해야 한다. i번째 줄에는 하나의 정수를 출력해야 하고, 이 정수는 i번째 행에 있는 퀸이 있는 열의 번호이다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 746.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0
        ]
    },
    "616": {
        "problem_text": "KOI 야구 리그에는 $N$개의 지역리그가 존재하고 각 지역리그에는 $M$개의 팀이 존재해서, 리그 전체로는 $N \\times M$개의 팀으로 운영되고 있다.\n한 시즌에 각 팀은 같은 지역리그 팀뿐만 아니라 다른 지역리그 팀과도 경기를 해야 한다. 같은 지역리그 팀과의 팀당 경기 수는 $A$로 같은 지역리그 팀들에 대해서 모두 동일하다. 즉, 한 팀 $X$는 같은 지역리그에 있는 모든 팀 $Y$ ($\\ne X$)와 각각 $A$번의 경기를 한다. 또한 다른 지역리그 팀과의 팀당 경기 수는 $B$로 다른 지역리그 팀들에 대해서 모두 동일하다. 즉, 한 팀 $X$는 다른 지역리그에 있는 모든 팀 $Z$($\\ne X$)와 각각 $B$번의 경기를 한다. 단, $A$와 $B$는 $A = k \\times B$ ($k$는 $1$ 이상의 정수)를 만족해야 한다.\n세계적 판데믹의 영향으로 올해 KOI 야구 리그는 시즌을 단축하여, 리그의 전체 경기 수가 $D$개 이하 이면서 $D$에 가장 가깝게 되도록 정하기로 했다. 따라서 같은 지역리그 팀과의 팀당 경기 수 $A$와 다른 지역리그 팀과의 팀당 경기 수 $B$를 새롭게 결정해야 한다. 물론, $A = k \\times B$를 만족해야 하고, $k$는 변함없이 유지되어야 한다. 또한 각 팀은 다른 팀과 적어도 한 번이상은 경기를 해야 한다. 다시 말해서, $A \\ge 1$, $B \\ge 1$을 만족해야 한다.\n예를 들어, $N = 2$, $M = 3$, $k = 3$일 때, 경기 수 제한 $D = 60$이면, $A = 6$, $B = 2$일 때, 다른 지역리그 팀들과의 총 경기 수는 $18$이고, 같은 지역리그 팀들과의 총 경기 수는 $36$이다. 따라서 리그 전체 경기 수는 $54$로 $D$에 가장 가까운 새로운 경기 수이다.\n지역리그의 개수 $N$, 각 지역리그에 속하는 팀 수 $M$, 그리고 위에서 $A = k \\times B$를 만족하는 정수 $k$, 새로운 경기 수 제한 $D$가 주어질 때, $D$ 이하이면서 $D$에 가장 가까운 리그 전체 경기 수를 계산해서 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 개수 $T$가 주어진다.\n다음 $T$개의 줄에 각 테스트 케이스의 정보가 한 줄에 하나씩 주어진다.\n각 테스트 케이스는 하나의 줄에 네 개의 정수 $N$, $M$, $k$, $D$가 공백 하나를 사이로 두고 주어진다.\n",
        "output_text": "$T$개의 각 줄에 각 테스트 케이스에 대해 리그 전체 경기 수를 출력한다.\n만약 조건을 만족하는 경기 수가 존재하지 않으면 $-1$을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 424.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "617": {
        "problem_text": "A CCC soccer game operates under slightly different soccer rules. A goal is only counted if the 4 players, in order, who touched the ball prior to the goal have jersey numbers that are in strictly increasing numeric order with the highest number being the goal scorer.\nPlayers have jerseys numbered from 1 to 99 (and each jersey number is worn by exactly one player).\nGiven a jersey number of the goal scorer, indicate how many possible combinations of players can produce a valid goal.\n",
        "input_text": "The input will be the positive integer J (1 ≤ J ≤ 99), which is the jersey number of the goal scorer.\n",
        "output_text": "The output will be one line containing the number of possible scoring combinations that could have J as the goal scoring jersey number.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 202.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "618": {
        "problem_text": "괄호 문자열은 다음과 같이 정의 한다.\n\n빈 문자열은 괄호 문자열이다.\nS가 괄호 문자열일 때, (S)도 괄호 문자열이다.\nS와 T가 괄호 문자열이라면, ST도 괄호 문자열이다.\n모든 괄호 문자열은 위의 3개 규칙으로만 만들 수 있다.\n\n이 문제에서는 괄호 문자열이 아닌 문자열이 나온다. 만약 문자열이 ‘(’와 ‘)’로만 이루어져 있고, 괄호 문자열이 아니라면, 그 문자열을 괄호ㄴㄴ문자열이라고 한다.\n길이가 N인 괄호ㄴㄴ문자열 중에 사전순으로 K번째인 문자열을 출력하는 프로그램을 작성하시오. 그러한 것이 없으면 -1을 출력한다. ‘(’가 ‘)’보다 사전순으로 앞선다. 사전순으로 가장 앞서는 문자열은 $0$번째 문자열이다.\n",
        "input_text": "첫째 줄에 두 정수 N과 K가 주어진다.\n",
        "output_text": "첫째 줄에 문제의 정답을 출력한다.\n",
        "memory_median": 2040.0,
        "time_median": 0.0,
        "length_median": 1108.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "619": {
        "problem_text": "높이가 1, 2, ..., n인 막대 n개가 일렬로 배치되어 있다. 막대를 왼쪽이나 오른쪽에서 보면, 큰 막대가 뒤에있는 작은 막대를 가리게 된다. 아래와 같이 4개의 막대로 이루어진 두 배치를 살펴보자.\n\n위의 두 배치는 모두 왼쪽에서 봤을 때 막대가 한 개 보이고, 오른쪽에서 봤을 때는 막대가 두 개 보인다.\n막대의 개수 n과 왼쪽에서 봤을 때 보이는 막대의 개수 l, 오른쪽에서 봤을 때 보이는 막대의 개수 r이 주어진다. 이때, 이러한 결과를 만드는 배치의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, n, l, r이 주어진다. (1 ≤ l, r ≤ n ≤ 20)\n",
        "output_text": "각 테스트 케이스마다, 입력으로 주어진 값에 해당하는 배치의 수를 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 0.0,
        "length_median": 624.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "620": {
        "problem_text": "비요뜨는 지금 강 앞에 서 있다. 강 위에는 징검다리가 놓여 있다.\n징검다리는 비요뜨가 있는 방향에서부터 반대 방향까지 차례로 1번, 2번, ..., N번의 번호를 가지고 있다.\n비요뜨는 1번 징검다리 위에 올라갔다. 그리고 아래 두 가지 규칙을 지키며 징검다리를 건너려고 한다.\n\n1 ≤ X ≤ N 인 임의의 정수 X에 대해, 현재 있는 징검다리의 번호를 i번이라고 할 때 i+X번 징검다리로 뛸 수 있다.\nN번째 징검다리를 지나쳐선 안 되고, 정확히 도착해야 한다\n\n비요뜨는 자신의 특기인 코딩을 살리기 위해 노트북을 켰지만, 실수로 노트북을 강에 빠뜨리고 말았다.\n비요뜨를 대신해 강을 건너는 경우의 수를 구해 주자!\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 1000)\n각 테스트 케이스는 한 줄로 구성되며, 징검다리의 개수를 의미하는 N이 주어진다. (1 ≤ N ≤ 109)\n",
        "output_text": "각 테스트 케이스에 대해, 한 줄에 하나씩 규칙을 만족하면서 징검다리를 건너는 경우의 수를 109+7로 나눈 나머지를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 508.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "621": {
        "problem_text": "N명의 학생들이 있다. 이 학생들을 다음과 같은 방식으로 줄을 세우려고 한다.\n\n맨 앞줄에는 아무나 설 수 있다.\n둘째 줄에도 아무나 설 수 있다.\n셋째 줄에는 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 클 경우, 둘째 줄에 서 있는 사람보다 작은 사람만이 설 수 있으며, 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 작을 경우, 둘째 줄에 서 있는 사람보다 큰 사람만이 설 수 있다.\n넷째 줄부터는 둘째 줄과 셋째 줄을 비교하는 식으로 해서 N번째의 줄을 서는 사람은 N-2번째 줄과 N-1번째 줄에 서는 사람을 비교해서 세운다.\n\n학생들이 1이 가장 작은 사람, N이 가장 큰 사람이며, 같은 키를 가진 사람이 없다고 할 때, 5명을 세운다면 1 - 3 - 2 - 5 - 4, 3 - 2 - 5 - 1 - 4 등의 방법으로 세울 수 있다.\n문제는 N명의 학생을 이런 식으로 줄을 세울 때 총 몇 가지의 경우의 수가 생기는지 찾아내는 것이다.\n",
        "input_text": "첫째 줄에 학생 수 N(1 ≤ N ≤ 100)이 입력된다.\n",
        "output_text": "첫째 줄에 총 경우의 수를 1,000,000으로 나눈 나머지를 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 0.0,
        "length_median": 895.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "622": {
        "problem_text": "강토는 Day Of Mourning의 기타리스트로, 다가오는 공연을 준비하고 있다.\n어느 날 강토의 집에 도둑이 들어서 기타를 모두 도둑맞고 말았다. 기타를 사야 한다.\n강토는 공연 때 연주할 노래의 목록을 뽑아 놓았다. 하지만, 하나의 기타로 모든 곡을 연주할 수는 없다. 어떤 기타는 어떤 곡을 연주할 때, 이상한 소리가 나기 때문이다. 항상 완벽을 추구하는 강토는 이런 일을 용납하지 않는다.\n최대한 많은 곡을 제대로 연주하려고 할 때, 필요한 기타의 최소 개수를 구하는 프로그램을 작성하시오.\n예를 들어, GIBSON으로 1, 2, 3번 곡을 제대로 연주할 수 있고, FENDER로 1, 2, 5번 곡을 제대로 연주할 수 있고, EPIPHONE으로 4, 5번 곡을 제대로 연주할 수 있고, ESP로 1번곡을 제대로 연주할 수 있다면, 세준이는 EPIPHONE과 GIBSON을 사면 최소의 개수로 모든 곡을 연주할 수 있다. \n",
        "input_text": "첫째 줄에 기타의 개수 N과 곡의 개수 M이 주어진다. N은 10보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 기타의 이름과 기타가 연주할 수 있는 곡의 정보가 1번 곡부터 차례대로 주어진다. Y는 연주할 수 있는 것이고, N은 없는 것이다. 기타의 이름은 알파벳 대문자로만 이루어져 있고, 길이는 2 이상, 50 이하이다. 두 기타의 이름이 같은 경우는 없다.\n",
        "output_text": "첫째 줄에 필요한 기타의 개수를 출력한다. 만약 연주할 수 있는 곡이 없으면 -1을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1078.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1,
            0
        ]
    },
    "623": {
        "problem_text": "인하대학교에 다니는 토쟁이는 y축과 평행한 w개의 도로, x축과 평행한 h개의 도로가 있는 도시에 살고 있다. 토쟁이의 집은 이 도시의 맨 왼쪽 아래에 위치하며 좌표로는 (1, 1)로 표시할 수 있다. 매일 아침 토쟁이는 등교를 하며, 등굣길에 토스트 가게에 들러 토스트를 사 먹는다. 이때 학교의 위치는 토쟁이의 집 반대쪽 맨 오른쪽 위에 위치하며 좌표로는 (w, h)로 표시할 수 있다. 토쟁이는 늦장 부리는 것을 좋아하여 수업 시작 시간에 맞게 도착하게끔 출발한다. 따라서 토스트 가게를 거쳐 학교로 가는 경로는 항상 최소의 시간이 걸려야 한다. (토쟁이는 토스트를 매우 빠르게 먹어 0초 만에 먹으며, 토스트 가게 아주머니 역시 토스트 장인이기 때문에 0초 만에 토스트를 만든다고 가정한다) 이때, 토쟁이가 토스트를 먹고 학교에 늦지 않게 도착할 수 있는 경로는 몇 가지일까??\n예를 들면, y축과 평행한 도로가 3개 있으며, x축과 평행한  도로가 2개 있다고 했을 때, 도시는 아래의 그림과 같이 그려진다.\n\n이때, 토스트 가게가 (2,2)에 위치하면, 토쟁이의 집은 (1,1)에 위치하고, 학교는 (3,2)에 위치하므로, 이때 경로들은\n\n위와 같이 2가지이다.\n",
        "input_text": "입력의 첫째 줄에 도시의 y축과 평행한 도로의 개수 w와 x축과 평행한 도로의 개수 h가 주어진다. (2 ≤ w, h ≤ 200)\n둘째 줄에는 토스트 가게의 (x, y)좌표가 주어진다. (1 ≤ x ≤ w,1 ≤ y ≤ h) x, y는 항상 정수이다.\n",
        "output_text": "첫째 줄에 토쟁이가 학교에 늦지 않게 도착할 수 있는 등굣길의 개수를 1,000,007로 나눈 나머지 값을 출력한다. \n",
        "memory_median": 2336.0,
        "time_median": 0.0,
        "length_median": 631.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "624": {
        "problem_text": "1부터 N까지 번호가 매겨진 박스와 1부터 N까지 번호가 매겨진 열쇠가 있다. i번째 키는 i번째 박스를 열 수 있다.\n다못이는 각각의 박스에 정확하게 하나의 열쇠를 무작위로 넣는다. 각각의 열쇠가 박스에 들어갈 확률은 모두 같다고 가정한다. 그러고 나서 박스를 모두 잠근다. 다못이에게는 M개의 폭탄이 있다. 폭탄은 잠겨져 있는 박스를 파괴하는 역할을 한다. 이때 박스 안에 있는 열쇠는 부서지지 않는다. 다못이는 모든 열쇠를 얻고 싶다. 그래서 다음 전략을 사용하기로 했다.\n우선 잠겨져 있는 박스 하나를 선택해서 폭탄으로 파괴하고 열쇠를 얻는다. 각각의 잠겨져 있는 박스가 선택될 확률은 모두 같다. 그 열쇠로 열 수 있는 박스가 있으면 열고, 그 박스 속의 열쇠로 열 수 있는 박스가 있으면 또 열고, 이를 열 박스가 더 이상 없을 때까지 반복한다. 그러고 나서 폭탄이 남았으면 그 폭탄을 이용해서 이 전략을 반복한다.\n다못이가 모든 열쇠를 얻을 확률을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 박스와 열쇠의 개수 N과 폭탄의 개수 M이 공백을 사이에 두고 주어진다. N은 20보다 작거나 같은 자연수이고, M은 N보다 작거나 같은 자연수이다.\n",
        "output_text": "다못이가 모든 열쇠를 얻을 확률을 A/B 형태로 출력한다. A와 B는 최대공약수가 1인 자연수이다.\n",
        "memory_median": 1992.0,
        "time_median": 0.0,
        "length_median": 678.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "625": {
        "problem_text": "인하대 컴퓨터 공학과에 재학 중인 이산이는 오랜만에 미팅을 나가 볼까 한다. 미팅은 N명이 원탁에 앉아서 진행된다고 한다. 질투가 난 이산이 친구 명기는 X의 저주를 걸었다. 그 저주는 N명이 동시에 2명씩 짝을 지어 악수할 때 사람의 팔이 교차되거나 한 사람이라도 악수를 하지 못하면 그 미팅은 실패하게 되는 저주다. 하지만 명기는 이산이에게 저주를 풀 기회를 주었다. 미팅에 성공할 경우의 수를 구하여 큰소리로 외치면 저주가 풀린다. 하지만 이산이는 계산 능력이 부족해서 당신에게 도움을 청했다. 이산이가 걸린 저주를 풀어주는 프로그램을 만들어주자.\n미팅에 참가한 사람이 4명일 경우 미팅에 성공할 경우는 다음 그림과 같이 2가지이다.\n\n미팅에 참가한 사람이 6명일 경우 미팅에 성공할 경우는 다음 그림과 같이 5가지이다.\n\n",
        "input_text": "첫째 줄에 미팅에 참가하는 사람의 수 N 이 주어진다. 이 값은 10,000이하의 짝수이다.\n",
        "output_text": "미팅에 성공하는 경우의 수를 987654321로 나눈 나머지를 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 24.0,
        "length_median": 403.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "626": {
        "problem_text": "길이가 $N$인 수열 $A_1, \\cdots, A_N$이 주어집니다. 수열의 모든 수는 서로 다른 $1$ 이상 $N$ 이하의 수입니다. 아래 조건을 모두 만족시키는 $(i, j)$ 정수쌍의 개수를 구하세요.\n\n$1 \\le i \\le j \\le N$.\n$A$의 $i$번째 수부터 $j$번째 수까지가 오름차순으로 배열되어있다. 즉, $i \\le k < j$를 만족하는 모든 정수 $k$에 대해 $A_k < A_{k+1}$.\n\n",
        "input_text": "첫 줄에 수열의 길이 $N$이 주어집니다. $(1 \\le N \\le 200\\,000)$\n다음 줄에는 수열의 각 원소 $A_1, A_2, \\cdots, A_N$이 공백으로 구분되어 주어집니다. $(1 \\le A_i \\le N;$ $A_1, A_2, \\cdots, A_N$은 서로 다른 정수$)$\n",
        "output_text": "문제의 조건을 만족시키는 $(i, j)$ 정수쌍의 개수를 출력하세요.\n",
        "memory_median": 2804.0,
        "time_median": 20.0,
        "length_median": 519.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "627": {
        "problem_text": "Do you know a game called “La cave aux énigmes”? One of its questions is to find the number of squares contained in a grid square of length l. A grid square of length 4 will look like this:\n\nThe total number of squares that can be seen in this image is 30. Your task is to find the total number of squares which can be seen in an image of a grid square of length l.\n",
        "input_text": "The input will begin with a single integer P on the first line, indicating the number of cases that will follow.\nThe remaining lines of the input will consist of one integer l per line, which is the grid square length. All integers will be less than 1,000,000 and greater than 0.\nYou should process all integers and for each integer l, determine the total number of squares which can be seen in an image of a grid square of length l.\nYou can assume that no operation overflows a 32-bit integer.\n",
        "output_text": "For each integer l, you should output the total number of squares which can be seen in an image of a grid square of length l, with one line of output for each line of input.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 281.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "628": {
        "problem_text": "RUNIST 대학교에서는 매 학기마다 재미있는 기숙사 배정을 한다.\nRUNIST 대학교에는 N명의 학생이 있고 N개의 기숙사가 있다. 모든 N명의 학생들은 봄학기에 기숙사를 한 명 당 하나씩 배정을 받았고, 모두 각각 다 다른 기숙사에 배정이 되었다.\n이제 가을학기가 되어 학생복지팀에서는 기숙사를 다시 배정하려고 한다. 모든 학생들은 본인이 살았던 봄학기 기숙사에서 가을 학기에 다른 기숙사로 배정되면 이사를 해야하므로 기숙사 재배정을 신청하였다. (기숙사 재배정이 된다면 기숙사를 그대로 쓰게 된다.)\n이렇게 모든 학생들은 기숙사 재배정을 신청했지만, 학생복지팀에서는 어떤 학생에게도 기숙사 재배정을 해주지 않으려고 한다.\n봄학기때 기숙사를 이미 배정받은 상태에서, 가을학기 기숙사에 아무도 재배정이 되지 않는 경우의 수를 구해보자.\n",
        "input_text": "첫 번째 줄에 테스트 케이스의 수 T가 주어진다.\n각 케이스의 첫 번째 줄에 학생 명수(기숙사의 개수) N (1 ≤ N ≤ 20) 이 주어진다. \n",
        "output_text": "각 테스트 케이스 별로 아무도 재배정이 되지 않는 경우의 수를 출력한다.\n",
        "memory_median": 1984.0,
        "time_median": 0.0,
        "length_median": 386.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "629": {
        "problem_text": "0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.\n덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.\n",
        "input_text": "첫째 줄에 두 정수 N(1 ≤ N ≤ 5,000), K(1 ≤ K ≤ 5,000)가 주어진다.\n",
        "output_text": "첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.\n",
        "memory_median": 100066.0,
        "time_median": 194.0,
        "length_median": 434.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "630": {
        "problem_text": "N과 K가 주어졌을 때, 1K + 2K + 3K + ... + NK를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 K가 주어진다. N은 109보다 작거나 같은 자연수이고, K는 50보다 작거나 같은 자연수이다.\n",
        "output_text": "첫째 줄에 1K + 2K + 3K + ... + NK를 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1241.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "631": {
        "problem_text": "곧 시계는 6시, 벌써 첫 번째 별이 보인다. 정$N$각형 모양의 하늘에는 몇 개의 별이 뜰 수 있을까?\n정$N$각형의 꼭짓점의 개수 $N$이 주어졌을 때, 정$N$각형의 꼭짓점을 이어 만들 수 있는 서로 다른 별의 개수를 출력하여라.\n별은 정$N$각형의 다섯 꼭짓점에 시계 방향으로 번호를 붙였을 때, 그 꼭짓점들을 1-3-5-2-4-1 순으로 연결한 것을 의미한다. 뒤집거나 돌려서 같은 모양이 나오는 별도 정$N$각형의 다른 꼭짓점을 이어 만든 별이라면 서로 다른 별이다.\n",
        "input_text": "정$N$각형의 꼭짓점의 개수인 정수 $N$이 주어진다. $(5\\leq N \\leq 100)$\n",
        "output_text": "정$N$각형의 꼭짓점을 이어 만들 수 있는 별의 개수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 257.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "632": {
        "problem_text": "유진이는 현수의 암호를 알아내려고 한다. 유진이는 사전 조사를 통해 임현수의 컴퓨터에 어떤 문자들이 쓰이는지 알아내었고, 하나씩 대입해보려고 한다. 대입하는 순서는 유진이가 메모한 문자 집합의 순서대로이고, 한 글자부터 암호가 풀릴 때까지 모두 대입해본다.\n예를 들어, 메모한 문자 집합이 bca라고 한다면, 유진이는 b, c, a, bb, bc, ba, cb, cc, ca, ab, ac, aa, bbb, bbc, ........ 순서로 암호가 풀릴 때까지 계속 대입해본다.\n",
        "input_text": "첫 번째 줄에는 암호로 사용할 수 있는 문자가 공백 없이 주어지고, 두 번째 줄에는 컴퓨터의 암호가 주어진다. 암호에 사용할 수 있는 문자의 종류는 최대 100가지이고, 공백은 사용할 수 없다. 영문자는 대소문자를 구분한다. 암호의 길이는 최대 1,000,000자이다.\n",
        "output_text": "첫 번째 줄에 주어진 암호를 몇 번의 시도로 풀 수 있는지 출력한다. 만약 수가 클 경우, 시도 횟수를 900528으로 나눈 나머지를 출력한다.\n",
        "memory_median": 3688.0,
        "time_median": 24.0,
        "length_median": 567.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "633": {
        "problem_text": "강산이는 심각한 게임 중독자이기 때문에 날씨에 상관없이 매일 PC방을 간다.\n최근에 폭우로 인해 일부 지역이 침수되어 침수된 지역으로는 이동할 수 없게 되었다. 하지만 강산이는 출석 이벤트를 위해 하루도 빠짐없이 PC방을 가야 한다.\n강산이는 PC방까지 상, 하, 좌, 우 방향으로만 이동하며, 한 번 이동할 때의 거리는 1이다. 또한, 강산이는 게임을 빨리하러 가야 하기 때문에 집에서 PC방까지 최단경로로 움직인다.\n강산이의 집의 좌표 (H, H)와 PC방의 좌표 (N, N)이 주어지고 좌표평면 위 (x, y)에서 y > x인 곳은 침수되었다고 할 때, 강산이가 침수된 지역을 피해서 PC방까지 갈 수 있는 경로의 개수를 구하라.\n단, PC방의 좌표가 집의 좌표 같은 경우 경로는 1가지라고 한다.\n",
        "input_text": "첫째 줄에 집과 PC방의 좌표 (H, H), (N, N) 을 나타내는 두 정수 H, N (0 ≤ H, N ≤ 30) 이 차례로 주어진다.\n",
        "output_text": "집에서 PC방까지 갈 수 있는 경로의 개수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 504.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "634": {
        "problem_text": "시흠이는 최근에 레스토랑 \"삼각형\"을 오픈했고, 시흠이는 레스토랑을 상징하는 네온 사인을 주문했다.\n네온 사인은 총 N개의 꼭짓점이 원의 둘레를 따라 찍혀져 있다. 그리고, 총 N * (N-1) / 2개의 야광 튜브가 꼭짓점을 연결하고 있다. 야광 튜브는 두 가지 색(빨간색과 파란색)이 있다.\n시흠이는 한 번에 한 삼각형만 불을 밝히려고 한다. 이때, 삼각형의 모든 변은 색상이 같아야 하고, 꼭짓점이 서로 이어져 있어야 한다. 그는 이러한 단색 삼각형의 개수를 알려고 한다.\n예를 들어, 아래 네온 사인에는 단색 삼각형이 두 개 있다. (1, 3, 5)와 (2, 3, 4)\n\n네온 사인의 꼭짓점의 수와 각 야광 튜브의 색상이 주어졌을 때, 단색 삼각형의 개수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에는 테스트 케이스의 수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 꼭짓점의 개수 N(3 ≤ N ≤ 1,000)이 주어진다. 다음 N-1개의 각 야광 튜브의 색이 주어진다. 이 줄의 i번째 줄에는 꼭짓점 i와 연결된 튜브의 색상이 i+1번 꼭짓점과 연결된 튜브부터 N번까지 순서대로 주어진다. 빨간색은 1, 파란색은 0으로 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해서 단색 삼각형의 개수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 1408.0,
        "length_median": 663.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "635": {
        "problem_text": "오늘은 즐거운 선린 축제날, 갑자기 폭우가 쏟아지기 시작했다! 상민이는 비에 실망한 학우들을 위해 실내에서도 할 수 있는 복불복 게임을 준비했다.\n상민이는 N개의 컵에 N개의 서로 다른 음료를 담았다. 그러고는 아래와 같은 규칙에 따라 음료를 섞기로 했다.\n\n1~N의 번호가 메겨진 컵을 오름차순으로 일렬로 배치한다.\n어떤 두 컵을 골라 위치를 맞바꾼다. 이 작업을 N/2번 반복한다.\n모든 컵은 정확히 한 번씩 위치가 바뀌어야 한다. 자기 자신과는 위치를 바꿀 수 없다.\n\n이쯤 읽고 나니 왠지 컵이 배열되는 경우의 수가 몇 가지인지 궁금해야 할 것 같다. 이걸 구하지 않으면 지구가 멸망한다고 한다. 이 문제를 풀고 지구의 용사가 되자!\n",
        "input_text": "첫째 줄에 음료의 개수 N이 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 105)\n",
        "output_text": "컵이 배열되는 경우의 수를 출력한다. 수가 커질 수 있으므로 109+7로 나눈 나머지를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 271.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "636": {
        "problem_text": "좌표 평면에 점 N개가 있다.\n이때, 빗변을 제외한 나머지 두 변이 좌표축에 평행한 직각삼각형을 이루는 점 3개를 고르는 방법을 수를 구하는 프로그램을 작성하시오.\n직각삼각형은 한각이 직각인 삼각형이며, 직각의 대변을 빗변이라고 한다.\n",
        "input_text": "첫째 줄에 점의 개수 N(3 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개의 줄에는 점의 좌표가 X Y 순서대로 주어진다. (1 ≤ X,Y ≤ 100,000) 겹치는 점은 없다.\n",
        "output_text": "첫째 줄에 직각삼각형의 개수를 출력한다.\n",
        "memory_median": 4408.0,
        "time_median": 32.0,
        "length_median": 527.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "637": {
        "problem_text": "메이지는 카드 게임 대회에 출전하려고 한다. 메이지는 $N$종류의 카드게임에 참가하려 한다. 어떤 카드 게임에 참가하기 위해서는, 그 게임에 맞는 카드 덱이 있어야 한다. 메이지는 $i$번째 게임에 대해, 메이지는 서로 다른 카드 덱을 $A_i$개 소유하고 있다. 만약, 참가자가 특정 게임에 대해 카드 덱이 없을 경우, 대회 주최측에서는 기본 카드덱을 준비 해 준다.\n메이지는 자신이 얼마나 다양한 카드 덱 구성으로 참가할 수 있는지가 궁금해졌다. 서로 다른 방법으로 참여한다는 것은, 적어도 하나의 게임에 대해 다른 종류의 카드 덱으로 대회를 참가하는 것이다.\n이때, 메이지가 서로 다른 방법으로 대회에 참여할 수 있는 방법의 수를 구하여라. 단, 답이 매우 클 수 있으니 답을 $M$으로 나눈 나머지를 출력하여라.\n",
        "input_text": "첫째 줄에는, 정수 $N$, $M$이 공백으로 구분되어 들어온다. ($0 \\le N \\le 100$, $1 \\le M \\le 100$)\n다음 $N$개의 줄의 $i$번째 줄에는, 정수 $A_i$가 들어온다. ($0 \\le A_i \\le 100$)\n",
        "output_text": "메이지가 대회에 참여할 수 있는 방법의 수를 $M$으로 나눈 나머지를 구하여라.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 286.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "638": {
        "problem_text": "같은 차종의 빨간색 자동차 $A$대, 초록색 자동차 $B$대, 파란색 자동차 $C$대를 $N$칸의 주차장에 $1$대씩 주차하려고 한다.\n모든 자동차를 한 칸에 한 대씩 주차할 수 있는 경우의 수를 구하라.\n",
        "input_text": "첫 번째 줄에 양의 정수 $N$, $A$, $B$, $C$가 공백으로 구분되어 주어진다.\n",
        "output_text": "첫 번째 줄에 정답을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 389.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "639": {
        "problem_text": "섰다는 화투를 이용하여 20장의 카드를 가지고 2명 이상이 경기를 하는 게임이다.\n이러한 섰다의 규칙을 단순화한 게임이 바로 '앉았다'이다.\n앉았다의 규칙은 1, 2, 3, ... , 9, 10이 쓰인 카드가 각 2장씩 주어지며 총 20장의 카드가 사용되며, 2명이 참가한다.\n다음은 앉았다의 경기 방법이다.\n\n두 명의 참가자는 순서대로 20장의 카드 중 무작위로 2장의 카드를 가져온다.\n상대방이 이미 가지고 간 카드를 중복해서 가져올 수는 없다. 그리고 자신은 어떤 카드를 가져왔는지 알 수 있지만, 상대방이 어떤 카드를 가져갔는지는 알 수 없다.\n서로의 패를 공개한다.\n강한 족보의 패를 가진 사람이 이긴다. 만약 두 참가자가 같은 족보의 패를 가졌다면 비긴다.\n\n족보 (위에 있는 족보일수록 더 강한 족보이다)\n\n10땡: 두 패가 모두 10\n9땡: 두 패가 모두 9\n...\n2땡: 두 패가 모두 2\n1땡: 두 패가 모두 1\n9끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 9\n8끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 8\n...\n1끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 1\n0끗: 땡이 아니고, 두 패를 더했을 때 일의 자리의 수가 0\n\n예를 들어, 영학이의 패가 1과 1이고, 상대의 패가 10과 9라고 하자.\n그렇다면 영학이는 1땡이고, 상대는 9끗이다. 영학이가 더 강한 족보를 가졌으므로 영학이가 상대를 이긴다.\n영학이는 자신이 어떤 패를 받았는지 보았고, 상대방의 패는 모르는 상태이다.\n영학이는 영악해서 앉았다 게임에서 자신이 이길 확률이 높을 때만 돈을 베팅한다.\n영악한 영학이를 위하여 영학이의 패가 입력으로 주어졌을 때 이길 수 있는 확률을 구하여라.\n",
        "input_text": "영학이의 패를 뜻하는 두 개의 정수 A, B가 주어진다. (1 ≤ A, B ≤ 10)\n",
        "output_text": "영학이가 이길 확률을 소수점 이하 셋 째 자리까지 반올림해서 출력하시오.\n반드시 뒤따르는 0도 출력해야 한다. 예를 들어, '0.700'을 출력했다면 정답이고, '0.7'을 출력했다면 오답이다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 713.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "640": {
        "problem_text": "떡파이어의 불로장생의 비밀은 바로 떡국이다.\n떡파이어는 떡국을 먹은 그릇의 개수만큼 나이를 먹는다. 그들은 매일 떡국을 먹는데, 떡국을 먹는대로 바로 소화가 가능하기 때문에 하루에 얼마든지 원하는 만큼 떡국을 먹을 수 있다. 그러나 전에 떡국을 얼마나 먹었든지, 그들은 기구하게도 떡국을 하루라도 먹지 않으면 생을 마감하게 된다.\n어느 날, 디디는 어떤 떡파이어가 M째날에 N세로 생을 마감하기까지 어떤 생을 살아왔는지 알고 싶어서, 그의 나이를 먹는 과정의 경우의 수를 세려고 한다. 그렇지만, 떡파이어의 나이가 많을 수록 그 경우의 수는 무수히 많아지기 때문에 디디는 곤란해하고 있다.\n그런 디디를 위해 M째날에 N세로 생을 마감한 떡파이어가 나이를 먹는 과정의 경우의 수를 세는 프로그램을 작성해야 한다.\n떡파이어의 나이는 0세부터 시작된다.\nN = 3, M = 3,일때를 예로 들면,\n\n첫째 날 1개 둘째 날 2개, 셋째 날 0개\n첫째 날 2개 둘째 날 1개, 셋째 날 0개\n\n총 경우의 수는 2이다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 1000)가 주어진다.\n각 테스트 케이스는 한 줄로 이루어져 있으며, 정수 N(0 ≤ N ≤ 109)과 M(1 ≤ M ≤ 109)이 공백으로 구분되어 주어진다.\n",
        "output_text": "각 테스트 케이스마다 한 줄에 하나씩 나이를 먹는 방법의 가짓 수를 100007로 나눈 나머지를 출력하시오. 100007은 일반적이지 않은 나눗수임에 유의하라.\n",
        "memory_median": 2688.0,
        "time_median": 8.0,
        "length_median": 1593.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "641": {
        "problem_text": "홍준 왕국의 국왕 홍준이는 자신을 호위하는 N명의 친위대 병사가 있다. 병사들의 키는 모두 다르다. 홍준이는 그들을 일렬로 세울 때, 키 순서대로 세우는 것보다 맨 끝 두 병사를 제외한 나머지 병사들의 양 옆 두 병사의 키가 자신 보다 크거나 모두 자신보다 작을 때 보기 좋다고 생각한다. 예를 들어, 홍준이에게 7명의 친위대 병사가 있고, 그 들의 키가 160, 162, 164, 166, 168, 170, 그리고 172cm 라고 하자. 아래와 같이 병사가 일렬로 서있으면 홍준이는 보기 좋다고 생각한다.\n\n\n만약 홍준이가 매일 같은 병사 배치를 본다면 매우 지루해할 것이다. 때문에 매일 병사들의 배치를 새롭게 하고 싶다. 즉, 병사 N명이 있을 때 서로 다른 배치가 몇 가지 있는지 알고 싶어한다.\n예를 들어, 병사가 4명이 있고 편의상 그들의 키를 1, 2, 3, 4라고 나타내자. 그러면 아래와 같이 10가지 배치가 가능하다.\n1324, 2143, 3142, 2314, 3412, 4231, 4132, 2413, 3241, 1423\n병사의 수 N이 주어졌을 때, 가능한 배치의 수를 구하는 프로그램을 작성하자.\n",
        "input_text": "첫 줄에 테스트케이스 수 T가 주어진다. (1 ≤ T ≤ 1,000)\n각 테스트케이스마다 병사의 수를 나타내는 자연수 N이 주어진다. (1 ≤ N ≤ 20)\n",
        "output_text": "각 테스트케이스 마다 가능한 배치의 수를 줄로 구분하여 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 798.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "642": {
        "problem_text": "상도시의 차량 번호판 형식이 주어졌을 때, 가능한 차량 번호판의 개수를 구해보자.\n\n번호판에 사용할 수 있는 숫자는 0, 1, 2, ..., 8, 9이다.\n사용할 수 있는 문자는 a, b, c, d, ..., y, z이다.\n차량 번호판의 형식은 최대 1,000,000글자이고, c와 d로 이루어진 문자열로 나타낼 수 있다.\nc는 문자가 위치하는 자리, d는 숫자가 위치하는 자리이다.\n같은 문자 또는 숫자가 연속해서 2번 나타나면 안 된다.\n\n예를 들어, 형식이 \"cd\"이면, a1, d4, h5, k4 등이 가능하다. 형식이 \"dd\"인 경우에 01, 10, 34, 69는 가능하지만, 00, 11, 55, 66은 같은 숫자가 2번 연속해서 불가능하다.\n",
        "input_text": "첫째 줄에 차량 번호판의 형식이 주어진다. 형식은 길이가 1,000,000보다 작거나 같으며, c와 d로만 이루어져 있다.\n",
        "output_text": "첫째 줄에 가능한 차량 번호판의 개수를 1,000,000,009로 나눈 나머지를 출력한다.\n",
        "memory_median": 3680.0,
        "time_median": 16.0,
        "length_median": 536.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "643": {
        "problem_text": "루나와 리나는 타워 건설 게임을 하려고 한다. 타워 건설 게임은 $K$개의 타워를 사용하는 게임이고 루나는 이 게임을 세팅하려고 한다. \n게임 세팅은 서로 다른 높이의 $N$개의 타워 중 $K$개를 선택해 원하는 순서로 일렬로 배치하는 것이다. 이때 앞과 뒤에서 바라볼 때 모든 타워가 최소 한 번은 보여야 한다. 즉, 어떤 타워에 대해서 그보다 높은 타워가 그 타워의 앞쪽과 뒤쪽에 모두 존재하면 안된다는 것이다. \n게임 세팅을 하던 루나는 문득 게임을 세팅하는 방법이 얼마나 많을 지가 궁금해졌다. 루나를 도와서 게임 세팅을 하는 경우의 수를 구해보자. \n",
        "input_text": "첫째 줄에는 두 양의 정수 $N$과 $K$가 주어진다.\n둘째 줄에는 각각의 타워의 높이 $A_{1}, A_{2}, \\cdots, A_{N}$이 공백으로 구분되어 주어진다.\n모든 입력은 정수이다.\n",
        "output_text": "게임 세팅을 할 수 있는 경우의 수를 $10^{9}+7$로 나눈 나머지를 출력한다. \n",
        "memory_median": 17660.0,
        "time_median": 12.0,
        "length_median": 719.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "644": {
        "problem_text": "동물원에 동물이 N마리 있고, 1번부터 N번가지 번호가 매겨져 있다. 이 동물원에 동물은 토끼나 고양이밖에 없고, 모든 동물의 키는 다 다르다.\n수빈이는 토끼와 고양이를 구분할 수 없지만, 토끼와 고양이와 대화를 할 수 있다!\n수빈이는 모든 동물에게 다음과 같은 질문을 했다.\n\"너랑 같은 동물 중에서 너보다 키가 큰 동물은 몇 마리야?\"\n모든 토끼는 자신보다 키가 큰 토끼의 수를 말해줬고, 모든 고양이도 자신보다 키가 큰 고양이의 수를 말해줬다.\n모든 동물의 대답이 주어졌을 때, 각 대답을 어떤 동물이 했는지 알아내려고 한다. 가능한 조합의 수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 동물의 수 N (1 ≤ N ≤ 40)이 주어진다.\n둘째 줄에는 각 동물의 대답이 주어진다. 대답은 0보다 크거나 같고, 40보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 가능한 조합의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 735.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "645": {
        "problem_text": "체스 세계랭킹 1위의 숌은 더 이상 체스를 대결할 상대가 없자, 새로운 체스방법을 생각했다.\n일단 Rook은 체스판의 같은 열, 혹은 같은 행에 다른 말이 있을 경우, 그 말을 공격할 수 있는 말이다.\n숌은 N * M 크기의 체스판에 K개의 룩을 놓는데, 서로 공격받지 않는 경우의 수를 구하는 문제를 생각했다. 이 문제는 너무 쉽게 풀려서 숌은 좀 더 어려운 문제를 찾다가 각 룩이 최대 1개의 룩에만 공격받는 경우의 수가 궁금해졌다. 어떤 룩은 공격받지 않을 수도 있다.\nN*M크기의 체스판이 주어졌을 때, K개의 룩을 놓을 때, 각 룩이 최대 1개의 룩에만 공격받는 경우의 수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 체스판의 세로 크기 N, 둘째 줄에 가로 크기 M, 셋째 줄에 놓으려고 하는 룩의 수 K가 주어진다.\n",
        "output_text": "N * M 크기의 체스판에 K개의 룩을 놓을 때, 각 룩이 최대 1개의 룩에만 공격받는 경우의 수를 1,000,001로 나눈 나머지를 출력한다.\n",
        "memory_median": 10068.0,
        "time_median": 8.0,
        "length_median": 738.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "646": {
        "problem_text": "휘파람을 불지 못하는 시루는 휘파람을 불기 위해 수없이 많이 시도했지만 항상 실패한다. 시루의 휘파람 연습을 도와주고 있는 루시는, 시루가 휘파람과 비슷한 소리를 낼 때마다 사탕을 주기로 했다.\n시루의 입에서 나온 소리는 대문자로 구성된 문자열 $S$로 나타낼 수 있다. 루시는 문자열 $S$에서 휘파람과 비슷한 소리, 즉 '유사 휘파람 문자열'의 개수를 구해야 한다. '유사 휘파람 문자열'은 다음과 같이 정의한다.\n\nWHEE는 '유사 휘파람 문자열'이다.\n'유사 휘파람 문자열' 뒤에 E를 붙인 것 또한 '유사 휘파람 문자열'이다.\n\n'유사 휘파람 문자열'은 문자열 $S$ 상에서 연속하지 않아도 된다. 즉, $S$에서 '유사 휘파람 문자열'인 부분 수열(subsequence)의 개수를 구하면 된다.\n시루는 수없이 많이 시도했기 때문에 $S$의 길이가 너무 길어졌다. 루시를 도와 시루에게 사탕을 몇 개 줘야 할지 계산해주자.\n",
        "input_text": "첫째 줄에 문자열 $S$의 길이 $N$이 주어진다.\n둘째 줄에 대문자로만 구성된 문자열 $S$가 주어진다.\n",
        "output_text": "'유사 휘파람 문자열'인 부분 수열의 개수를 $1\\,000\\,000\\,007(= 10^9+7)$로 나눈 나머지를 출력한다.\n",
        "memory_median": 5480.0,
        "time_median": 8.0,
        "length_median": 829.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "647": {
        "problem_text": "크기 $N$인 집합 $A = \\{A_1, A_2, \\cdots, A_N\\}$와 정수 $K$가 주어집니다. $A$의 부분집합 $S$가 좋은 집합이라는 것은 다음 조건을 모두 만족시킴을 의미합니다.\n\n$S$에는 두 개 이상의 수가 포함되어 있습니다.\n$S$의 서로 다른 두 원소 $a, b \\in S$에 대해서, $a + b$는 $K$의 배수가 아닙니다.\n\n좋은 집합의 개수를 출력하세요.\n",
        "input_text": "첫 줄에 정수의 개수 $N$과 문제의 정수 $K$가 공백으로 구분되어 주어집니다. $(2 \\le N, K \\le 100\\,000)$\n둘째 줄에 $N$개의 서로 다른 정수 $A_1, A_2, \\cdots, A_N$이 공백으로 구분되어 주어집니다. $(1 \\le A_i \\le 10^9)$\n",
        "output_text": "첫 줄에 좋은 집합의 개수를 출력하세요. 단, 수가 매우 커질 수 있으니 $1\\,000\\,000\\,007 (= 10^9+7)$로 나눈 나머지를 출력하세요. $1\\,000\\,000\\,007$은 소수입니다.\n",
        "memory_median": 3194.0,
        "time_median": 16.0,
        "length_median": 946.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "648": {
        "problem_text": "Gandalf’s search for the history of the One Ring took him to the library of Minas Babel, under the care of Archivist Borges. This library contains every possible book - true and false, nonsensical and insightful - and Gandalf must use all of this wisdom to find the true account of the Ring.\nGiven that there are C possible characters, W characters in a line, L lines on a page, and P pages in a book, tell how many books are in the library of Minas Babel, if each possible book appears exactly once.\nFor example, if the library were to contain books with 2 characters (a,b), 3 characters per line, one line per page, and one page per book, then the following books would be in the library: aaa aab aba abb baa bab bba bbb\n",
        "input_text": "Each test case is on its own line, each of the form C W L P; all are non-negative integers. The end of input is marked by a line of the form ”0 0 0 0”, which should produce no output.\n",
        "output_text": "For each test case, output a new line containing a single integer, which should represent the number of books in the library.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 366.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "649": {
        "problem_text": "Farmer John has $N$ cows ($1\\le N \\leq 20$) of heights $a_1 \\ldots a_N$. His barn has $N$ stalls with max height limits $b_1 \\ldots b_N$ (so for example, if $b_5 = 17$, then a cow of height at most $17$ can reside in stall $5$). In how many distinct ways can Farmer John arrange his cows so that each cow is in a different stall, and so that the height limit is satisfied for every stall?\n",
        "input_text": "The first line contains $N$. The second line contains $N$ space-separated integers $a_1,a_2,\\ldots,a_N$. The third line contains $N$ space-separated integers $b_1,b_2,\\ldots,b_N$. All heights and limits are in the range $[1,10^9]$.\n",
        "output_text": "The number of ways Farmer John can place each cow into a different stall such that the height limit is satisfied for every stall. Note that the large size of the output might require the use of a 64-bit integer, like a \"long long\" in C++.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 647.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "650": {
        "problem_text": "오늘도 서준이는 동적 프로그래밍 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.\n양의 정수로 이루어진 n × n 행렬 m이 주어진다. 행렬의 왼쪽 위에서 시작해 한 칸씩 이동해 오른쪽 아래까지 도달한다. 이 과정에서 방문한 칸에 있는 수들을 더한 값이 이 경로의 합이다. 이동 규칙은 다음과 같다.\n\n오른쪽이나 아래쪽으로만 이동할 수 있다.\n왼쪽, 위쪽, 대각선 이동은 허용하지 않는다.\n\n행렬의 원소 (1, 1)에서 (n, n)으로 이동하는 모든 경로의 점수 중 가장 높은 점수를 구하는 행렬 경로 문제 의사코드는 아래와 같다. 재귀호출에 비해 동적 프로그래밍이 얼마나 빠른지 확인해 보자. 행렬의 크기 n과 행렬 m이 주어진 경우 코드1 코드2 실행 횟수를 출력하자.\n행렬 경로 문제 재귀호출 의사 코드는 다음과 같다.\n\r\nmatrix_path(m[][], n) {  # (1, 1)에서 (n, n)에 이르는 최고 점수를 구한다.\r\n    return matrix_path_rec(m, n, n);\r\n}\r\nmatrix_path_rec(m[][], i, j) {  # (1, 1)에서 (i, j)에 이르는 최고 점수를 구한다.\r\n    if (i == 0 or j == 0) then\r\n        return 0; # 코드1\r\n    else\r\n        return (mij + (max(matrix_path(m, i-1, j), matrix_path(m, i, j-1))));\r\n}\n행렬 경로 문제 동적 프로그래밍 의사 코드는 다음과 같다.\n\r\nmatrix_path(m[][], n) {  # (1, 1)에서 (n, n)에 이르는 최고 점수를 구한다.\r\n    for i <- 0 to n\r\n        d[i, 0] <- 0;\r\n    for j <- 1 to n\r\n        d[0, j] <- 0;\r\n    for i <- 1 to n\r\n        for j <- 1 to n\r\n            d[i, j] <- mij + max(d[i - 1, j], d[i, j - 1]);  # 코드2\r\n    return d[n, n];\r\n}\n",
        "input_text": "첫째 줄에 행렬의 크기 n(5 ≤ n ≤ 1,000)이 주어진다.\n그 다음 n개의 줄에는 각 줄마다 행렬의 각 행을 나타내는 n개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 1 이상 100,000 이하이다.\n",
        "output_text": "코드1 코드2 실행 횟수를 1,000,000,007로 나눈 나머지를 한 줄에 출력한다.\n",
        "memory_median": 9400.0,
        "time_median": 96.0,
        "length_median": 520.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "651": {
        "problem_text": "$\\textrm{mex}(S)$는 집합 $S$에 포함되지 않은 가장 작은 음이 아닌 정수이다.\n$N$개의 $0$ 이상의 정수 $A_1, A_2, \\dots, A_N$이 주어질 때, 다음 값을 구하는 프로그램을 작성하시오.\n$$\\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} \\textrm{mex}(\\{A_i, A_j\\})$$\n",
        "input_text": "첫째 줄에 정수 $N$이 주어진다. ($2 \\le N \\le 200\\,000$)\n둘째 줄에 $N$개의 정수 $A_1, A_2, \\dots, A_N$이 공백으로 구분되어 주어진다. ($0 \\le A_i \\le 100\\,000$)\n",
        "output_text": "문제에서 요구하는 값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 16.0,
        "length_median": 507.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "652": {
        "problem_text": "리프는 카드 뽑기 놀이를 하고 있다. $N$장의 카드가 일렬로 나열되어 있고, 각각의 카드에는 양의 정수 1개가 적혀있다. 카드 뽑기 놀이는 다음과 같은 과정으로 진행된다.\n\n1번째 카드부터 $N$번째 카드까지 차례로 보면서 뽑을지 말지 결정한다. 각 카드를 뽑는 시행은 독립적이다.\n뽑은 카드가 없을 경우 뽑기를 다시 진행한다.\n뽑은 카드에 적힌 정수들이 모두 다를 경우 게임에서 승리한다.\n\n리프가 각 카드를 뽑을 확률이 정확히 $\\frac{1}{2}$라고 할 때, 게임에서 승리할 확률 $p$를 구하여라.\n",
        "input_text": "첫 번째 줄에 정수 $N$이 주어진다.\n두 번째 줄에 $N$개의 정수 $A_1, A_2, \\ldots, A_N$이 주어진다. $i$번째 카드에 적힌 정수는 $A_i$이다.\n",
        "output_text": "첫 번째 줄에 $(2^N-1)p$를 $10^9+7$로 나눈 나머지를 출력한다. $(2^N-1)p$가 항상 정수임을 증명할 수 있다.\n",
        "memory_median": 3584.0,
        "time_median": 32.0,
        "length_median": 473.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "653": {
        "problem_text": "리유나는 양팔저울을 가지고 놀고 있다. 무게가 $2^1$, $2^2$, $\\cdots$, $2^N$인 $N$개의 추가 있고, 적당한 순서로 서로 다른 $N$개의 추를 하나씩 놓는 동안, 왼쪽의 무게가 오른쪽의 무게를 넘지 않도록 하고 싶다. 추를 놓는 순서의 경우의 수를 구하여라.\n",
        "input_text": "첫째 줄에는, $N$이 주어진다. ($1 \\le N \\le 50000$)\n",
        "output_text": "첫째 줄에, 추를 놓는 순서의 경우의 수를 구하여라. 단, 답이 매우 클 수 있으니, 1000000009 ($=10^9 + 9$) 로 나눈 나머지를 구하여라.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 296.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "654": {
        "problem_text": "인간의 염색체는 [‘A’, ‘C’, ‘G’, ‘T’] 네 가지 알파벳으로 대표되는 네 가지 염기로 이루어져 있다. 힘들게 의경에 붙었지만, 고급시계에 빠져버린 준서는 자기 대신 복무를 해줄 피노키오를 만들려고 한다.\n준서는 길이가 L인 염기열을 가지고 있는데, 이 염기열에서 각 1개씩의 ‘A’, ‘C’, ‘G’, ‘T’ 염기를 빼내어 합성하면 하나의 피노키오를 만들 수 있다. 자신이 직접 가는 것은 아니지만, 좋은 게 좋은 거라고 준서는 이 중 가장 일을 잘할 것 같은 피노키오를 만들려고 한다. 같은 염기더라도 염기열의 어디에 위치해 있느냐에 따라서 조금씩 다르므로, 완전히 같은 위치의 네 염기로 이루어진 게 아니라면 서로 다른 성질의 피노키오가 된다. 준서의 편안한 고급시계 생활을 위해 만들 수 있는 피노키오의 종류가 총 몇 개나 되는지 알려주자.\n",
        "input_text": "첫 줄에 문자열의 길이 L(1 ≤ L ≤ 1,000,000)이 주어진다. 둘째 줄에 길이 L의 문자열 S가 주어진다. 모든 문자는 ‘A’, ‘C’, ‘G’, ‘T’ 중 하나이다.\n",
        "output_text": "한 줄에 가능한 피노키오의 종류를 1,000,000,007로 나눈 나머지를 출력한다.\n",
        "memory_median": 3036.0,
        "time_median": 16.0,
        "length_median": 459.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "655": {
        "problem_text": "\t\t\t\tFarmer John has recently acquired $N$ new cows $(3 \\le N \\le 5 \\times 10^5)$, \r\neach of whose breed is either Guernsey or Holstein.  \r\n\r\nThe cows are currently standing in a line, and Farmer John wants take a photo\r\nof every sequence of three or more consecutive cows.  However, he doesn't want\r\nto take a photo in which there is exactly one cow whose breed is Guernsey or\r\nexactly one cow  whose breed is Holstein --- he reckons this singular cow would\r\nfeel isolated and self-conscious.  After taking a photo of every sequence of \r\nthree or more cows, he throws out all of these so-called \"lonely\" photos, in\r\nwhich there is exactly one Guernsey or exactly one Holstein.\r\n\r\nGiven the lineup of cows, please help Farmer John determine how many lonely\r\nphotos he will throw out.  Two photos are different if they start or end at\r\ndifferent cows in the lineup.\r\n\n\t\t\t\t",
        "input_text": "The first line of input contains $N$.\nThe second line contains a string of $N$ characters. The $i$th character is G if the $i$th cow in the line is a Guernsey. Otherwise, it will be an H and the $i$th cow is a Holstein.\n",
        "output_text": "Please print the number of photos Farmer John will throw out because they are lonely.\n",
        "memory_median": 3476.0,
        "time_median": 12.0,
        "length_median": 780.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0
        ]
    },
    "656": {
        "problem_text": "공학자 길동이는 외부의 침략으로부터 마을을 지킬 수 있는 부메랑 무기를 개발하는 공학자다. 길동이는 부메랑 제작을 위한 고급 나무 재료를 구했다. 이 나무 재료는 NxM크기의 직사각형 형태이며 나무 재료의 부위마다 그 강도가 조금씩 다르다.\n예를 들어 나무 재료의 크기가 2x3일 때는 다음과 같이 총 6칸으로 구성된다.\n\n길동이는 이처럼 넓은 사각형 형태의 나무 재료를 잘라서 여러 개의 부메랑을 만들고자 한다. 그리고 부메랑은 항상 3칸을 차지하는 ‘ㄱ’모양으로 만들어야 한다. 따라서 부메랑의 가능한 모양은 다음과 같이 총 4가지다.\n\n이때 부메랑의 중심이 되는 칸은 강도의 영향을 2배로 받는다. 위 그림에서 노란색으로 칠한 부분이 ‘중심이 되는 칸’이다. 예를 들어 앞선 예시에서는 다음과 같이 2개의 부메랑을 만들 수 있으며, 이때 만들어지는 부메랑들의 강도의 합은 46으로 이보다 강도의 합이 높아지는 경우는 없다.\n\n또한 나무 재료의 특정 위치는 아예 사용하지 않아도 괜찮다. 예를 들어 앞선 예시에서 다음과 같이 1개의 부메랑만을 만들어도 괜찮다. 다만, 이렇게 만들게 되면 부메랑들의 강도의 합이 18이 되기 때문에 비효율적이다.\n\n나무 재료의 형태와 각 칸의 강도가 주어졌을 때, 길동이가 만들 수 있는 부메랑들의 강도 합의 최댓값을 출력하는 프로그램을 작성하시오. \n",
        "input_text": "첫째 줄에는 길동이가 가지고 있는 나무 재료의 세로, 가로 크기를 의미하는 두 자연수 N, M이 주어진다. (1 ≤ N, M ≤ 5) 다음 N개의 줄에 걸쳐서, 매 줄마다 나무 재료의 각 위치의 강도를 나타내는 M개의 자연수 K가 공백을 기준으로 구분되어 주어진다. (1 ≤ K ≤ 100)\n",
        "output_text": "첫째 줄에 길동이가 만들 수 있는 부메랑들의 강도 합의 최댓값을 출력한다.\n단, 나무 재료의 크기가 작아서 부메랑을 하나도 만들 수 없는 경우는 0을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 12.0,
        "length_median": 1700.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "657": {
        "problem_text": "스도쿠가 세계적으로 유행이 된 이후에, 비슷한 퍼즐이 매우 많이 나왔다. 게임 매거진 2009년 7월호에는 스도쿠와 도미노를 혼합한 게임인 스도미노쿠가 소개되었다. \n이 퍼즐은 스도쿠 규칙을 따른다. 스도쿠는 9×9 크기의 그리드를 1부터 9까지 숫자를 이용해서 채워야 한다. 스도쿠는 다음과 같은 조건을 만족하게 숫자를 채워야 한다.\n\n각 행에는 1부터 9까지 숫자가 하나씩 있어야 한다.\n각 열에는 1부터 9까지 숫자가 하나씩 있어야 한다.\n3×3크기의 정사각형에는 1부터 9가지 숫자가 하나씩 있어야 한다.\n\n스도미노쿠의 그리드에는 1부터 9까지 숫자가 쓰여져 있고, 나머지 72칸은 도미노 타일 36개로 채워야 한다. 도미노 타일은 1부터 9까지 서로 다른 숫자의 가능한 쌍이 모두 포함되어 있다. (1+2, 1+3, 1+4, 1+5, 1+6, 1+7, 1+8, 1+9, 2+3, 2+4, 2+5, ...) 1+2와 2+1은 같은 타일이기 때문에, 따로 구분하지 않는다. 도미노 타일은 회전 시킬 수 있다. 또, 3×3 크기의 정사각형의 경계에 걸쳐서 놓여질 수도 있다.\n왼쪽 그림은 퍼즐의 초기 상태를 나타내고, 오른쪽은 퍼즐을 푼 상태이다.\n\n스도미노쿠의 퍼즐의 초기 상태가 주어졌을 때, 퍼즐을 푸는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 채워져 있는 도미노의 개수 N이 주어진다. (10 ≤ N ≤ 35) 다음 N개 줄에는 도미노 하나를 나타내는 U LU V LV가 주어진다. U는 도미노에 쓰여 있는 한 숫자이고, LU는 길이가 2인 문자열로 U의 위치를 나타낸다. V와 LV는 도미노에 쓰여 있는 다른 숫자를 나타낸다. 도미노의 위치는 문제에 나와있는 그림을 참고한다. 입력으로 주어지는 도미노의 각 숫자 위치는 항상 인접해 있다.\nN개의 도미노의 정보가 주어진 다음 줄에는 채워져 있는 숫자의 위치가 1부터 9까지 차례대로 주어진다. 위치는 도미노의 위치를 나타낸 방법과 같은 방법으로 주어진다.\n모든 도미노와 숫자가 겹치는 경우는 없다.\n입력의 마지막 줄에는 0이 하나 주어진다.\n",
        "output_text": "각 퍼즐에 대해서, 스도쿠를 푼 결과를 출력한다. 항상 답이 유일한 경우만 입력으로 주어진다.\n",
        "memory_median": 2024.0,
        "time_median": 4.0,
        "length_median": 3266.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "658": {
        "problem_text": "N×M 보드 위에서 할 수 있는 게임이 있다. 보드는 크기가 1×1인 정사각형 칸으로 나누어져 있다. 보드의 각 칸은 빈 칸 또는 장애물이다. 장애물은 아래 그림에선 어두운 사각형으로 표시되어져 있다.\n게임을 시작하려면 보드의 빈 칸 위에 공을 하나 놓아야 한다. 아래 그림에서 공은 회색 점으로 표시되어져 있다. 게임은 단계로 이루어져 있고, 각 단계는 아래와 같이 구성되어져 있다.\n\n위, 아래, 오른쪽, 왼쪽 중 방향 하나를 고른 다음, 그 방향으로 공을 계속해서 이동시킨다.\n공은 장애물, 보드의 경계, 이미 공이 지나갔던 칸을 만나기 전까지 계속해서 이동한다.\n\n게임은 공이 더 이상 이동할 수 없을 때 끝난다. 이 때, 모든 빈 칸을 공이 방문한 적이 있어야 한다.\n아래 그림은 총 10단계 만에 모든 칸을 방문하는 방법이다.\n\n보드의 상태가 주어졌을 때, 모든 칸을 방문하기 위한 이동 횟수의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 여러 개의 테스트 케이스로 이루어져 있다.\n각 테스트 케이스의 첫째 줄에는 보드의 크기를 나타내는 N과 M이 주어진다. N은 세로 크기, M은 가로 크기이고, 두 값은 30보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 상태가 주어진다. 보드의 상태는 장애물을 나타내는 '*'과 빈 칸을 나타내는 '.'으로 이루어져 있다.\n입력으로 주어진 보드가 장애물로만 이루어진 경우는 없다.\n",
        "output_text": "각 테스트 케이스마다 보드의 모든 빈 칸을 방문하는 최소 이동 횟수를 출력한다. 출력 형식은 예제를 참고한다.\n만약, 모든 빈 칸을 방문할 수 없다면 최소 이동 횟수는 -1이다. 가능한 이동 경로의 수는 1,000,000개를 넘지 않는다.\n",
        "memory_median": 2020.0,
        "time_median": 164.0,
        "length_median": 1822.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "659": {
        "problem_text": "길이가 N인 수식이 있다. 수식은 0보다 크거나 같고, 9보다 작거나 같은 정수와 연산자(+, -, ×)로 이루어져 있다. 곱하기의 연산자 우선순위가 더하기와 빼기보다 높기 때문에, 곱하기를 먼저 계산 해야 한다. 수식을 계산할 때는 왼쪽에서부터 순서대로 계산해야 한다. 예를 들어, 3+8×7-9×2의 결과는 41이다.\n수식에 괄호를 추가하면, 괄호 안에 들어있는 식은 먼저 계산해야 한다. 단, 괄호 안에는 연산자가 하나만 들어 있어야 한다. 예를 들어, 3+8×7-9×2에 괄호를 (3+8)×7-(9×2)와 같이 추가했으면, 식의 결과는 59가 된다. 하지만, 중첩된 괄호는 사용할 수 없다. 즉, 3+((8×7)-9)×2, 3+((8×7)-(9×2))은 모두 괄호 안에 괄호가 있기 때문에, 올바른 식이 아니다.\n수식이 주어졌을 때, 괄호를 적절히 추가해 만들 수 있는 식의 결과의 최댓값을 구하는 프로그램을 작성하시오. 추가하는 괄호 개수의 제한은 없으며, 추가하지 않아도 된다.\n",
        "input_text": "첫째 줄에 수식의 길이 N(1 ≤ N ≤ 19)가 주어진다. 둘째 줄에는 수식이 주어진다. 수식에 포함된 정수는 모두 0보다 크거나 같고, 9보다 작거나 같다. 문자열은 정수로 시작하고, 연산자와 정수가 번갈아가면서 나온다. 연산자는 +, -, * 중 하나이다. 여기서 *는 곱하기 연산을 나타내는 × 연산이다. 항상 올바른 수식만 주어지기 때문에, N은 홀수이다.\n",
        "output_text": "첫째 줄에 괄호를 적절히 추가해서 얻을 수 있는 결과의 최댓값을 출력한다. 정답은 231보다 작고, -231보다 크다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 2208.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "660": {
        "problem_text": "원장선생님께서는 1부터 N까지 번호가 붙은 N(K ≤ N ≤ 900)명의 학생들 중에서 K(1 ≤ K ≤ 62)명의 학생들을 소풍에 보내려고 한다. 그런데 원장선생님께서는 중간에 싸움이 일어나면 안되므로 소풍을 갈 학생들이 모두 서로 친구 사이이기를 원한다. 원장선생님께서는 이러한 일을 이번에 조교로 참가한 고은이에게 친구 관계에 대한 정보를 F(1 ≤ F ≤ 5,600)개를 주시며 K명을 선발하라고 부탁하였다.\n고은 조교를 도와 소풍을 가게 될 K명의 학생들을 결정하시오.\n",
        "input_text": "첫째 줄에 공백으로 분리된 세 정수 K, N, F가 주어진다. 다음 F개의 줄에는 서로 친구 관계인 두 사람의 번호가 주어진다. 친구 관계는 상호적인 관계이므로 2번 학생이 4번 학생을 좋아하면 4번 학생도 2번 학생을 좋아한다. 같은 친구 관계가 여러 번 주어지는 경우는 없다.\n",
        "output_text": "만약 K명의 친구 관계인 학생들이 존재하지 않는다면 -1을 출력한다. 그 외의 경우에는, K개의 줄에 학생들의 번호를 증가하는 순서로 한 줄에 한 개씩 출력한다. 여러 경우가 존재한다면 첫 번째 학생의 번호가 제일 작은 것을 출력한다. 첫 번째 학생의 번호가 같은 경우라면, 두 번째 학생의 번호가 작은 경우를 출력하고, 이와 같은 식으로 출력한다.\n",
        "memory_median": 2816.0,
        "time_median": 8.0,
        "length_median": 1147.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "661": {
        "problem_text": "눈송이들이 많은 동네인 숙명여대 앞마당에서 눈사람 만들기 대회를 연다. 앞마당의 길이는 $N$이고 위치 $1$부터 위치 $N$ 까지만 눈이 쌓여있다. 위치 $i$에 눈이 $a_i$만큼 쌓여있다. 대회 규칙은 해당 앞마당에서 $M$초 동안 눈덩이를 굴려 눈사람을 만드는 것이다. 눈덩이의 시작 크기는 $1$이다. 눈덩이의 시작 위치는 $0$이다.\n가장 큰 눈사람을 만들고 싶던 수수는 눈덩이를 굴리는 법을 연구했다. 눈덩이를 굴리는 방법에는 두 가지가 있다. 눈덩이를 굴리거나 던질 때 1초가 소모된다.\n\n눈덩이를 현재 위치 +1칸으로 굴린다. 현재 칸의 위치를 $i$라고 하면 눈덩이의 크기는 $a_{i+1}$ 만큼 늘어난다.\n눈덩이를 현재 위치 +2칸으로 던진다. 눈덩이가 착지하며 충격을 받아 눈덩이의 크기는 원래의 크기의 반으로 줄어들고  현재 칸의 위치를 $i$라고 하면 눈덩이의 크기는 $a_{i+2}$ 만큼 늘어난다. 이 때 소수점은 절사한다. 눈덩이를 던져 크기가 $0$이 되어도 눈덩이는 사라지지 않는다.\n\n눈덩이가 앞마당의 끝에 도달한 경우 남은 시간과 관계없이 눈덩이 굴리기는 끝이 난다. 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 구하는 프로그램을 작성해보자.\n",
        "input_text": "첫째 줄에 공백을 기준으로 앞마당의 길이 $N$ ($1 \\leq N \\leq 100$), 대회의 시간 $M$ ($1 \\leq M \\leq 10$)이 주어진다.\n둘째 줄에 길이가 $N$인 수열 $a$가 주어진다. ($1 \\leq a_i \\leq 1\\,000\\,000$)\n",
        "output_text": "첫째 줄에 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 618.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "662": {
        "problem_text": "1부터 N2까지의 수가 하나씩 채워져 있는 크기가 N×N인 배열이 있고, 이 배열의 모든 행, 열, 길이가 N인 대각선의 합이 모두 같을 때, 매직 스퀘어라고 한다.\n크기가 3×3인 배열 A가 주어졌을 때, 이 배열을 매직 스퀘어로 변경하려고 한다. 한 칸에 있는 수 a를 b로 변경하는 비용은 |a - b| 이다. 예를 들어, 아래와 같은 경우를 살펴보자.\n\r\n5 3 4\r\n1 5 8\r\n6 4 2\n이 배열의 수를 아래와 같이 변경하면 매직 스퀘어가 되고, 비용은 |5 - 8| + |8 - 9| + |4 - 7| = 7 이다.\n\r\n8 3 4\r\n1 5 9\r\n6 7 2\n3×3 크기의 배열 A가 주어졌을 때, 이 배열을 매직 스퀘어로 변경하는 비용의 최솟값을 구해보자. 배열 A는 1부터 9까지의 수로만 채워져 있고, 매직 스퀘어로 변경한 배열도 1부터 9까지의 수로만 채워져 있어야 한다.\n",
        "input_text": "총 세 개의 줄에 걸쳐서 배열 A의 원소가 주어진다.\n",
        "output_text": "첫째 줄에 배열 A를 매직 스퀘어로 변경하는 비용의 최솟값을 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 4.0,
        "length_median": 1158.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "663": {
        "problem_text": "진우는 민트초코우유를 좋아하는 민초단이다. 힘든 일이 있더라도 민트초코우유 하나를 마시면 기운이 펄펄 솟는다고 한다!\n민트초코우유를 너무 좋아하는 나머지 진우는 매일 아침 특정 지역들에서 민트초코우유가 배달된다는 N × N 크기의 2차원 민초마을로 이사를 하였다.\n진우는 아침에 눈을 뜨면 집에서 민초마을의 지도를 들고 민트초코우유를 찾으러 출발한다. 이때의 초기 체력은 M이다. 여기에서 체력은 진우가 이동할 수 있는 거리를 나타낸다. 진우는 지도상에서 상, 하, 좌, 우로 1칸씩 이동할 수 있으며 이동하면 체력이 1만큼 줄어든다. 진우가 마을을 돌아다니다가 민트초코우유를 마신다면 체력이 H 만큼 증가하며 진우의 체력이 초기체력 이상으로 올라갈 수 있다. 체력이 0이 되는 순간 진우는 이동할 수 없다.\n민트초코를 찾으러 돌아다니다가 마을 한복판에서 체력이 0이 되어 집으로 못 돌아가는 상황은 만들어져서는 안된다. 진우가 얼마나 많은 민트초코우유를 마시고 집으로 돌아올 수 있는지 알아보자.\n",
        "input_text": "첫번째 줄에 민초마을의 크기인 N과 진우의 초기체력 M, 그리고 민트초코우유를 마실때 마다 증가하는 체력의 양 H가 공백을 두고 주어진다. N, M, H는 모두 10보다 작거나 같은 자연수이다.\n두번째 줄부터 N+1번째 줄에 N칸에 걸쳐서 민초마을의 지도가 주어진다. 각 칸은 공백을 두고 주어지며 지도상에서 진우의 집은 1, 민트초코우유는 2로 주어지며 빈 땅은 0으로 주어진다. 진우의 집은 무조건 한 곳이 주어지며 마을에 배달되는 민트초코우유의 총합은 10개를 넘지 않는다.\n",
        "output_text": "진우가 집을 나와서 다시 집으로 돌아올 때 까지 마실 수 있는 민트초코우유의 최대 개수를 출력하자.\n",
        "memory_median": 2020.0,
        "time_median": 220.0,
        "length_median": 1209.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "664": {
        "problem_text": "준하는 노트에 수를 적다가 수가 만들어지는 방식을 깨달았다.\n처음에 어떤 숫자 하나를 적고 만들어진 수의 왼쪽이나 오른쪽에 숫자를 계속 붙이면 어떤 수 N이든 만들 수 있다는 것이다.\n다시 말해 어떤 수 N을 만들기 위해서는, 처음에 어떤 숫자를 하나 적고 아래의 두 가지 행동을 반복한다.\n\n수의 왼쪽에 숫자를 하나 적는다.\n수의 오른쪽에 숫자를 하나 적는다.\n\n준하는 어떤 수 N을 만드는 방법의 수가 몇 가지인지 궁금해졌다. 이를 알아내는 프로그램을 작성해주자. 숫자를 적는 과정에서 나온 수가 순서대로 모두 같다면 같은 방법이다.\n단, 숫자를 적는 과정에서 수는 0으로 시작할 수 있다.\n",
        "input_text": "음이 아닌 정수 N이 주어진다. (0 ≤ N ≤ 10,000,000)\n",
        "output_text": "N을 만드는 방법의 수를 출력한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 753.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "665": {
        "problem_text": "소싯적 호석이는 골목 대장의 삶을 살았다. 호석이가 살던 마을은 N 개의 교차로와 M 개의 골목이 있었다. 교차로의 번호는 1번부터 N 번까지로 표현한다. 골목은 서로 다른 두 교차로를 양방향으로 이어주며 임의의 두 교차로를 잇는 골목은 최대 한 개만 존재한다. 분신술을 쓰는 호석이는 모든 골목에 자신의 분신을 두었고, 골목마다 통과하는 사람에게 수금할 것이다. 수금하는 요금은 골목마다 다를 수 있다.\n당신은 A 번 교차로에서 B 번 교차로까지 C 원을 가지고 가려고 한다. 호석이의 횡포를 보며 짜증은 나지만, 분신술을 이겨낼 방법이 없어서 돈을 내고 가려고 한다. 하지만 이왕 지나갈 거면, 최소한의 수치심을 받고 싶다. 당신이 받는 수치심은 경로 상에서 가장 많이 낸 돈에 비례하기 때문에, 결국 갈 수 있는 다양한 방법들 중에서 최소한의 수치심을 받으려고 한다. 즉, 한 골목에서 내야 하는 최대 요금을 최소화하는 것이다.\n\n예를 들어, 위의 그림과 같이 5개의 교차로와 5개의 골목이 있으며, 당신이 1번 교차로에서 3번 교차로로 가고 싶은 상황이라고 하자. 만약 10원을 들고 출발한다면 2가지 경로로 갈 수 있다. 1번 -> 2번 -> 3번 교차로로 이동하게 되면 총 10원이 필요하고 이 과정에서 최대 수금액을 5원이었고, 1번 -> 4번 -> 5번 -> 3번 교차로로 이동하게 되면 총 8원이 필요하며 최대 수금액은 6원이 된다. 최소한의 수치심을 얻는 경로는 최대 수금액이 5인 경로이다. 하지만 만약 8원밖에 없다면, 전자의 경로는 갈 수 없기 때문에 최대 수금액이 6원인 경로로 가야 하는 것이 최선이다.\n당신은 앞선 예제를 통해서, 수치심을 줄이고 싶을 수록 같거나 더 많은 돈이 필요하고, 수치심을 더 받는 것을 감수하면 같거나 더 적은 돈이 필요하게 된다는 것을 알게 되었다. 마을의 지도와 골목마다 존재하는 호석이가 수금하는 금액을 안다면, 당신이 한 골목에서 내야하는 최대 요금의 최솟값을 계산하자. 만약 지금 가진 돈으로는 절대로 목표 지점을 갈 수 없다면 -1 을 출력하라.\n",
        "input_text": "첫 줄에 교차로 개수 N, 골목 개수 M, 시작 교차로 번호 A, 도착 교차로 번호 B, 가진 돈 C 가 공백으로 구분되어 주어진다. 이어서 M 개의 줄에 걸쳐서 각 골목이 잇는 교차로 2개의 번호와, 골목의 수금액이 공백으로 구분되어 주어진다. 같은 교차로를 잇는 골목은 최대 한 번만 주어지며, 골목은 양방향이다.\n",
        "output_text": "호석이가 지키고 있는 골목들을 통해서 시작 교차로에서 도착 교차로까지 C 원 이하로 가는 경로들 중에, 지나는 골목의 요금의 최댓값의 최솟값을 출력하라. 만약 갈 수 없다면 -1을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1293.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            1
        ]
    },
    "666": {
        "problem_text": "무한히 많은 정육각형이 서로 맞닿아 놓인 형태의 개미 우리가 있다. 다음 그림과 같은 형태이고, 하얀색 변으로만 개미가 다닐 수 있다.\n\n개미 우리의 모습\n곤충 관찰이 취미인 유이는 세 정육각형이 서로 맞닿아 있는 어떤 점 위에 개미를 하나 올렸다. 이렇게 우리에 올라온 개미는 그 자신에게 미지의 영역인 우리를 페로몬을 뿌리며 탐색하기 시작했다. 처음 개미는 점과 연결된 세 변 중 하나를 향해 이동을 시작하는데, 편의를 위해 이 첫 번째 이동이 북쪽을 향하도록 돌려서 보자.\n만약 개미가 변이 세 갈래로 갈라지는 점에 도착하면, 자신이 이동해온 변을 제외한 나머지 두 변 중 하나를 골라 그 방향으로 회전하여 탐색을 계속한다.\n\n연두색은 시작 지점, 초록색은 개미가 탐색하며 페로몬을 뿌린 경로. 검은색은 개미, 주황색은 다음 이동을 위해 선택 가능한 두 변을 나타낸다.\n개미가 이전에 방문했던, 즉, 페로몬이 뿌려진 지점에 도착하면 이곳이 이미 익숙한 영역이라는 착각에 빠지고 더 이상의 탐색을 멈춘다. 이렇게 탐색을 멈췄을 때, 방향을 회전한 횟수가 정확히 N번이 되는 경우의 수를 구해보자.\n\n방향을 7번 회전하는 두 경로. 페로몬의 궤적은 동일해도 개미의 이동 방향에 따라 경로를 구별하도록 한다.\n",
        "input_text": "첫 번째 줄에 하나의 정수 N(1 ≤ N ≤ 22)이 주어진다.\n",
        "output_text": "첫 번째 줄에 개미가 방향 회전을 N번 하고 멈추는 경우의 수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 24.0,
        "length_median": 979.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "667": {
        "problem_text": "대학교를 졸업한 준규는 농부의 꿈을 이루기 위해서 가로 5m, 세로 5m 크기의 땅을 구입했다. 준규는 땅을 가로 1m, 세로 1m 크기로 구역을 나누었다. 가장 왼쪽 위 칸은 (1,1)이고 가장 오른쪽 아래 칸은 (5,5)이다. 준규의 땅을 아래 그림과 같이 나타낼 수 있다.\n\r\n(1,1) (1,2) (1,3) (1,4) (1,5)\r\n(2,1) (2,2) (2,3) (2,4) (2,5)\r\n(3,1) (3,2) (3,3) (3,4) (3,5)\r\n(4,1) (4,2) (4,3) (4,4) (4,5)\r\n(5,1) (5,2) (5,3) (5,4) (5,5)\n구역 K개를 제외한 각각의 구역에는 사과 나무가 하나씩 심어져 있다. K개 구역에는 거대한 돌이 있기 때문에 사과 나무가 심어져 있지 않다.\n사과를 수확하는 일은 매우 귀찮은 일이다. 따라서, 준규는 친구 해빈이와 함께 재밌는 방법으로 수확을 하려고 한다.\n준규는 (1,1)에서 사과를 수확하기 시작하고, 해빈이는 (5,5)에서 시작한다. (1,1)과 (5,5)에는 항상 사과 나무가 심어져 있다.\n사과 나무 하나에 있는 모든 사과를 수확하는데 걸리는 시간은 항상 30분이다. 준규와 해빈이가 현재 있는 칸의 사과 나무에서 사과를 모두 수확하면, 인접한 칸 중 사과 나무가 있는 칸으로 이동한다. 이동하는데 걸리는 시간도 30분이다.\n준규와 해빈이는 준규의 땅에 있는 모든 사과를 수확할 것이고, 마지막에는 같은 칸에서 만나려고 한다. 이때, 이렇게 사과를 수확하는 방법의 수를 구하는 프로그램을 작성하시오.\n두 사람은 항상 사과가 있는 칸으로만 이동하며, 이미 수확을 마친 사과 나무가 있는 칸으로는 이동하지 않는다. 또, 마지막을 제외하고 같은 칸에서 만날 수는 없다.\n",
        "input_text": "첫째 줄에 K가 주어진다. 둘째 줄부터 K (0 ≤ K ≤ 22, K는 짝수)개 줄에는 사과 나무가 없는 칸의 위치 (i,j)가 주어진다.\n",
        "output_text": "문제에서 주어진 방법대로 사과를 모두 수확하는 방법의 수를 출력한다.\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 947.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "668": {
        "problem_text": "상근이는 자신이 다니는 학교에서 영어단어를 가장 많이 외우고 있다. 그 비법은 바로 조기교육이었다. 상근이는 젖병을 물기도 전에 영어 단어를 외웠다. 따라서, 지금은 자리에 앉으면 사전을 만들 수 있을 정도로 많이 외우게 되었다.\n더 이상 외울 단어가 없어진 상근이는 이제 단어를 만들기로 결심했다.\n상근이는 단어는 두 종류, 즐거운 단어와 즐겁지 않은 단어로 분류할 수 있다고 생각한다. 새로운 단어를 만들기 위해 즐겁지 않은 단어를 공책에 적는다. 그 다음, 보기 싫은 알파벳을 지우개로 지우고 그 자리에 밑 줄(_)을 적는다. 이렇게 보기 싫은 단어를 모두 지운 다음에는 즐거운 단어를 만들 수 있도록 밑 줄에 알파벳을 적는다.\n상근이에게 즐거운 단어란, 모음(A,E,I,O,U)이 연속해서 3번, 자음(모음을 제외한 나머지 알파벳)이 연속해서 3번 나오지 않아야 한다. 또, L을 반드시 포함해야 한다.\n상근이게 보기 싫은 알파벳을 지운 단어가 주어졌을 때, 즐거운 단어를 만들 수 있는 경우의 수를 세는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 상근이가 공책에 적은 단어가 주어진다. 단어의 길이는 최대 100이고, 알파벳 대문자와 밑 줄(_)로만 이루어져 있다. 단어에 포함된 밑 줄의 개수는 최대 10이다.\n",
        "output_text": "첫째 줄에, 밑 줄을 알파벳으로 바꿔 즐거운 단어를 만들 수 있는 경우의 수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1266.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "669": {
        "problem_text": "4×4 격자판에 1에서 16까지 정수 번호가 매겨진 16개 타일이 임의로 놓여져 있다. 타일을 움직여 그림 1과 같이 타일을 놓이게 하려고 한다.\n\n\n\n1\n2\n3\n4\n\n\n5\n6\n7\n8\n\n\n9\n10\n11\n12\n\n\n13\n14\n15\n16\n\n\n\n그림 1\n타일을 움직이는 방법은 하나의 행(가로줄)을 오른쪽으로 원하는 칸 수만큼 순환적으로 움직이거나, 하나의 열(세로줄)을 원하는 칸 수만큼 아래쪽으로 순환적으로 움직이는 것이다. 그림 2는 그림 1의 2번째 행을 오른쪽으로 2칸 움직인 것이다. 그림 1의 2번째 행의 오른쪽 끝에 있는 7번 타일과 8번 타일이 오른쪽 경계를 넘어가서 왼쪽 끝으로 옮겨갔다.\n\n\n\n1\n2\n3\n4\n\n\n7\n8\n5\n6\n\n\n9\n10\n11\n12\n\n\n13\n14\n15\n16\n\n\n\n그림 2\n그림 3은 그림 2의 3번째 열을 아래쪽으로 1칸 움직인 것이다. 그림 2의 3번째 열의 가장 아래에 있는 15번 타일이 가장 위쪽으로 옮겨갔다.\n\n\n\n1\n2\n15\n4\n\n\n7\n8\n3\n6\n\n\n9\n10\n5\n12\n\n\n13\n14\n11\n16\n\n\n\n그림 3\n그림 3과 같이 타일이 놓여진 격자판이 주어졌다면 3번째 열을 3칸 움직인 다음, 2번째 행을 2칸 움직이면 그림 1과 같이 타일이 놓이게 된다. 따라서 2번 움직이면 된다.\n1에서 16까지 번호가 매겨진 타일이 임의로 놓여져 있을 때 그림 1과 같이 타일이 놓일 수 있도록 타일을 움직이는 순서를 출력하는 프로그램을 작성하시오. 여기서 움직이는 횟수는 최소로 하여야 한다.\n",
        "input_text": "4×4 격자판에 놓여진 타일 번호가 행단 위로 4개 줄에 주어진다. 타일 번호는 1부터 16까지의 정수이다.\n각 줄에는 해당하는 행에 놓여지는 4개 타일의 번호가 빈칸을 사이에 두고 순서대로 주어진다.\n",
        "output_text": "첫 번째 줄에는 움직이는 횟수를, 두 번째 줄부터는 한 줄에 하나씩 타일을 움직이는 방법을 순서대로 출력한다.\n이때, 격자판의 i번째 행을 k칸 움직였다면 정수 1과 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 그리고 격자판의 i번째 열을 k칸 움직였다면 정수 2와 i와 k를 빈칸을 사이에 두고 한 줄에 출력한다. 여기서 i는 1 이상 4 이하, k는 1 이상 3 이하의 정수이다.\n",
        "memory_median": 1988.0,
        "time_median": 108.0,
        "length_median": 2031.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "670": {
        "problem_text": "가희는 고구마를 정말 좋아합니다.\n\n이번에도 어김 없이 고구마 냄새가 났는데, 고구마가 보이지 않습니다. 오빠가 방 안에 고구마를 숨겨 놓았기 때문입니다.\n오빠는 가희에게 하나의 게임을 제안하고, 게임의 규칙을 설명해 주었습니다. 게임 규칙은 아래와 같습니다.\n\n가희는 1초마다 상하좌우 방향 중 한 방향으로 1번 이동하거나, 이동하지 않고 그 자리에 머무를 수 있습니다.\n가희가 이동한 지점에 고구마가 있는 경우에는, 고구마를 먹습니다. 고구마를 먹는 데 걸리는 시간은 없다고 가정합니다.\n가희가 고구마를 먹으면, 고구마가 다시 그 자리에 생기지 않습니다.\n\n가희는 현재 위치에서 T초만큼 이동했을 때 고구마를 최대한 많이 먹고 싶습니다. 가희가 최대 몇 개의 고구마를 먹을 수 있는지 알려주세요.\n",
        "input_text": "첫 번째 줄에 맵의 세로 크기 R, 가로 크기 C, 가희가 이동하는 시간 T가 주어집니다.\n두 번째 줄부터 R+1번째 줄까지 길이가 C인 문자열이 주어집니다.\n주어지는 문자열에 있는 문자는 가희를 나타내는 'G', 고구마를 나타내는 'S', 빈 칸을 나타내는 '.', 장애물을 나타내는 '#' 중 하나 입니다.\n",
        "output_text": "문제에 대한 답을 출력합니다.\n",
        "memory_median": 2044.0,
        "time_median": 12.0,
        "length_median": 1139.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "671": {
        "problem_text": "N개의 수로 이루어진 수열 A1, A2, ..., AN이 주어진다. 또, 수와 수 사이에 끼워넣을 수 있는 N-1개의 연산자가 주어진다. 연산자는 덧셈(+), 뺄셈(-), 곱셈(×), 나눗셈(÷)으로만 이루어져 있다.\n우리는 수와 수 사이에 연산자를 하나씩 넣어서, 수식을 하나 만들 수 있다. 이때, 주어진 수의 순서를 바꾸면 안 된다.\n예를 들어, 6개의 수로 이루어진 수열이 1, 2, 3, 4, 5, 6이고, 주어진 연산자가 덧셈(+) 2개, 뺄셈(-) 1개, 곱셈(×) 1개, 나눗셈(÷) 1개인 경우에는 총 60가지의 식을 만들 수 있다. 예를 들어, 아래와 같은 식을 만들 수 있다.\n\n1+2+3-4×5÷6\n1÷2+3+4-5×6\n1+2÷3×4-5+6\n1÷2×3-4+5+6\n\n식의 계산은 연산자 우선 순위를 이용해 계산해야 한다. 연산자 우선 순위는 ×와 ÷가 +와 -보다 앞선다. 우선 순위가 같은 경우에는 앞에 있는 식을 먼저 계산한다. 또, 나눗셈은 정수 나눗셈으로 몫만 취한다. 이에 따라서, 위의 식 4개의 결과를 계산해보면 아래와 같다.\n\n1+2+3-4×5÷6 = 3\n1÷2+3+4-5×6 = -23\n1+2÷3×4-5+6 = 2\n1÷2×3-4+5+6 = 7\n\nN개의 수와 N-1개의 연산자가 주어졌을 때, 만들 수 있는 식의 결과가 최대인 것과 최소인 것을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 수의 개수 N(2 ≤ N ≤ 11)가 주어진다. 둘째 줄에는 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 100) 셋째 줄에는 합이 N-1인 4개의 정수가 주어지는데, 차례대로 덧셈(+)의 개수, 뺄셈(-)의 개수, 곱셈(×)의 개수, 나눗셈(÷)의 개수이다.\n",
        "output_text": "첫째 줄에 만들 수 있는 식의 결과의 최댓값을, 둘째 줄에는 최솟값을 출력한다. 최댓값과 최솟값이 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과가 나오는 입력만 주어진다. 또한, 식을 어떤 순서로 계산해도 중간에 계산되는 식의 결과도 항상 -10억보다 크거나 같고, 10억보다 작거나 같다.\n",
        "memory_median": 2024.0,
        "time_median": 8.0,
        "length_median": 1821.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "672": {
        "problem_text": "5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자는 사과가 1개 있는 격자, 장애물이 있는 격자, 빈칸으로 되어 있는 격자로 구분된다. 격자의 위치는 (r, c)로 표시한다. r은 행 번호, c는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다.\n현재 한 명의 학생이 (r, c) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한가지 방향으로 한 칸 이동할 수 있다. 학생이 사과가 있는 칸으로 이동하면 해당 칸에 있는 사과를 1개 먹는다. 장애물이 있는 칸으로는 이동할 수 없다. 학생이 지나간 칸은 학생이 해당 칸을 떠나는 즉시 장애물이 있는 칸으로 변경된다. 즉, 학생이 해당 칸에서 상, 하, 좌, 우 방향으로 한 칸 이동하는 즉시 해당 칸은 장애물이 있는 칸으로 변경된다.\n학생이 현재 위치 (r, c)에서 세 번 이하의 이동으로 사과를 2개 이상 먹을 수 있으면 1을 출력하고, 그렇지 않으면 0을 출력하자.\n",
        "input_text": "첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 정보가 주어진다. i번째 줄의 j번째 수는 보드의 (i - 1)번째 행, (j - 1)번째 열의 정보를 나타낸다. 보드의 정보가 1이면 해당 칸은 사과가 1개 있는 격자임을 나타내고, 0이면 빈칸이 있는 격자를 나타내고, -1이면 장애물이 있는 격자임을 나타낸다.\n다음 줄에 학생의 현재 위치 r, c가 빈칸을 사이에 두고 순서대로 주어진다.\n",
        "output_text": "첫 번째 줄에 학생이 현재 위치 (r, c)에서 세 번 이하의 이동으로 사과를 2개 이상 먹을 수 있으면 1을 출력하고, 먹을 수 없으면 0을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1076.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "673": {
        "problem_text": "가로, 세로 길이가 $N$인 정사각형 격자가 있다. 해당 격자에는 두 곳을 제외한 모든 곳에 체력을 1씩 감소시키는 죽음의 비가 내리고 있다. 죽음의 비가 안내리는 곳은 현재 있는 위치와 안전지대라는 곳이다. 현재 있는 위치에도 곧 비가 내릴 예정이라 빨리 이 죽음의 비를 뚫고 안전지대로 이동해야한다.\n다행히도 격자에는 죽음의 비를 잠시 막아주는 우산이 $K$개 존재한다. 우산에는 내구도 $D$라는 개념이 존재한다. 우산에 비를 맞으면 내구도가 1씩 감소하고, 내구도가 0이 되는 순간 우산은 사라진다. 문제에서 주어지는 우산의 내구도는 모두 $D$로 동일하다.\n격자에서 이동을 할 때 다음과 같이 순서로 진행된다.\n\n상하좌우로 이동한다. 만약 이동할 곳이 격자 밖이라면 이동할 수 없다. \n이동한 곳이 안전지대라면 반복을 종료한다.\n이동한 곳에 우산이 있다면 우산을 든다. 만약, 이동할 때부터 우산을 가지고 있다면 가지고 있는 우산을 버리고 새로운 우산으로 바꾼다.\r\n\t버린 우산은 더 이상 사용할 수 없다.\n죽음의 비를 맞았을 때, 우산을 가지고 있다면 우산의 내구도가 1이 감소하고 만약 우산을 가지고 있지 않는다면 체력이 1 감소한다.\n만약 우산의 내구도가 0이 되면 들고 있는 우산이 사라진다.\n만약 체력이 0이 되면 죽는다...\n아직 체력이 남았다면 안전지대까지 위 과정을 반복한다.\n\n현재 있는 위치에서 안전지대로 얼마나 빠르게 이동할 수 있는지 구해주자.\n",
        "input_text": "첫 번째 줄에 정사각형 격자의 한변의 길이인 $N$와 현재 체력 $H$, 우산의 내구도 $D$가 공백으로 구분되어 주어진다.\n다음 $N$개의 줄에는 정사각형 격자의 정보가 $N$개의 문자로 붙어서 주어진다. 이때 주어지는 문자는 우산은 \"U\", 현재 있는 위치 \"S\", 안전지대 \"E\", 빈 칸 \".\"만 존재한다. 현재 있는 위치 \"S\"와 안전지대 \"E\"는 반드시 1개 존재한다.\n",
        "output_text": "안전지대로 이동할 때 최소 이동 횟수를 출력한다. 만약 안전지대로 이동하지 못하는 경우에는 -1을 출력한다.\n",
        "memory_median": 2512.0,
        "time_median": 16.0,
        "length_median": 1872.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "674": {
        "problem_text": "복면산이란 수학 퍼즐의 일종으로, 어떤 계산식의 각 숫자들을 특정 문자로 바꾸면 각 문자가 어떤 숫자인지 맞추는 퍼즐이다.\n대표적으로 SEND+MORE=MONEY가 있다.\n\r\n  SEND\r\n+ MORE\r\n------\r\n MONEY\r\n\nS=9, E=5, N=6, D=7, M=1, O=0, R=8, Y=2로 바꾸면 식이 성립한다.\n\r\n  9567\r\n+ 1085\r\n------\r\n 10652\r\n\n복면산 문제가 주어질 때, 답이 존재하는지 여부를 출력하시오.\n단, 같은 문자는 같은 숫자에 대응되어야 하며, 서로 다른 문자는 서로 다른 숫자를 나타낸다. 또한, 수는 0으로 시작할 수 있다.\n",
        "input_text": "세 단어가 공백을 두고 주어진다. 첫 번째 단어와 두 번째 단어를 더한 결과가 세 번째 단어임을 의미한다.\n단어는 공백 없이 알파벳 대문자로만 이루어져 있으며 각 단어의 길이는 18자리를 넘지 않는다.\n",
        "output_text": "계산식에 해답이 존재한다면 YES를, 그렇지 않다면 NO를 한 줄에 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 256.0,
        "length_median": 1334.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "675": {
        "problem_text": "랭퍼드 수열은 다음 조건을 만족하는 길이 2n의 수열이다.\n\n1 이상 n 이하의 자연수가 각각 두 개씩 들어 있다.\n두 개의 1 사이에는 정확히 1개의 수가 있다.\n두 개의 2 사이에는 정확히 2개의 수가 있다.\n...\n두 개의 n 사이에는 정확히 n개의 수가 있다.\n\n예를 들어 3, 1, 2, 1, 3, 2은 n=3인 랭퍼드 수열이다.\nn이 주어졌을 때, 길이 2n의 랭퍼드 수열의 개수를 구하면 된다. 하지만 이렇게만 하면 재미가 없으니 조건 하나를 추가하고자 한다. x번째 수와 y번째 수는 같다는 조건이다. (이 번호는 1부터 시작한다.)\n",
        "input_text": "세 자연수 n, x, y가 주어진다. (2 ≤ n ≤ 12, 1 ≤ x < y ≤ 2n, 1 ≤ y-x-1 ≤ n)\n",
        "output_text": "x번째 수와 y번째 수가 같은 길이 2n의 랭퍼드 수열의 개수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 144.0,
        "length_median": 730.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "676": {
        "problem_text": "리유나와 라가는 메이플스토리라는 노동을 즐겨 한다. 메이플스토리에서는 키셋팅을 할 수 있는데, 키셋팅을 하면 원하는 키를 눌러서 원하는 스킬을 쓰게 할 수 있다.\n리유나와 라가는 원래 좋은 친구였다. 리유나는 레벨이 225인데, 라가는 레벨이 202밖에 되지 않는다. 라가는 리유나를 질투해서 메이플 레벨을 따라잡으려고 했다. 그래서 리유나가 메이플을 하지 못하도록 키보드에 있는 키를 n개만 빼고 모두 망가뜨려버렸다!\n하지만 리유나는 메이플에 이미 인생을 팔아버렸기 때문에, 키가 망가져도 일간 퀘스트를 계속해야만 했다! 그래서 2n개의 스킬들 중에서 n개를 적절히 키에 배치해서 어떻게든 일간 퀘스트를 해야만 했다!\n일간 퀘스트는 다음과 같이 진행된다. m개의 퀘스트들이 주어진다. 각각의 퀘스트에서는 k개의 스킬을 사용해야 한다. 만약 스킬을 사용할 수 없다면 그 퀘스트는 수행할 수 없다고 본다.\n리유나는 n개의 키에 스킬들을 배치하려고 한다. 실제 게임에서는 키셋팅을 마음대로 할 수 있고, 키셋팅을 하지 않아도 더블 클릭으로 스킬을 사용할 수 있지만, 여기서는 키셋팅을 한번 설정하면 그 날은 키셋팅을 다시 바꿀 수 없고 더블 클릭으로 스킬을 사용할 수 없다고 가정하다. 이 때 어떤 스킬들을 배치해야 가장 많은 양의 일간 퀘스트를 깰 수 있는지 구하여자.\n",
        "input_text": "첫째 줄에 키의 개수 n, 퀘스트의 개수 m, 퀘스트 당 사용해야 하는 스킬의 수 k가 주어진다. n은 10 이하, k는 n 이하의 양의 정수이며, m은 100 이하의 양의 정수이다.\r\n둘째 줄부터 m개의 줄에는 각각의 퀘스트에서 사용해야 하는 스킬들이 나온다. 스킬들의 이름은 1에서 2n까지의 정수로 주어진다.\n",
        "output_text": "첫째 줄에 가장 최적의 키배치를 했을 때 최대로 깰 수 있는 퀘스트의 개수를 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 12.0,
        "length_median": 946.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "677": {
        "problem_text": "틱택토(Tic-tac-toe) 게임은 두 플레이어가 번갈아가며 O와 X를 3x3판에 써서 같은 글자를 가로, 세로, 혹은 대각선 상에 놓이도록 하는 게임이다.\n먼저 3개의 연속 된 O 또는 X를 완성시킨 플레이어가 승리하게 된다. 이 게임은 무승부가 가능하다.\n\nFigure: 게임의 진행과정 예시\n틱택토 초보 승현이와 기영이는 틱택토 게임을 플레이하고 있었다. 그런데 뒤에서 지켜보고 있던 틱택토 초고수 윤영이와 진욱이가 너무나 답답한 나머지 본인들이 대신 플레이를 해주겠다고 나섰다.\n지금까지 진행 된 틱택토 게임 보드가 주어졌을 때, 이번에 착수하는 플레이어가 얻을 수 있는 최선의 게임 결과는 무엇일까? 단, 두 플레이어는 항상 모든 경우를 고려하여 최선의 수를 둔다고 가정한다.\n",
        "input_text": "현재까지 진행된 틱택토 게임 보드가 띄어쓰기로 구분되어 3줄에 걸쳐 주어진다. 0은 빈칸, 1은 X, 2는 O를 의미한다. 단, 항상 X가 선공이다. 그리고 이미 게임이 종료된 상태는 입력으로 주어지지 않는다.\n",
        "output_text": "첫째 줄에 주어진 게임 보드에서 이번에 착수하는 플레이어가 얻을 수 있는 최선의 게임 결과를 출력한다.\n\n이기는 경우 \"W\", 무승부인 경우 \"D\", 지는 경우 \"L\"을 출력한다.\n\n",
        "memory_median": 2020.0,
        "time_median": 12.0,
        "length_median": 1822.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "678": {
        "problem_text": "미미는 미적 감각이 뛰어난 미술가이다. 미미는 때때로 여러 물감을 섞어 새로운 색의 물감을 만들고는 한다. 어느 날 그림을 그리던 미미는 놀라 자빠질 수밖에 없었다. 미미가 가장 아끼는 곰두리색 물감이 다 떨어졌기 때문이다. 하지만 미미는 새 물감을 살 돈이 없다. 물감은 역시 섞어 써야 제맛이다. 미미는 남은 물감들을 섞어 곰두리색 물감을 만들기로 결심하였다.\n먼저 RGB 표기법에 대하여 알아보자. RGB 표기법은 빨간색(Red), 초록색(Green), 파란색(Blue)을 혼합하여 색을 나타내는 방법으로, 각각의 색은 밝기에 따라 0부터 255까지의 정수로 표현한다. 예를 들어, 분홍색은 rgb(255, 192, 203)과 같이 표현한다. 이는 빨간색을 255만큼, 초록색을 192만큼, 파란색을 203만큼 혼합하였다는 의미이다.\n새로운 물감을 만들기 위해서는 남아 있는 물감 중 혼합할 물감들을 선택한 후 이들을 동일한 비율로 섞는다. P1, P2, ..., PK번 물감을 섞어 새로 만들어지는 색은 RGB 표기법으로 다음과 같다.\n$$rgb\\left(\\left\\lfloor\\frac{1}{K}\\sum_{i=1}^K R_{P_i}\\right\\rfloor,\\left\\lfloor\\frac{1}{K}\\sum_{i=1}^K G_{P_i}\\right\\rfloor,\\left\\lfloor\\frac{1}{K}\\sum_{i=1}^K B_{P_i}\\right\\rfloor\\right)$$\n즉, 새로운 R 값은 혼합할 모든 물감의 R 값을 더한 후 이를 물감의 개수로 나누어 구한다. 이때 소수점은 버린다. G와 B 값도 동일한 방법으로 구한다.\n색 i와 색 j의 차이는 다음과 같다.\n$$|R_i-R_j|+|G_i-G_j|+|B_i-B_j|$$\n물감들을 섞어서 만들 수 있는 색 중 곰두리색에 가장 가까운, 즉 곰두리색과의 차이가 가장 작은 색을 문두리색이라고 한다. N개의 물감과 곰두리색이 주어졌을 때, 곰두리색과 문두리색의 차이를 구하는 프로그램을 작성하시오. 단, 미미는 아직 실력이 부족하여 최대 7개의 색만을 혼합할 수 있다. 또한 물감을 섞지 않고 단독으로 사용할 수 없다.\n",
        "input_text": "첫 번째 줄에 물감의 개수 N이 주어진다.\n이후 N개의 줄 중 i(1 ≤ i ≤ N)번째 줄에는 i번 물감의 Ri, Gi, Bi 값이 주어진다.\n다음 줄에 곰두리색의 Rg, Gg, Bg 값이 주어진다.\n모든 입력은 정수이며 공백으로 구분되어 주어진다.\n",
        "output_text": "첫 번째 줄에 곰두리색과 문두리색의 차이를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 68.0,
        "length_median": 1031.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "679": {
        "problem_text": "Every day, Farmer John milks his 8 dairy cows, named Bessie, Buttercup, Belinda, Beatrice, Bella, Blue, Betsy, and Sue.\nThe cows are rather picky, unfortunately, and require that Farmer John milks them in an order that respects $N$ constraints ($1 \\leq N \\leq 7$). Each constraint is of the form \"$X$ must be milked beside $Y$\", stipulating that cow $X$ must appear in the milking order either directly after cow $Y$ or directly before cow $Y$.\nPlease help Farmer John determine an ordering of his cows that satisfies all of these required constraints. It is guaranteed that an ordering is always possible. If several orderings work, then please output the one that is alphabetically first. That is, the first cow should have the alphabetically lowest name of all possible cows that could appear first in any valid ordering. Among all orderings starting with this same alphabetically-first cow, the second cow should be alphabetically lowest among all possible valid orderings, and so on.\n",
        "input_text": "The first line of input contains $N$. The next $N$ lines each contain a sentence describing a constraint in the form \"$X$ must be milked beside $Y$\", where $X$ and $Y$ are names of some of Farmer John's cows (the eight possible names are listed above).\n",
        "output_text": "Please output, using 8 lines, an ordering of cows, one cow per line, satisfying all constraints. If multiple orderings work, output the one that is alphabetically earliest.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1145.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "680": {
        "problem_text": "a와 b로만 이루어진 문자열 s이 있다. 그룹은 같은 글자로 이루어진 가장 긴 연속 부분 문자열이다. 길이가 2 이상인 s의 모든 그룹 g는 제거할 수(뽑을 수) 있고, 남은 왼쪽 부분과 오른쪽 부분을 연결해서 새 문자열을 만들 수 있다. 이러한 과정은 문자열이 빈 문자열이 되거나, 길이가 2 이상인 그룹이 없을 때 까지 계속한다.\n예를 들어, s = babbbaaabb일 때, s에는 그룹이 다섯 개 있다. s는 다음과 같은 단계를 거쳐서 빈 문자열로 바꿀 수 있다. (밑 줄이 그어져 있는 그룹이 뽑히는 그룹)\nbabbbaaabb → baaaabb → bbb → 빈 문자열\n하지만, 아래와 같은 단계를 거친다면, 빈 문자열로 바꿀 수 없다.\nbabbbaaabb → babbbaaa → baaaa → b\n문자열이 주어졌을 때, 적절한 과정을 거쳐 빈 문자로 바꿀 수 있는지 없는지를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 a와 b로 이루어진 문자열로 이루어져 있다. 문자열의 길이는 1보다 크거나 같고, 25보다 작거나 같다.\n",
        "output_text": "각 테스트 케이스에 대해서, 입력으로 주어진 문자열을 빈 문자열로 바꿀 수 있으면 1을, 없으면 0을 출력한다. \n",
        "memory_median": 2020.0,
        "time_median": 224.0,
        "length_median": 889.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "681": {
        "problem_text": "Farmer John has two milking barns, each of which has a large milk tank as well as a storage closet containing $10$ buckets of various sizes. He likes to carry milk back and forth between the two barns as a means of exercise.\nOn Monday, Farmer John measures exactly $1000$ gallons of milk in the tank of the first barn, and exactly $1000$ gallons of milk in the tank of the second barn.\nOn Tuesday, he takes a bucket from the first barn, fills it, and carries the milk to the second barn, where he pours it into the storage tank. He leaves the bucket at the second barn.\nOn Wednesday, he takes a bucket from the second barn (possibly the one he left on Tuesday), fills it, and carries the milk to the first barn, where he pours it into the storage tank. He leaves the bucket at the first barn.\nOn Thursday, he takes a bucket from the first barn (possibly the one he left on Wednesday), fills it, and carries the milk to the second barn, where he pours it into the tank. He leaves the bucket at the second barn.\nOn Friday, he takes a bucket from the second barn (possibly the one he left on Tuesday or Thursday), fills it, and carries the milk to the first barn, where he pours it into the tank. He leaves the bucket at the first barn.\nFarmer John then measures the milk in the tank of the first barn. How many possible different readings could he see?\n",
        "input_text": "The first line of input contains $10$ integers, giving the sizes of the buckets initially at the first barn. The second line of input contains $10$ more integers, giving the sizes of the buckets initially at the second barn. All bucket sizes are in the range $1 \\dots 100$.\n",
        "output_text": "Please print the number of possible readings Farmer John could get from measuring the milk in the tank of the first barn after Friday.\n",
        "memory_median": 2000.0,
        "time_median": 0.0,
        "length_median": 1019.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "682": {
        "problem_text": "Hello, BOJ 2023! 대회는 2023년의 시작을 기념하는 알고리즘 문제해결 대회이다.\n다들 저마다의 이유로 올 한 해를 기대하고 있겠지만, Good Bye, BOJ 2022!와 Hello, BOJ 2023! 두 대회의 운영진들은 대회장에서 참가자 여러분을 만날 수 있게 되어 감사한 마음으로 2023년을 한껏 기대하고 있다.\n하지만 위대한 수학자 준겸이는 2023년을 조금 다른 방식으로도 기대하고 있는 것 같다. 준겸이에 의하면, 2023이라는 수는 다음의 두 등식:\n\n$2^1+0^1+2^1+3^1=2+0+2+3$\n$2^3+0^3+2^3+3^3=20+23$\n\n을 동시에 만족하기 때문에, 올해도 좋은 해가 될 것이라고 한다.\n여러분은 이 얘기를 듣고, 다른 연도에 대해서도 준겸이가 말한 좋은 성질이 성립하는지가 궁금해졌다.\n$10$진법으로 표기된 양의 정수 $n=\\overline{d_0d_1\\cdots d_k}$ 가 주어진다. $n$의 자릿수 사이사이에 $0$개 이상의 $+$ 기호를 넣어서 계산했을 때, 그 값이 $d_0^m+d_1^m+\\cdots +d_k^m$ 과 같아지도록 하는 양의 정수 $m$의 개수를 구하면 된다. \n$+$ 기호를 삽입하는 방법의 수가 아닌, $m$의 개수를 구해야 함에 유의하여라. \n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 $T$가 주어진다.\n이후 $T$개의 줄에 걸쳐 $10$진법으로 표현된 양의 정수 $n$이 주어진다.\n",
        "output_text": "각 테스트 케이스에 대해, $m$의 개수를 출력하여라.\n만약 그러한 $m$이 무수히 많다면, Hello, BOJ 2023!을 출력한다.\n",
        "memory_median": 2156.0,
        "time_median": 36.0,
        "length_median": 1441.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "683": {
        "problem_text": "숌은 N개의 다른 숫자로 구성되어 있는 집합 X를 만들었다. 그리고, 길이가 2N인 숌 사이 수열 (S)을 만들려고 한다.\n숌 사이 수열이란 다음과 같다.\n\nX에 들어있는 모든 수는 숌 사이 수열 S에 정확히 두 번 등장해야 한다.\nX에 등장하는 수가 i라면, S에서 두 번 등장하는 i사이에는 수가 i개 등장해야 한다.\n\n예를 들어, 숌이 만든 집합 X가 {1,2,3}이고, 숌이 만든 숌 사이 수열이 {2 3 1 2 1 3}이라면, 일단 X에 속하는 모든 수가 S에 두 번 등장하므로 1번 조건을 만족한다. 그리고, 2와 2사이엔 수가 두 개, 1과 1사이엔 1개, 3과 3사이엔 3개가 등장하므로 조건을 만족시킨다.\n집합 X가 주어졌을 때, 숌 사이 수열 S를 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 X의 크기 N이 주어진다. 둘째 줄에 X에 들어가는 수가 빈칸을 사이에 두고 주어진다. X의 크기는 8보다 작거나 같은 자연수이다. X의 원소는 0보다 크거나 같고 16보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 숌 사이 수열을 출력한다. 만약 여러 개일 경우 사전 순으로 가장 빠른 것을 출력한다. 만약 없을 경우에는 -1을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 1057.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "684": {
        "problem_text": "Bessie is on a diet where she can eat no more than C (10 <= C <= 35,000) calories per day. Farmer John is teasing her by putting out B (1 <= B <= 21) buckets of feed, each with some (potentially non-unique) number of calories (range: 1..35,000). Bessie has no self-control: once she starts on a feed bucket, she consumes all of it.\nBessie is not so good at combinatorics. Determine the optimal combination of feed buckets that gives Bessie as many calories without exceeding the limit C.\nAs an example, consider a limit of 40 calories and 6 buckets with 7, 13, 17, 19, 29, and 31 calories. Bessie could eat 7 + 31 = 38 calories but could eat even more by consuming three buckets: 7 + 13 + 19 = 39 calories. She can find no better combination.\n",
        "input_text": "\nLine 1: Two space-separated integers: C and B\nLine 2: B space-separated integers that respectively name the number of calories in bucket 1, 2, etc.\n\n \n",
        "output_text": "\nLine 1: A single line with a single integer that is largest number of calories Bessie can consume and still stay on her diet.\n\n",
        "memory_median": 1988.0,
        "time_median": 0.0,
        "length_median": 438.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "685": {
        "problem_text": "하얔이는 마라탕에 여러 재료를 넣어 먹는 것을 좋아한다. 하지만 마라탕에 항상 많은 재료를 넣는다고 맛있는 것은 아니다. 마라탕은 각 재료마다 궁합이 존재해서 같이 넣으면 맛있는 재료도 있고 그렇지 않은 경우도 있다. 여기서 하얔이는 고민에 빠졌다.\n\n대체 어떻게 해야 $K$개의 재료를 넣었을 때 마라탕의 맛을 최대로 할 수 있는거지?\n\n$C_{i, j}$를 재료 $i$와 재료 $j$를 같이 넣었을 때의 궁합이라 하자. 마라탕의 맛은 마라탕에 들어간 모든 재료 쌍의 궁합의 합이다. 고른 재료의 그룹을 $G$라고 했을 때 마라탕의 맛을 수식으로 표현하면 다음과 같다.\n$$\\sum_{i, j\\in G,\\ i < j}C_{i,j}$$\n가여운 하얔이를 위해 재료를 $K$개만 사용했을 때의 최대의 마라탕의 맛을 구해보자.\n",
        "input_text": "첫째 줄에 마라탕 재료의 수 $N (1 \\leq N \\leq 10)$, 고를 재료의 수 $K (1 \\leq K \\leq N)$가 공백으로 구분되어 주어진다.\n이후, $N$개의 줄에 걸쳐 $i+1$번 줄에 재료 $i$와 다른 재료들의 궁합을 나타내는 수열 ${C_{i, 1}, C_{i, 2}, ..., C_{i,N}}$이 공백으로 구분되어 정수로 주어진다. $(-1\\,000 \\leq C_{i,j} \\leq 1\\,000)$ 단, $(C_{i, i} = 0; C_{i, j} = C_{j, i})$\n",
        "output_text": "첫째 줄에 $K$개의 재료만 사용한 마라탕의 맛의 최댓값을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 812.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "686": {
        "problem_text": "원형으로 큰 길(순환로)이 뻗어 있고, 길 옆으로 V개의 마을이 자리잡고 있다. 큰 길의 둘레 길이는 정수 L이다. 이 문제에서 큰 길은 0 이상 L-1 이하의 정수가 늘어져 있는 원이고, 각 마을의 위치는 길 상의 정수 좌표로 표현된다. 한 위치에 여러 마을이 있을 수 있다. 좌표가 x, y인 두 마을의 거리는 min(|x - y|, L - |x - y|) 이다. \n우리는 이들 마을이 있는 곳에 우체국을 P개 지으려고 한다. 물론 모든 마을마다 다 짓는 건 아니다. 전체 마을 중 몇 곳을 골라, 그 위치에 우체국을 짓게 된다. 우리는 그 때 각 마을과 그 마을과 가장 가까운 우체국 사이의 거리의 합이 최소가 되게 하고 싶다.\n각 마을의 위치와 짓고자 하는 우체국 개수를 입력받아서, 각 마을과 그 마을과 가장 가까운 우체국 사이 거리의 합으로 있을 수 있는 최소값을 계산하고, 그런 결과를 낼 수 있도록 각 우체국을 지을 위치를 출력하는 프로그램을 작성하라.\n",
        "input_text": "첫 줄에는 세 정수 V, P, L이 주어진다. (1 ≤ P ≤ V ≤ 20, 1 ≤ L ≤ 1012) \n다음 줄에는 각 마을의 위치를 나타내는 V개의 정수 좌표가 나온다. 좌표는 비내림차순으로 정렬되어 있다. 각 좌표의 범위는 0 이상 L-1 이하이다.\n",
        "output_text": "첫째 줄에는, 각 마을과 거기서 가장 가까운 우체국 사이 거리들의 합의 최소값을 나타내는 정수 S를 출력한다.\n다음 줄에는, 우체국을 지을 마을들을 골라, 그 마을의 위치를 나타내는 P개의 정수를 비내림차순으로 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 42.0,
        "length_median": 1659.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "687": {
        "problem_text": "윤헌이는 수강신청 시즌이 되어 시간표를 짜고 있다. 지난 학기 금요일에 수업을 들어 친구들에게 온갖 놀림을 받은 윤헌이는 이번 학기에는 꼭 금요일 공강을 지켜내기로 결심했다!!\n고려대학교에서 수강할 수 있는 $n$개의 수업의 요일과 시작 교시, 끝 교시가 주어진다. 요일 $w$는 월요일부터 금요일까지 각각 1부터 5까지의 정수로 주어지며, 수업의 시작 교시 $s$, 끝 교시 $e$가 $1$부터 $10$까지의 정수로 주어진다. 수업의 학점은 $e-s+1$이다.\n이번 학기에 $k$ 학점을 듣고 싶은 윤헌이는 금요일에 공강이 있는 시간표의 가짓수가 궁금하다.\n이때, 같은 요일, 같은 교시에 열리는 두 수업은 동시에 수강할 수 없다. 예를 들어, 화요일 $5$교시부터 $7$교시까지 열리는 수업과 화요일 $7$교시부터 $9$교시까지 열리는 수업은 동시에 수강할 수 없다.\n윤헌이를 위해 정확히 $k$ 학점을 들으면서 금요일에 수업이 하나도 없는 시간표의 가짓수를 구해 보자!\n",
        "input_text": "첫 줄에 수강 가능한 수업의 개수 $n$과 윤헌이가 듣고 싶은 학점 $k$가 공백으로 구분되어 주어진다.\n다음 $i$번째 줄에는 $i$번 수업의 요일, 시작 교시, 끝 교시 $w_i, s_i, e_i$가 공백으로 구분되어 주어진다.\n",
        "output_text": "정확히 $k$ 학점을 들으면서 금요일에 수업이 하나도 없는 시간표의 가짓수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 20.0,
        "length_median": 1158.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "688": {
        "problem_text": "1, 3, 7, 9로 끝나는 숫자 S가 주어진다. 이때, 세제곱했을 때, S로 끝나는 수가 반드시 존재한다.\n예를들어, S가 123이면, 947을 세제곱하면 849278123이 되고, 이 수는 123으로 끝난다.\nS가 주어졌을 때, 세제곱했을 때 S로 끝나는 숫자를 찾아 출력하는 프로그램을 작성하시오. 이때 x의 길이는 S의 길이보다 작거나 같아야 한다.\n",
        "input_text": "첫째 줄에 테스트 케이스의 개수 T가 주어진다. 둘째 줄 부터 T개 줄에는 테스트 케이스의 정보가 주어진다. 각 테스트 케이스는 숫자 하나로 이루어져 있고, 이 수는 문제에서 설명한 S이다. S는 1, 3, 7, 9로 끝나며, 최대 10자리이다.\n",
        "output_text": "각 테스트 케이스에 대해 한 줄에 하나씩 세제곱했을 때 S가 되는 수 x를 출력한다.\n",
        "memory_median": 2016.0,
        "time_median": 0.0,
        "length_median": 1055.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "689": {
        "problem_text": "다솜이의 보물 1호는 계산기이다. 어느 날 계산기를 떨어뜨리게 되었고, 계산기가 망가지게 되었다. 계산기는 이제 D자리까지 밖에 나타나지 않는다. 다솜이는 이 계산기를 이용해서 재미있는 일을 해보려고 한다.\n가장 처음에 계산기에 표시되어 있는 수는 1이다. 다솜이는 계산기에서 정확하게 P번 만큼의 곱셈을 하려고 한다. 한번의 곱셈에 다솜이는 화면에 나와있는 수에 2와 9를 포함해서 그 사이에 있는 자연수를 곱하려고 한다. 수를 곱한 결과는 반드시 D자리 이하여야 한다. 다솜이가 P번의 곱셈을 해서 구할 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 다솜이의 계산기가 표시할 수 있는 자리수 D와 다솜이가 하려고하는 연산의 수 P가 주어진다. D는 2보다 크거나 같고, 8보다 작거나 같은 자연수이고, P는 30보다 작거나 같은 음이아닌 정수이다.\n",
        "output_text": "첫째 줄에 다솜이가 만들 수 있는 가장 큰 수를 출력한다. 만약 P번의 연산을 수행했을 때 나오는 결과가 모두 D자리를 넘어간다면 -1을 출력한다.\n",
        "memory_median": 2208.0,
        "time_median": 8.0,
        "length_median": 643.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "690": {
        "problem_text": "초등학생인 재홍이는 이번 봄 학예회 때, 재홍이가 지휘를 맡고 반 친구들이 춤을 추기로 계획했다. 이 춤은 시작할 때 춤추는 친구들이 일렬로 쭉 서서 각자 막춤을 추다가, 가운데 있는 친구를 기준으로 왼쪽과 오른쪽에 있던 친구들이 두손을 마주잡고 춤을 춘다. 즉 5명의 친구가 일렬로 서있었다면, 첫 번째 친구와 다섯 번째 친구가 함께 춤을 추게 되며, 두 번째 친구와 네 번째 친구가 함께 춤을 추게 된다. 세 번째에 있던 친구는 같이 출 수 있는 친구가 없기 때문에 혼자 로봇 댄스를 춘다.\n재홍이네 반 친구들은 모두 자신과 친한 친구하고만 춤을 추고 싶어한다. 재홍이는 이번 학예회에 스케일 크게 해보고 싶기 때문에 최대한 많은 친구를 무대에 세우려고 한다. 친구 관계도가 주어졌을 때, 최대 몇 명을 무대로 올려보낼 수 있는지 구해서 재홍이에게 알려주자. 친구들은 출석번호로 나타내며, 1부터 시작해서 N까지 있다. 각 친구는 오로지 하나의 출석번호를 갖는다.\nA와 B가 친한 친구고, B와 C가 친한 친구라고해서 반드시 A와 C가 친한 친구는 아니다. 로봇 댄스를 추는 친구를 제외한 무대에 올라가는 친구들은 모두 각자 자신과 친한 친구하고만 춤을 춰야한다. 또한 재홍이 반 친구들은 모두 로봇 댄스를 출 수 있다.\n\n",
        "input_text": "첫째 줄에 총 반친구 수 N(2<=N<=20, 재홍이 제외)와 관계도 수 M(0<=M<=(N^2-N)/2, 최대 50 제한)이 주어진다. 둘째 줄부터 M+1줄까지 친한 친구 관계는 출석번호 u, v로 나타나며 u와 v는 같지 않고, u와 v가 친한 친구라면 v와 u도 친한 친구다.\n똑같은 입력은 두 번 이상 나오지 않는다. 가령 1 2 가 이미 나왔다면 1 2 또는 2 1는 입력으로 들어오지 않는다.\n",
        "output_text": "무대에 최대한 세울 수 있는 친구의 수를 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 798.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "691": {
        "problem_text": "(String permutation) Write a recursive method to print all the permutations of a string. The user need to enter the string which consists of a set of characters.\n",
        "input_text": "First line of the input contains T (1 ≤ T ≤ 200), the number of test cases. For each test case, there will a string of characters, L (1 ≤ L ≤ 5).\n",
        "output_text": "For each test case, output a line in the format “Case # x:” where x is the case number (starting with 1), follow by the set of string permutation.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 626.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "692": {
        "problem_text": "바다에서 수학을 좋아하기로 유명한 오징어의 취미는 스도쿠이다. 스도쿠는 9*9칸으로 이루어져 있으며, 3*3칸에 1~9까지가 1번씩, 각각의 가로줄에도 1번씩, 세로줄에도 1번씩 들어가게 만드는 게임이다.\n오징어는 하루를 스도쿠와 함께 시작한다. 스도쿠를 푸는 오징어가 멋있어 보였던 새우는 오징어에게 문제지를 하나만 달라고 요청하였고, 오징어는 문제지를 복사해 주었다.\n새우는 오징어보다 스도쿠를 먼저 풀어서 자랑하기 위해 프로그래밍으로 스도쿠를 풀어보려고 한다.\n\n위의 모습 처럼 생긴 스도쿠가 있다면, 숫자는 숫자로, 빈 칸은 0으로 주어진다.\n스도쿠를 입력받아 스도쿠를 푸는 프로그램을 작성하시오\n",
        "input_text": "입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 9개의 줄로 이루어진 스도쿠이다. 또, 각 줄은 0부터 9까지 숫자로 이루어져 있다. 각 테스트 케이스에는 항상 0이 5개가 주어진다.\n",
        "output_text": "규칙을 지키면서 스도쿠를 풀 수 없는 경우에는 \n\r\nCould not complete this grid.\n를 출력한다.\n스도쿠를 풀 수 있는 경우에는 입력 형식대로 스도쿠를 9개 줄에 걸쳐서 출력한다.\n각 테스트케이스 사이에는 빈 줄을 출력하며, 스도쿠를 풀 수 있는 경우에는 항상 정답이 유일한 것만 입력으로 주어진다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 2193.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "693": {
        "problem_text": "Farmer John recently bought another bookshelf for the cow library, but the shelf is getting filled up quite quickly, and now the only available space is at the top.\nFJ has N cows (1 <= N <= 20) each with some height of H_i (1 <= H_i <= 1,000,000 - these are very tall cows). The bookshelf has a height of B (1 <= B <= S, where S is the sum of the heights of all cows).\nTo reach the top of the bookshelf, one or more of the cows can stand on top of each other in a stack, so that their total height is the sum of each of their individual heights. This total height must be no less than the height of the bookshelf in order for the cows to reach the top.\nSince a taller stack of cows than necessary can be dangerous, your job is to find the set of cows that produces a stack of the smallest height possible such that the stack can reach the bookshelf. Your program should print the minimal 'excess' height between the optimal stack of cows and the bookshelf.\n",
        "input_text": "\nLine 1: Two space-separated integers: N and B\nLines 2..N+1: Line i+1 contains a single integer: H_i\n\n \n",
        "output_text": "\nLine 1: A single integer representing the (non-negative) difference between the total height of the optimal set of cows and the height of the shelf.\n\n \n",
        "memory_median": 2020.0,
        "time_median": 4.0,
        "length_median": 503.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "694": {
        "problem_text": "5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자는 사과가 1개 있는 격자, 장애물이 있는 격자, 빈칸으로 되어 있는 격자로 구분된다. 격자의 위치는 (r, c)로 표시한다. r은 행 번호, c는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다.\n현재 한 명의 학생이 (r, c) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한가지 방향으로 한 칸 이동할 수 있다. 학생이 사과가 있는 칸으로 이동하면 해당 칸에 있는 사과를 1개 먹는다. 장애물이 있는 칸으로는 이동할 수 없다. 학생이 지나간 칸은 학생이 해당 칸을 떠나는 즉시 장애물이 있는 칸으로 변경된다. 즉, 학생이 해당 칸에서 상, 하, 좌, 우 방향으로 한 칸 이동하는 즉시 해당 칸은 장애물이 있는 칸으로 변경된다.\n학생이 현재 위치 (r, c)에서 사과 3개를 먹기 위한 최소 이동 횟수를 출력하자. 현재 위치에서 사과 3개를 먹을 수 없는 경우 -1을 출력한다.\n",
        "input_text": "첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 정보가 순서대로 주어진다. i번째 줄의 j번째 수는 보드의 (i - 1)번째 행, (j - 1)번째 열의 정보를 나타낸다. 보드의 정보가 1이면 해당 칸은 사과가 1개 있는 격자임을 나타내고, 0이면 빈칸이 있는 격자를 나타내고, -1이면 장애물이 있는 격자임을 나타낸다.\n다음 줄에 학생의 현재 위치 r, c가 빈칸을 사이에 두고 순서대로 주어진다.\n",
        "output_text": "첫 번째 줄에 학생이 현재 위치에서 사과 3개를 먹기 위한 최소 이동 횟수를 출력한다. 사과 3개를 먹을 수 없는 경우 -1을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1103.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "695": {
        "problem_text": "외판원 순회 문제는 영어로 Traveling Salesman Problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 이 중 변종 문제 중 하나인 Bottleneck Traveling Salesman Problem (BTSP) 문제를 살펴보자.\n정점의 개수가 $N$개, 비용이 있는 간선이 $M$개인 방향 그래프가 주어진다. 어느 한 정점에서 출발해, 출발한 정점을 제외한 $N-1$개의 정점을 모두 한 번씩 방문하고 다시 처음 정점으로 돌아오는 순회를 찾으려고 한다. 이러한 순회는 여러 가지가 있을 수 있는데, 정점 간 이동 비용의 최댓값을 최소화하려고 한다.\n그래프가 주어졌을 때, 정점 간 이동 비용의 최댓값을 최소화하면서 모든 정점을 방문하는 순회를 찾아보자.\n",
        "input_text": "첫 번째 줄에는 정점의 개수 $N$과 간선의 개수 $M$이 주어진다. ($2 \\le N \\le 9$, $0 \\le M \\le N(N-1)$)\n두 번째 줄부터 $M$개의 줄에 걸쳐서 간선에 대한 정보가 세 정수 $u$, $v$, $c$로 주어진다. 이는 정점 $u$에서 $v$로 향하는 비용이 $c$인 간선이 있음을 의미한다. 두 정점 사이에 같은 방향의 간선이 2개 이상 존재하지 않는다. ($1 \\le u, v \\le N$, $u \\ne v$, $1 \\le c \\le 5 \\, 000 \\, 000$)\n",
        "output_text": "모든 정점을 방문하는 순회가 있다면 첫 번째 줄에 정점 간 이동 비용의 최댓값의 최솟값을 출력한다. 만약에 이러한 순회가 없는 경우 -1을 출력한다.\n모든 정점을 방문하는 순회가 있다면, 다음 줄에 정점 간 이동 비용의 최댓값을 최소화하도록 방문해야 하는 정점 번호를 순서대로 $N$개를 출력한다. 이러한 순회가 여러 가지가 있는 경우 아무것이나 출력해도 된다.\n",
        "memory_median": 2044.0,
        "time_median": 4.0,
        "length_median": 1487.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0
        ]
    },
    "696": {
        "problem_text": "주환이는 요즘 등산에 빠졌다. 주환이는 등산을 위해 지도를 가지고 있는데, 그 지도에는 각 지점의 높이와 갈 수 있는 다른 지점까지의 거리가 표시되어 있다.\n주환이는 아침에 집에서 출발하여 등산을 갔다가, 오후 수업을 듣기 위해 고려대학교로 돌아와야 한다.\n\n주환이는 지도의 임의의 지점을 골라, 그 지점을 목표로 정한다. 집 또는 고려대학교는 목표로 선택할 수 없다.\n주환이가 집에서 정한 목표에 도달할 때 까지는 항상 높이가 증가하는 방향으로만 이동해야 한다.\n주환이가 정한 목표에 도달한 후, 고려대학교로 갈 때에는 항상 높이가 감소하는 방향으로만 이동해야 한다.\n주환이는 거리 1을 움직일 때 마다 D 의 체력이 소모된다.\n주환이는 정한 목표에 도달하면 높이 1당 E 의 성취감을 얻는다. 즉 높이가 h인 목표에 도달하면 hE의 성취감을 얻는다.\n\n주환이는 이 등산의 가치를 (얻은 성취감) - (소모한 체력) 으로 계산하기로 하였다. 주환이를 위해 가치가 가장 높은 등산 경로를 선택해주자.\n",
        "input_text": "첫 번째 줄에 지도에 표시된 지점의 개수, 지점을 잇는 경로의 개수, 주환이의 거리 비례 체력 소모량, 높이 비례 성취감 획득량을 나타내는 정수 N, M, D, E가 공백을 사이에 두고 주어진다. (2 ≤ N ≤ 100,000, 1 ≤ M ≤ 200,000, 1 ≤ D ≤ 100, 1 ≤  E ≤ 100)\n두 번째 줄에 N개의 정수 h1, ...  ,hN이 공백으로 구분되어 주어진다. hi는 i 번째 지점의 높이를 의미한다. (1 ≤ hi ≤ 1,000,000, 1 ≤ i ≤ N)\n세 번째 줄부터 M개의 줄에 걸쳐 세 정수 a, b, n이 공백으로 구분되어 주어진다. 이는 a번 지점과 b번 지점을 잇는 거리 n의 양방향 경로가 있음을 의미한다. (1 ≤ a, b ≤ N, 1 ≤ n ≤ 100,000)\n어떤 지점에서 다른 지점으로 가는 경로가 여러 개 있을 수도 있으며 (등산로는 여러 개가 있을 수 있다), 한 지점에서 출발해 그 지점으로 돌아가는 경로가 있을 수도 있다 (쉼터에서 몇 바퀴 돌며 쉴 수도 있다).\n주환이의 집은 1번 지점에 위치하고, 고려대학교는 N번 지점에 위치하며 주환이의 집과 고려대학교의 높이는 1임이 보장된다.\n",
        "output_text": "첫 번째 줄에 주환이가 얻을 수 있는 가치의 최댓값을 출력한다. 만약 조건을 만족하는 등산 경로를 선택할 수 없다면, \"Impossible\"을 쌍따옴표를 제외하고 출력한다. 답이 음수일 수 있음에 유의하여라.\n",
        "memory_median": 17778.0,
        "time_median": 148.0,
        "length_median": 1801.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "697": {
        "problem_text": "당신은 세계적인 인간대포 서커스 공연자이다. 즉, 당신은 거대한 가짜 대포 안으로 기어올라가 먼 거리를 발사되며 사람들에게 기쁨을 주는 사람인 것이다. 오늘, 당신은 혼자가 아니다. 당신은 국제 인간대포 회의 겸 전시장에 와 있으며 이 곳에서는 수백명의 인간대포 전문가들이 서로의 경험을 공유하고 기술을 연마한다. 보통 당신의 서커스에서 당신은 한 대포만을 가지고 공연하는데 반해 이곳에서는 사용할 수 있는 수많은 대포가 있다.\n여러 대포를 사용하면 회의장을 좀 더 편리하게 돌아다닐 수 있다. 만약 당신이 a장소에서 b장소까지 이동하려 한다면 a 부터 b까지 직선으로 걸어갈 수도 있고, 주변의 대포에 탑승해서 어딘가 다른 곳으로 발사되어 이동할 수도 있다. 발사되고 나면 내린 위치에서 도착점을 향해서 걸어갈 수도 있고, 다시 한 번 또 다른 대포를 이용하여 목적지에 더 빠르게 도착할 수도 있다. 그림 E.1처럼 배치된 지도에서 당신은 a에서 b로 이동하기 위하여 그림 E.2와 같은 경로로 걷거나 대포를 이용하여 움직일 수 있다. 화살표는 당신이 대포에서 발사되어 떨어진 점을 의미하며 직선은 당신이 달린 경로를 나타낸다.\n\n그림 E.1\n\n그림 E.2\n당신은 5m/s의 속도로 달린다. 모든 대포는 당신을 당신이 원하는 임의의 방향으로 50m 날려줄 수 있다. 대포에 올라타고 발사되고 착륙하기까지는 정확히 2초가 걸린다. 대포는 장애물이 아니기 때문에 당신이 뛰는 도중에 대포가 있다면 점프해서 넘어가 마치 직선과 같이 움직일 수 있다. 당신의 현재 위치와 목적지의 위치, 그리고 대포들의 위치가 주어질 때 당신은 목적지에 가장 빨리가기 위한 경로를 알고 싶다.\n",
        "input_text": "입력은 한 개의 길찾기 문제를 표현한다. 첫 줄에는 두 개의 실수가 입력되며 각각은 당신이 현재 위치한 X, Y좌표이다. 두 번째 줄에는 목적지의 X, Y좌표가 실수로 입력된다. 이어지는 줄에는 대포의 숫자 정수 n이 주어진다. 남은 n줄에는 한 줄에 대포 하나의 위치 정보가 주어지며, 이는 실수로 주어지는 X, Y 좌표이다. 모든 좌표는 미터로 측정되었으며 n의 값은 0 이상 100 이하이다. 입력으로 주어지는 모든 X, Y좌표는 0 이상 500 이하의 실수이고, 소수점 아래로 최대 두 자리까지만 주어진다.\n",
        "output_text": "한 줄에 걸쳐 목적지에 다다르기 위해 가장 빠른 시간을 출력하라. 실제 답과 0.001초 미만의 차이는 정답으로 인정한다.\n",
        "memory_median": 2160.0,
        "time_median": 0.0,
        "length_median": 1732.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "698": {
        "problem_text": "상수는 2차원 배열 A[1..n][1..n] (n≥2, n은 자연수)을 가지고 있습니다. 이 배열의 각 원소는 1 이상 222 이하의 정수입니다.\n배열을 가지고 놀던 상수를 본 승현이는, 질투심이 불타올라 상수를 A[1][1]에 가둬 버렸습니다! 최소한의 양심이 있던 승현이는 A[n][n]에 출구를 만들어 놓고 이 사실을 상수에게 알려줬습니다.\n\n[그림 1] n=4라면 상수는 A[1,1]에 있고, 출구는 A[4][4]에 있습니다.\n상수는 가능한 한 빨리 출구인 A[n][n]에 도달하고자 합니다. 상수가 A[i][j]에 있다고 가정했을 때, 상수는 최단 경로로 이동하기 위해 아래와 같은 조건을 만족하며 이동합니다.\n\n1≤i,j<n이라면, 상수는 A[i][j+1] 또는 A[i+1][j]로만 건너갑니다.\ni=n,1≤j<n이라면, A[i][j+1]로만 건너갑니다.\n1≤i<n,j=n이라면 A[i+1][j]로만 건너갑니다.\ni=j=n인 경우 바로 출구로 갑니다.\n\n\n[그림 2] n=5라고 가정합시다. (ㄱ)는 1번 조건을 만족하고, (ㄴ)는 2번 조건을 만족하며, (ㄷ)는 3번 조건을 만족합니다.\n그러나 건너갈 때에도 제약이 따릅니다. 상수가 A[a][b]에서 A[c][d]로 건너가려면 A[a][b]>A[c][d]를 만족해야 합니다. 상수는 왜인지 이런 조건을 만족하면서 이동할 수 없을 것 같았습니다. 다행히도, 승현이가 상수를 배열에 가둬버리기 전에, 상수는 배열의 각 원소에 버튼을 만들어 놓아서, 이 버튼을 누르면 해당 원소의 값이 1 증가하도록 했습니다. (물론 상수는 자신이 위치해 있는 원소의 버튼만 누를 수 있습니다.) 이 버튼 덕분에, 상수는 항상 배열을 탈출할 수 있습니다!\n\n[그림 3] n=2라고 가정합시다. A[1][1]=5>A[1][2]=2이므로, 상수는 A[1][1]에서 A[1][2]로 건너갈 수 있습니다. 상수가 A[1][1]에서 A[2][1]로 건너가려면, A[1][1]에 있는 버튼을 두 번 눌러 A[1][1]의 값을 7로 만들면 됩니다.\n하지만 버튼을 한 번 누르는 데에는 1원의 비용이 듭니다. 상수는 돈을 가능한 한 적게 들이면서 배열을 탈출하고자 합니다. 상수를 도와주세요.\n",
        "input_text": "첫 번째 줄에 n이 주어집니다. (n ≤ 2,222)\n다음에 n개 줄이 주어집니다. 이 중 i(1≤i≤n)번째 줄에는 n개의 수 A[i][1],A[i][2],⋯,A[i][n−1],A[i][n]이 공백을 사이로 두고 차례대로 주어집니다.\n",
        "output_text": "첫 번째 줄에 상수가 배열을 탈출하기 위해 들여야 할 최소 비용(원 단위)을 출력합니다.\n \n",
        "memory_median": 40884.0,
        "time_median": 628.0,
        "length_median": 1083.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "699": {
        "problem_text": "홍수의 발생으로 인해 도시의 도로들이 유실되어 많은 ICP(International Computational Plan) 시민들이 불편을 겪고 있다. 도시는 아래와 같은 격자 형태로 표현이 된다고 가정하자. 검정색 단위 격자가 ‘단위도로’를 의미하며 흰색 단위 격자는 도로가 없었거나 유실된 상태를 의미한다. X로 표시된 단위 격자는 도로를 건설할 수 없는 곳을 의미한다.\n\n도시의 차들은 단위 도로 상에서 가로나 세로 방향으로만 움직인다고 가정했을 때 도시의 기능을 회복시키기 위해 맨 왼쪽 위 단위 격자에서 맨 오른쪽 아래 단위 격자로 도시의 차들이 가는 경로를 만들기 위해 필요한 최소한의 도로 건설 비용을 계산하고자 한다. 단위 도로 하나를 건설하기 위해 1 또는 2 의 비용이 소요된다고 가정하자. 위 그림에서는 흰색 단위 격자에 단위 도로 하나를 건설하기 위해서는 1 의 비용이 든다고 가정한다.\n\n위와 같이 회색으로 표시된 단위 도로들을 4 의 비용으로 건설하면 목적을 달성할 수 있다.\n도시가 위와 같이 격자 형태로 주어졌을 때 맨 왼쪽 위 단위 격자에서 맨 오른쪽 아래 단위 격자로 가는 경로를 만들기 위해 필요한 최소 도로 건설 비용을 구하는 프로그램을 작성하시오.\n",
        "input_text": "입력은 표준입력을 사용한다. 첫 번째 줄에 도시를 표현하는 격자의 행과 열의 크기를 각각 나타내는 두 개의 양의 정수 m, n (1 ≤ m, n ≤ 1,000, 1 < m×n)이 주어진다. 다음 m개의 각 줄에 격자의 각 열의 정보를 나타내는 n개의 숫자가 주어진다. 각 열의 정보는 정수 0, 1, 2, -1 로 나타내며 0 은 단위도로가 이미 존재하는 것을, 즉, 도로에 유실이 없는 상태, 1 은 단위 도로가 없고 1 의 비용으로 도로를 건설할 수 있는 단위 격자, 2 는 단위 도로가 없고 2 의 비용으로 도로를 건설할 수 있는 단위 격자를 의미한다. -1 은 X로 표시된 단위 격자로 그 위치에 단위 도로를 건설할 수 없는 상태를 의미한다.\n",
        "output_text": "출력은 표준출력을 사용한다. 도시의 맨 왼쪽 위 단위 격자에서 맨 오른쪽 아래 단위 격자로 가는 경로를 만들기 위해 필요한 최소한의 도로 건설 비용을 한 줄에 출력한다. 해당 경로를 건설할 수 없을 때는 -1 을 출력한다.\n",
        "memory_median": 9996.0,
        "time_median": 192.0,
        "length_median": 1440.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "700": {
        "problem_text": "작은 세상 네트워크(Small World Network)란 Milgram 교수가 1967년에 처음으로 밝혀낸 이론이다.\n간단히 설명하자면 전체 네트워크가 거대하더라도 전체가 서로 가깝게 연결될 수 있다는 이론이다.\n해당 이론에서 Milgram 교수는 지구에 있는 모든 사람들이 최대 6단계로 연결될 수 있다고 주장하였다.\n예를 들어 이 문제를 만든 김 모 씨(23)와 이지은님(27)이 서로 생판 모르는 관계라도 최대 6단계만 거치면 서로 연결이 되어있다는 것이다.\n\n위의 그림에서 정점은 사람, 간선은 친구 관계라 할 때 왼쪽 그래프의 모든 정점들은 서로 최소 6단계 이하로 연결되어 있으므로 작은 세상 네트워크를 만족한다. 그러나 오른쪽 그래프의 초록색 정점끼리는 최소 7단계를 거쳐서 연결되어 있으므로 작은 세상 네트워크를 만족하지 않는다. \n이 이론에 대해 의구심이 생긴 김 모 씨는 정말 최대 6단계만 거치면 지구상의 모든 사람들이 서로 연결이 될 수 있는지 확인하고 싶었다.\n김 모 씨를 위해 지구상의 모든 사람들의 친구 관계가 주어졌을 때 작은 세상 네트워크가 실제로 만족하는지 확인하는 프로그램을 만들어보자.\n",
        "input_text": "첫 번째 줄에 지구에 있는 사람의 수 N과 친구 관계의 개수 K가 주어진다. 모든 사람은 1부터 N까지 번호가 매겨져 있다. (1 ≤ N ≤ 100, 0 ≤ K ≤ N×(N-1)/2)\n두 번째 줄부터 K+1번째 줄까지 친구 관계를 나타내는 A B가 한 줄에 하나씩 주어진다. (1 ≤ A, B ≤ N)\nA와 B가 친구면 B와 A도 친구다. 자기 자신과 친구인 경우는 없다. A와 B의 친구 관계는 중복되어 입력되지 않는다.\n",
        "output_text": "해당 네트워크가 작은 세상 네트워크를 만족하면 \"Small World!\"를, 만족하지 않는다면 \"Big World!\"를 출력한다.\n",
        "memory_median": 2060.0,
        "time_median": 0.0,
        "length_median": 957.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "701": {
        "problem_text": "$N$개의 땅 중에서 한 곳에 자취를 하려고 집을 알아보고 있다. 세 명의 친구 $A$, $B$, $C$가 있는데 이 친구들이 살고 있는 집으로부터 가장 먼 곳에 집을 구하려고 한다.\n이때, 가장 먼 곳은 선택할 집에서 거리가 가장 가까운 친구의 집까지의 거리를 기준으로 거리가 가장 먼 곳을 의미한다.\n예를 들어, $X$ 위치에 있는 집에서 친구 $A$, $B$, $C$의 집까지의 거리가 각각 3, 5, 4이라 가정하고 $Y$ 위치에 있는 집에서 친구 $A$, $B$, $C$의 집까지의 거리가 각각 5, 7, 2라고 하자.\n이때, 친구들의 집으로부터 땅 $X$와 땅 $Y$ 중 더 먼 곳은 땅 $X$이다. 왜냐하면 $X$에서 가장 가까운 친구의 집까지의 거리는 3이고, $Y$에서는 $2$이기 때문이다.\n친구들이 살고 있는 집으로부터 가장 먼 곳을 구해보자.\n",
        "input_text": "첫번째 줄에 자취할 땅 후보의 개수 $N$이 주어진다.\n2번째 줄에는 친구 $A$, $B$, $C$가 사는 위치가 공백으로 구분되어 주어진다. 이때 친구들은 $N$개의 땅 중 하나에 사는 것이 보장된다. (같은 위치에서 살 수 있다.)\n3번째 줄에는 땅과 땅 사이를 잇는 도로의 개수 $M$이 주어진다.\n그 다음줄부터 $M + 3$번째 줄까지 땅 $D$, 땅 $E$, 땅 $D$와 땅 $E$와 사이를 연결하는 도로의 길이 $L$이 공백으로 구분되어 주어진다. 이 도로는 양뱡항 통행이 가능하다.\n",
        "output_text": "친구들이 살고 있는 집으로부터 가장 먼 곳의 땅 번호를 출력한다. 만약 가장 먼 곳이 여러 곳이라면 번호가 가장 작은 땅의 번호를 출력한다.\n",
        "memory_median": 21596.0,
        "time_median": 416.0,
        "length_median": 1584.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "702": {
        "problem_text": "한신이는 젊고, 똑똑하고 매우 유명한 정치인이다. 그럼에도 그는 여전히 자신의 성공을 위해서도 인간관계는 중요한것이라고 믿고있다. 다음달에 열릴 국회의원선거에서 한신이는 자신의 당이 반드시 이기길 희망한다. 그러기 위해서 최고의원의 지지가 필요하다.\n\n이 최고의원의 지지를 받기위해 한신이는 전략을 세웠다. 그는 그 최고의원을 직접적으로 만날수 없다면 그를 알고있는 인맥을 이용하여 만날것이다. 이것을 위해서 우선 정치인들의 친밀도를 조사하였는데 친밀도를 다음 4단계로 나누어서 기록해놓았다.\n최측근 [1] / 측근 [2] / 비즈니스관계 [3] / 지인 [4]\n[두 사람의 관계는 이 4가지 경우중 반드시 해당되며, 적(enemy)는 존재하지 않는다.]\n한신이는 지인보다는 최측근 친구에게 소개받기 원한다. 그래서 최고의원을 만나기까지의 인맥간 친밀도의 합을 최소화하고 싶어한다.\nN명의 정치인 명단으로부터 그들의 인맥 친밀도가 주어진다. 정치인 리스트를 보고 한신이가 최고의원을 만나기까지의 친밀도의 합 중에서 가장 작은 값을 구하면 된다.\n",
        "input_text": "맨위 첫 번째 줄에 T(1 <T< 100)는 테스트케이스 수를 의미한다. 이것을 따라 다음줄에 각 테스트 케이스가 주어지는데, 첫 번째 줄에는 N과 M이 주어진다. N(N ≤ 20)은 관계의 개수를 의미하며, M(5 ≤M≤ 20)은 정치인의 수를 나타낸다. 이 다음 N줄에는 정치인 x, 그의 친구 y (0 ≤x,y< M), 두사람간의 친밀도 z(1 ≤z≤ 4)를 입력받는다. 정치인 0번은 한신이를 나타내고 M-1은 최고의원을 의미한다.\n",
        "output_text": "각 테스트 케이스는 \"Case #x: \"의 형식으로 출력되며 x는 케이스 번호(1부터 시작)을 의미한다. 콜론뒤에 한신이가 최고의원을 만날수 있다면 0번 정치인(한신이)를 시작으로 M-1번 정치인(최고의원)까지 만난 순서대로 출력하면 되고, 최고의원을 만날수 없는 경우엔 -1을 출력하면 된다.\n",
        "memory_median": 2024.0,
        "time_median": 16.0,
        "length_median": 1555.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "703": {
        "problem_text": "당신은 집으로 가는 도중 복잡한 교차로를 만났다! 이 교차로에는 사람이 지나갈 수 있는 $N$ 개의 지역이 있고 그 지역 사이를 잇는 몇 개의 횡단보도가 있다. 모든 지역은 횡단보도를 통해 직, 간접적으로 연결되어 있다. 편의상 $N$ 개의 지역을 $1$부터 $N$까지로 번호를 붙이자.\n\n당신은 이미 멀리서 교차로의 신호를 분석했기 때문에 횡단보도에 파란불이 들어오는 순서를 알고 있다. 횡단보도의 주기는 총 $M$ 분이며 $1$분마다 신호가 바뀐다. 각 주기의 $1+i (0 \\le i < M)$ 번째 신호는 $i, M+i, 2M+i, 3M+i, \\cdots$ 분에 시작해서 $1$분 동안 $A_i$번 지역과 $B_i$번 지역을 잇는 횡단보도에 파란불이 들어오고, 다른 모든 횡단보도에는 빨간불이 들어온다. 한 주기 동안 같은 횡단보도에 파란불이 여러 번 들어올 수 있다.\n횡단보도에 파란불이 들어오면 당신은 해당 횡단보도를 이용하여 반대편 지역으로 이동할 수 있으며 이동하는 데 $1$분이 걸린다. 횡단보도를 건너는 도중에 신호가 빨간불이 되면 안되기 때문에 신호가 $s \\sim e$ 시간에 들어온다면 반드시 $s \\sim e-1$ 시간에 횡단보도를 건너기 시작해야 한다.\n횡단보도와 신호의 정보가 주어질 때, 시간 $0$분 에서 시작해서 $1$번 지역에서 $N$번 지역까지 가는 최소 시간을 구하는 프로그램을 작성하여라.\n",
        "input_text": "첫 번째 줄에는 지역의 수 $N$, 횡단보도의 주기 $M$이 공백으로 구분되어 주어진다.\n두 번째 줄부터 $M$ 개의 줄 중 $1+i$ 번째 줄에는 $i, M+i, 2M+i, 3M+i, \\cdots$ 분에 시작해서 $1$분동안 파란불이 들어오는 횡단보도의 두 끝점 $A_i$, $B_i$가 공백으로 주어진다.\n",
        "output_text": "첫 번째 줄에 $1$ 번 지역에서 $N$ 번 지역까지 가는데 필요한 최소 시간을 분단위로 출력한다.\n",
        "memory_median": 50898.0,
        "time_median": 408.0,
        "length_median": 1183.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "704": {
        "problem_text": "친한 친구인 승현이와 지학이는 여름방학 때 여행을 가기로 계획했습니다. 해외여행은 금전적으로 부담이 많기 때문에 둘은 한국의 여러 도시를 여행하기로 했습니다. 한국에는 N개의 도시가 있으며, 승현이는 이 중 여행할 M개의 도시를 결정했습니다. 여행 경로에서 같은 도시를 여러 번 방문할 수 있으며, 여행을 시작하는 도시와 끝내는 도시는 같습니다.\n한국에는 두 도시 사이를 오갈 수 있는 K개의 교통수단이 있습니다. 교통수단의 종류는 기차, 지하철, 버스, 택시, 비행기 등으로 다양합니다. 특히 기차 코스는 매우 세부적으로 나뉘어 있어서 무궁화호(Mugunghwa), ITX-새마을(ITX-Saemaeul), ITX-청춘(ITX-Cheongchun), KTX, S-Train, V-Train 등이 있습니다. 모든 교통수단은 한 번 이용하는 데 필요한 비용이 정해져 있습니다. 승현이와 지학이는 계획한 M개의 도시를 최소비용으로 차례대로 움직일 것입니다.\n한편, 코레일에서는 ‘내일로’라는 특별한 기차표를 판매하고 있습니다. 방학 동안, 젊은 청년들은 R원을 주고 내일로 티켓을 살 수 있습니다. 한 번 내일로 티켓을 사면, 며칠 동안 무궁화호, ITX-새마을, ITX-청춘은 무료로 이용할 수 있으며, S-Train과 V-Train은 50% 할인된 가격으로 이용할 수 있습니다. KTX나 지하철, 또는 다른 교통수단에 대해서는 할인이 적용되지 않습니다.\n지학이는 자신이 아무것도 하지 않는 것에 죄책감을 느끼기 때문에, 자신들의 여행에서 내일로 티켓이 필요한지 생각해보기로 했습니다. 지학이를 도와 내일로 티켓을 사는 것과 사지 않는 것 중 어떤 선택이 더 좋은 지 구하는 프로그램을 작성하세요.\n",
        "input_text": "첫 번째 줄에는 한국에 있는 도시의 수 N(1 ≤ N ≤ 100)과 1인당 내일로 티켓의 가격 R(1 ≤ R ≤ 1,000,000)이 주어집니다. 두 번째 줄에는 N개의 도시의 이름이 주어집니다. 도시의 이름은 알파벳 대소문자로 구성된 길이 20 이하의 문자열입니다. 세 번째 줄에는 승현이와 지학이가 여행할 도시의 수 M(1 ≤ M ≤ 200)이 주어집니다. 네 번째 줄에는 승현이와 지학이가 여행할 M개 도시의 이름이 주어집니다. 이 도시들은 앞서 언급된 N개의 도시 중 하나입니다. 다섯 번째 줄에는 교통수단의 수 K(1 ≤ K ≤ 10,000)가 주어집니다. 마지막 K개의 줄에는 교통수단에 대한 정보가 주어집니다. 줄마다 교통수단의 종류 Typei, 양 끝 도시 Si, Ei, 1인당 비용 Costi (1 ≤ Costi ≤ 100,000)가 주어집니다. Typei는 ‘Subway’, ‘Bus’, ‘Taxi’, ‘Airplane’, ‘KTX’, ‘S-Train’, ‘V-Train’, ‘ITX-Saemaeul’, ‘ITX-Cheongchun’, ‘Mugunghwa’ 중 하나이며, 모든 도시는 주어진 K개의 교통수단을 이용하여 갈 수 있음이 보장되어 있습니다.\n한국에는 이름이 같은 도시가 있을 수 있다. 따라서, N개의 도시의 이름에는 같은 도시의 이름이 두 번 이상 주어질 수도 있다. 이 경우 이러한 도시를 모두 같은 도시라고 생각해야 한다.\n",
        "output_text": "한줄에 내일로 티켓을 사는 것이 좋으면 ‘Yes’를 출력하고 그렇지 않으면 ‘No’를 출력합니다. 내일로 티켓을 사더라도 비용이 정확히 같다면 ‘No’를 출력합니다.\n",
        "memory_median": 2300.0,
        "time_median": 12.0,
        "length_median": 2104.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "705": {
        "problem_text": "만약 KIST 기사단 2기로 여러분이 선발된다면, 서울 월곡에 있는 KIST와 양재에 있는 씨알푸드에서 팀이 함께 만나 의논하고 함께 작업할 시간을 가지게 된다. 누구나 그 회의 장소에 빨리 가고 싶은 마음은 똑같을 것이다.\n각 장소를 노드로 생각하고, 연결된 도로를 간선으로 생각하면 그래프를 구성할 수 있다. KIST 기사단 N명의 집이 있는 노드 번호와 KIST, 씨알푸드의 노드 번호가 주어지고, 한 사람의 거리 di = (집-KIST의 최단 거리) + (집-씨알푸드의 최단 거리)로 정의된다. 단, 도달할 수 없는 경우의 최단 거리는 -1로 정의한다. 예를 들어, 어떤 사람이 KIST로는 갈 수 없고 씨알푸드까지의 최단 거리가 10인 경우 이 사람의 거리 d는 9이고, 다른 사람이 KIST, 씨알푸드로 모두 갈 수 없을 경우 이 사람의 거리 d는 -2이다. 이때 Σdi의 값을 출력하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 KIST 기사단 팀원의 수 N, 장소의 수 V, 도로의 수 E가 주어진다. (N ≤ 100, V ≤ 1000, E ≤ 10000)\n둘째 줄에 KIST의 위치 A와 씨알푸드의 위치 B가 주어진다. (1 ≤ A, B ≤ V)\n셋째 줄에 팀원 N명의 집의 위치 Hi가 공백을 사이에 두고 주어진다. (1 ≤ i ≤ N, 1 ≤ Hi ≤ V)\n넷째 줄부터 E+3번째 줄까지는 도로의 양 끝 장소 a, b와 길이 l이 주어진다. (1 ≤ a, b ≤ V, 1 ≤ l ≤ 100)\n",
        "output_text": "모든 사람의 최단 거리의 합을 출력한다. 단, KIST나 씨알푸드로 갈 수 없는 경우에는 -1로 처리한다.\n",
        "memory_median": 2324.0,
        "time_median": 16.0,
        "length_median": 1396.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "706": {
        "problem_text": "“앙두레 강”이 개미와 코끼리 결혼식에서 기차를 아름답게 만드는 것을 실패했기 때문에 식장이 아수라장이 되고 결혼이 물거품이 되어버렸다. 급기야는 왕국 간에 분쟁으로 이어져 개미왕국은 코끼리왕국을 공격하기로 결정하였다. 동물나라 지도에서 개미왕국은 1번 정점에 위치해 있고 코끼리왕국은 N번 정점에 위치해 있다. 따라서 개미왕국이 1번 정점에서 N번 정점으로 공격을 하러 가는 상황이다. (개미왕국은 최단거리로 이동을 하게 되고, 코끼리왕국은 움직이지 않는다)\n“개미”와 “코끼리”의 앞 글자를 따서 이 전쟁은 “개코전쟁”으로 역사에 기억된다.\n“앙두레 강”은 자신 때문에 발생한 이 전쟁을 어떻게든 막으려고 한다. 협상을 할 시간을 벌기 위해 개미왕국이 코끼리왕국에 도착하는 시간을 최대한 늦추려고 한다. 그래서 “앙두레 강”은 사자왕국의 도움을 빌어 도로 중 딱 하나를 파괴하려고 하는데 어느 도로를 파괴해야 개미왕국이 최단거리로 가더라도 그 거리를 최대로 할 수 있을까?\n“앙두레 강”를 도와 1번 정점에서 N번 정점으로의 최단거리가 최대가 되도록 도로 하나를 파괴하도록 하자. (어떤 하나의 도로를 파괴하더라도 1번 정점에서 N번 정점으로 도달 가능하다)\n",
        "input_text": "첫 줄에 N과 M이 입력된다. N은 정점의 개수이고 M은 도로의 수이다. (1 ≤ N ≤ 1000, 1 ≤ M ≤ N×(N-1)/2)\n다음 줄부터 M개의 줄에 도로의 정보가 입력된다.\ni+1번째 줄에는 i번째 도로의 정보 xi yi zi가 입력되고 이 도로는 정점 xi와 정점 yi를 잇는 도로이며 지나는데 zi만큼의 시간이 걸린다는 것을 의미한다. 두 정점사이에는 두 개 이상의 길이 존재하지 않고 모든 도로는 양방향이며 한 도로를 파괴하는 것은 양방향의 길 모두를 파괴하는 것이다. (1 ≤ xi, yi ≤ N, 1 ≤ zi ≤ 1000)\n",
        "output_text": "적당한 도로하나를 파괴했을 때 1번 정점에서 N번 정점으로의 최단거리의 최댓값을 출력한다.\n",
        "memory_median": 9256.0,
        "time_median": 112.0,
        "length_median": 1810.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "707": {
        "problem_text": "선영이는 N × M 직사각형 크기의 전자 회로를 디자인 하고 있다. 회로에는 N × M개의 정사각형 타일이 있고, 모두 직사각형의 변과 평행하다. 모든 타일은 두 개의 마주보는 꼭짓점이 전선으로 연결되어 있다. (그림 참조)\n전원은 왼쪽 위 모서리에 연결되어 있고, 전구는 오른쪽 아래 모서리에 연결되어 있다. 전구는  전원에서 전구로 가는 경로가 있을 때만 불이 켜진다. 전구에 불을 켜기 위해서, 선영이는 몇개의 타일을 90도 회전 시킬 수 있다.\n\n위의 그림에서 전구는 꺼져있다. 만약 오른쪽에서 2번째 열 중 아무 칸이나 90도 회전시킨다면, 전원과 전구는 연결되어 전구가 켜지게 된다. 전구에 불을 켜기 위해 돌려야 하는 칸의 개수의 최솟값을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에는 전자 회로의 상태가 주어진다. 상태는 / 또는 \\이다. (1 ≤ N, M ≤ 500)\n",
        "output_text": "첫째 줄에 문제의 정답을 출력한다. 전구에 불을 켜는 것이 가능하면, 몇 개의 칸을 돌려야 하는지를 출력하고, 불가능할때는 \"NO SOLUTION\"을 따옴표 없이 출력한다.\n",
        "memory_median": 8116.0,
        "time_median": 56.0,
        "length_median": 1753.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "708": {
        "problem_text": "세로 길이가 N, 가로 길이가 M, 높이가 H인 물탱크가 있다. N, M, H는 모두 양의 정수이다. <그림 1>은 세로 길이가 2, 가로 길이가 3, 높이가 5인 물탱크 모양을 보여준다. <그림 1>에서 보듯이 물탱크 내부는 가로와 세로로 벽이 설치되어 있는데, 내부 각 칸(즉 사각기둥 모양)의 세로와 가로 길이는 1이고 높이는 H가 되도록 벽이 설치되어 있다. 이 물탱크를 위에서 내려다보면 <그림 2>와 같이 각 칸이 정사각형인 격자 모양이 된다. 물탱크 각 칸의 벽에는 물 높이 조정을 위해 구멍이 뚫려 있을 수 있다. 각 칸에는 네 개의 벽이 있는데, 각 벽 내부에는 최대 한 개의 구멍이 뚫려 있을 수 있다. 단, 모서리엔 구멍이 없다.\n\n<그림 1>\n<그림 1>에서 구멍이 있는 높이는 바닥을 기준으로 표시되어 있다. 구멍의 위치를 위에서 보면 <그림 2>처럼 보이는데 이는 물탱크를 위에서 보았을때 어느 벽, 어떤 높이에 구멍이 뚫려 있는지를 알려주며, <그림 1>에선 표시 하기 어려운 물탱크의 구멍 위치도 표시한다. <그림 2>에서 보듯이 물탱크 내부 벽에도 구멍이 있을 수 있다.\n\r\n<그림 2>\n물탱크에 물을 채울 땐, 모든 구멍을 마개로 막아 물이 새지 못하도록 한 후, 격자의 각 칸 위에 설치된 급수 장치를 통해 물탱크 전체를 물로 채운다. 물이 꽉 찬 후에 구멍을 막고 있는 모든 마개를 제거하면 물이 구멍을 통해 인접한 방이나 외부로 흘러나가게 된다. 어느 정도 시간이 지나면 물이 더 이상 흘러 나가지 않게 되고, 그 때 물탱크 격자의 각 칸에 남아 있는 물의 높이는 서로 다를 수 있다.\n참고로, <그림 2>에서 보인 물탱크의 각 칸에 남아 있는 물의 높이를 나타내면 <그림 3>의 괄호 속의 수치와 같다.\n\r\n<그림 3>\n벽의 두께를 무시할 때, 물탱크에 남아 있는 물의 총량(부피)을 계산하는 프로그램을 작성하시오.\n",
        "input_text": "표준 입력으로 다음 정보가 주어진다. 첫 번째 줄에는 물탱크의 세로 길이, 가로 길이, 높이를 나타내는 세 양의 정수 N, M, H가 차례로 주어진다.\n다음 줄에는 첫 번째 가로 벽에 설치된 구멍 정보를 나타내는 M개의 정수가 주어진다. 각 정수는 왼쪽부터 시작하여 순서대로 각 칸의 구멍 높이를 의미한다. 구멍의 높이는 0 이상 H미만의 정수이다. 해당 벽에 구멍이 없는 경우는 –1로 표시한다. 이어지는 줄엔 두 번째 가로 벽에 설치된 구멍 정보가 주어지고, 이런 식으로 N+1 줄에 걸쳐 가로 벽에 설치된 모든 구멍에 대한 정보가 주어진다.\n이어지는 줄에는 첫 번째 가로 벽을 공유하는 칸들(<그림 2>에서 맨 윗줄의 칸들)의 세로 벽에 설치된 구멍 정보를 나타내는 M+1개의 정수가 주어진다. 각 정수는 첫 번째 세로 벽부터 시작하여 차례로 각 세로 벽의 구멍 높이를 나타낸다. 그 다음 줄에는 그 다음에 있는 칸들의 세로 벽에 설치된 구멍 정보가 주어진다. 이런 식으로 N줄에 걸쳐 세로 벽에 설치된 모든 구멍 정보가 주어진다.\n참고로, 입출력 예에서 보인 첫 번째 예제는 <그림 2>에서 보인 경우에 대응된다.\n",
        "output_text": "물이 더 이상 흘러 나가지 않는 시점에 물탱크에 남아 있는 물의 총량(부피)을 표준 출력으로 출력한다.\n",
        "memory_median": 40196.0,
        "time_median": 636.0,
        "length_median": 2299.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "709": {
        "problem_text": "소가 길을 건너는 이유는 그냥 길이 많아서이다. 존의 농장에는 길이 너무 많아서, 길을 건너지 않고서는 별로 돌아다닐 수가 없다.\n존의 농장에는 작은 정사각형 목초지가 N×N (3 ≤ N ≤ 100) 격자로 이루어져 있다. 농장의 바깥에는 높은 울타리가 있어서 소가 농장 밖으로 나갈 일은 없다. 이 농장에 사는 소 베시는 한 목초지에서 상하좌우로 인접한 다른 목초지로 이동할 수 있지만, 교통사고를 피하기 위해 차가 안 오는지 확인하고 길을 건너야 한다. 길을 건너는데는 T초 (0 ≤ T ≤ 1,000,000)가 걸린다.\n존이 베시에게 체스 대결을 신청했다. 베시는 북서쪽 끝에 있는 목초지에서 남동쪽 끝에 있는 존의 집으로 가야 한다. 길이 멀기 때문에 베시는 가는 도중에 배가 고파진다. 그래서 길을 세 번 건널 때마다 목초지에 있는 풀을 먹어야 한다. 존의 집에 도착할 때도 해당되지만, 출발할 때는 해당되지 않는다. 목초지마다 풀이 자란 정도가 달라서, 풀을 먹는데 걸리는 시간도 다르다.\n베시가 가능한 한 빨리 존의 집에 도착할 수 있도록 도와주자.\n",
        "input_text": "첫 줄에 N과 T가 주어진다. 다음 N줄에는 목초지마다 풀을 먹는데 걸리는 시간이 N×N의 형태로 주어진다. 각각의 수는 모두 100,000 이하이다.\n",
        "output_text": "베시가 존의 집까지 가는데 걸리는 최소 시간을 출력한다.\n",
        "memory_median": 2356.0,
        "time_median": 4.0,
        "length_median": 1458.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "710": {
        "problem_text": "동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러나 그는 곧 동물원 직원에게 쫓기는 신세가 되었다. 원숭이와 동물원 직원사이에 쫓고 쫓기는 추격전을 살펴보자.\n원숭이가 사는 나라는 여러 개의 도시와 도시들을 연결하는 길들로 구성되어 있다. 각 길들은 두 개의 도시를 양방향으로 연결한다. 또한, 각 길은 지나갈 때마다 일정한 시간이 걸린다. 원숭이는 시작도시에서 탈출하여 도착도시까지 최대한 빠른 시간에 가야한다.\n그런데 원숭이의 오랜 숙적 멍멍이가 이를 갈며 원숭이를 기다리고 있었다. 멍멍이는 원숭이가 도망가는 경로 중 시작점과 도착점을 포함한 도시 중 한 군데에서 원숭이를 괴롭히기로 계획했다. 각 도시마다 구조가 다르기 때문에 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 정해져있다.\n그래서 멍멍이는 원숭이가 도망가는 경로 상에 있는 모든 도시들 중에서 가장 오랜 시간동안 괴롭힐 수 있는 도시에서 괴롭히기로 계획했다. 원숭이는 멍멍이를 피할 수 없다. 피할 수 없다면 즐겨라! 시작도시와 도착도시가 주어졌을 때, 원숭이가 최대한 빨리 도망갈 수 있는 시간을 구하는 프로그램을 작성하시오.\n예를 들어, A, B, C, D 4개의 도시가 있고 원숭이는 A에서 도망쳐서 D로 가려고 한다고 하자. 이때, A-B와 B-D 간의 도로의 통행시간은 각각 50 이고 A-C 와 C-D 간의 도로의 통행시간은 각각 70 이면 A-B-D 의 경로가 더 이익이다. (각각 100 과 140 의 시간이 걸린다.)\n그러나, 네 도시에서 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 10, 80, 20, 10 이라면 A-C-D 를 통해 가는 것이 시간을 더 줄일 수 있는 방법이다. (A-B-D 의 경우 100+80 = 180 의 시간이 걸리고, A-C-D 의 경우 140+20 = 160 의 시간이 걸린다.)\n",
        "input_text": "첫 번째 줄에는 도시의 개수 N (2 ≦ N ≦ 500) 과 도로의 개수 M (0 ≦ M ≦ 10,000), 그리고 질문의 개수 Q (0 ≦ Q ≦ 40,000) 가 주어진다.\n그 다음 줄에, N개의 정수로 각 도시에서 멍멍이가 원숭이를 괴롭힐 수 있는 시간이 주어진다. 각 시간은 1이상 10,000이하의 정수이다. 그 후 M줄에 각각 3개의 정수로, 해당 도로가 잇는 두 도시의 번호 a, b (1 <= a, b <= N) 와 해당 도로의 통행시간 d 가 주어진다. 통행시간은 1이상 10,000이하의 정수이다.\n그 후 Q줄에 각각 2개의 정수로, 원숭이의 출발도시와 도착도시 S, T 가 주어진다.\n",
        "output_text": "첫째 줄에 원숭이가 S 번 도시로부터 T 번 도시까지 도망가는 데 드는 최소시간을 출력한다. 만약 두 도시 간에 경로가 없을 경우, -1 을 출력한다.\n",
        "memory_median": 3982.0,
        "time_median": 280.0,
        "length_median": 1465.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "711": {
        "problem_text": "늑대 현우는 피에 굶주린 사냥꾼들에게 벗어나려고 도망치고 있다. 사냥꾼은 매우 똑똑해서 나무 뒤에 숨어있다. 현우도 이 사실을 알고있다. 하지만, 어떤 나무 뒤에 사냥꾼들이 숨어있는지 알지 못한다. 현우는 사냥꾼에게 잡히지 않기 위해서 숲의 한 오두막으로 대피하려고 한다. 현우는 나무와 거리가 최대한 떨어지는 경로로 대피하려고 한다.\n숲은 N×M 크기의 그리드로 나타낼 수 있다. 각 칸이 빈 목초지라면 '.', 나무가 있다면 '+', 현재 현우의 위치는 'V', 오두막의 위치는 'J'로 나타나있다. 현우는 현재 있는 위치에서 동서남북으로 인접한 칸으로 이동할 수 있고, 나무가 있는 칸으로도 이동할 수 있다.\n만약 현우가 지금 R행 C열에 있고, 나무가 A행 B열에 있다면, 현우와 나무의 거리는 |R-A| + |C-B|이다.\n현우는 오두막으로 도망치는 가장 안전한 길로 이동하려고 한다. 가장 안전한 길이란 현우가 이동하는 모든 칸에서 나무와 거리의 최솟값이 가장 큰 경로이다. 또, 오두막이 있는 칸도 경로의 일부이기 때문에 나무와 거리를 계산해야 한다.\n숲의 지도가 주어졌을 때, 가장 안전한 길을 찾는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 N과 M (1 ≤ N, M ≤ 500)이 주어진다. 둘째 줄부터 N개 줄에는 숲의 지도가 주어진다. 지도에 'V'와 'J'는 딱 하나만 있고, 적어도 하나의 '+'가 있다.\n",
        "output_text": "첫째 줄에 가장 안전한 경로에서 나무와 현우와 거리의 최솟값을 출력한다.\n",
        "memory_median": 5368.0,
        "time_median": 32.0,
        "length_median": 2057.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "712": {
        "problem_text": "엄청난 벼락을 맞아 많은 전선들이 끊어져 현재 전력 공급이 중단된 상태이다. 가장 심각한 문제는 1번 발전소에서 N번 발전소로 가는 중간의 전선이 끊어진 것이기에 일단 이 두 발전소를 다시 연결하는게 현재 해결해야할 첫 번째 과제이다.\n발전소는 1번부터 N번까지 번호로 매겨져 2차원 격자 좌표 위에 있다. 그리고 몇몇 전선은 보존된 채 몇몇 발전소를 잇고 있다. 문제는 현재 전선과 발전소의 위치가 주어졌을 때 최소의 전선 길이를 추가로 사용하여 1번 발전소와 N번 발전소를 연결짓는 것이다. 물론 연결 짓는 중간에 다른 발전소를 거쳐갈 수 있다. 단, 안정성 문제로 어떠한 두 발전소 사이의 전선의 길이가 M을 초과할 수는 없다. 아래에 이에 대한 예를 그려놓았다.\n\r\n         연결 전                          연결 후\r\n\r\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\r\n                                          /\r\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\r\n                                        /\r\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\r\n   |                               |\r\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\r\n\r\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\r\n\n",
        "input_text": "첫 줄에는 발전소의 수 N(1 ≤ N ≤ 1,000)과 현재 남아있는 전선의 수 W(1≤ W ≤ 10,000)가 주어진다. 두 번째 줄에는 제한 길이 M(0.0 < M < 200,000.0)가 주어진다. 다음 N개의 줄에는 1번 발전소부터 N번 발전소까지 각각의 발전소의 X좌표와 Y좌표(-100,000 ≤ xi,yi  ≤ 100,000)가 차례대로 주어진다. 다음 W개의 줄에 대해 각 줄에는 두 개의 정수가 입력되어지는데 이는 현재 남아있는 전선이 잇고 있는 두 발전소를 의미한다.\n",
        "output_text": "첫 줄에 1번 발전소와 N번 발전소를 잇는데 필요한 추가 전선 길이의 최솟값을 1000배하여 출력한다. (단, 1000배하고 난 후 나머지 소수는 반올림이 아닌 버림을 한다)\n",
        "memory_median": 10186.0,
        "time_median": 28.0,
        "length_median": 1590.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "713": {
        "problem_text": "서기 2050년 엄청나게 강력한 폭풍이 인천을 강타했다. 강력한 폭풍의 영향으로 모든 사람은 대피소로 대피하였으며, 많은 도로가 유실되었다. 그나마 남아있는 도로도 모든 표지판과 가로등이 작동을 멈춰 제대로 된 길을 찾기란 불가능에 가까웠다.\n이런 심각한 상황에 민지는 대피소에 구명 물자를 보내려고 한다. 서기 2050년 인천의 모든 길은 교차로와 도로만으로 이루어져 있다. 한 교차로와 다른 교차로는 일방통행 도로로 연결되어 있으며, 한 교차로와 여러 교차로가 연결될 수 있다. 그리고 도로에 한번 진입하면 교차로에 도착할 때까지 도로를 벗어날 수 없다.\n민지는 구호물자로 가득 찬 트럭을 출발시키려고 했지만, 운행을 거부한 트럭운전사들 때문에 난관에 봉착했다. 강력한 폭풍의 영향으로 내비게이션은 정확하지 않고, 도로를 구분할 수 있는 표지판이 망가졌기 때문에 트럭운전사들은 교차로에서 어떤 도로를 선택해야 할지 모른다. 이러한 상황에서 특정 도로를 임의로 선택하면 이미 지나쳤던 교차로를 또다시 방문하는 일이 발생할 수 있고, 만약 그런 상황이 발생하면 트럭의 기름이 부족해 대피소에 도착하지 못할 수 있다.\n대피소에 반드시 구호물자를 보내야 한다고 생각하는 민지는 현재 위치인 1번 교차로에서 대피소가 있는 N번 교차로까지 어떤 도로를 선택하며 가더라도 지나친 교차로를 다시 방문하지 않는다는 것을 증명해 트럭 운전사들을 설득하려 한다.\n\n위 그림은 대피소가 3번에 있다고 했을 때 가능한 두 가지 모양이다. 왼쪽 그림에서는 어떠한 도로를 선택하더라도 지나친 교차로를 다시 방문하지 않고 대피소가 있는 3번에 무사히 도착할 수 있다. 하지만 오른쪽 그림에서는 방문했던 교차로를 다시 방문할 가능성이 있다.\n민지를 도와 어떠한 길을 선택하더라도 같은 교차로를 다시 방문하는 경우가 있는지 없는지를 판단하는 프로그램을 작성하자.\n",
        "input_text": "첫 번째 줄에 교차로의 수 N(1 ≤ N ≤ 100)이 주어진다. 그다음에 1번 교차로부터 N-1번 교차로의 상태가 각각 두 줄에 걸쳐 차례대로 주어진다. (1 ≤ i ≤ N-1)번째 교차로와 연결된 교차로의 수 Mi(0 ≤ Mi ≤ N)가 주어지고 그다음 줄에는 i번째에서 갈 수 있는 교차로의 번호 Ci(1 ≤ Ci ≤ N)가 주어진다. N번 교차로는 대피소가 있는 곳이기 때문에 연결 상태가 주어지지 않는다. 구호물자가 출발하는 장소는 항상 1번이며 대피소가 있는 곳 역시 항상 N번이다.\n",
        "output_text": "1번 교차로에서 N번 교차로까지 가는 과정 중 지나쳤던 교차로를 다시 방문하는 경우가 생길 수 있으면 CYCLE, 그렇지 않다면 NO CYCLE을 출력한다.\n",
        "memory_median": 2024.0,
        "time_median": 0.0,
        "length_median": 776.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "714": {
        "problem_text": "군인인 성현이는 전역 후에 새 집으로 이사를 갔다. 주변 이웃과 친하게 지내고 싶은 마음에 이웃집에 떡을 돌리기로 했다. 떡은 한번에 하나씩만 들고 갈 수 있다. 집들 사이에는 총 M개의 양방향 도로가 있다. 귀찮은 성현이는 하루에 X보다 먼 거리를 걷지 않고 거리가 가까운 집부터 방문한다. 또 잠은 꼭 본인 집에서 자야 하므로 왕복할 수 없는 거리는 다음날 가기로 다짐한다. N-1개의 이웃집 모두에게 떡을 돌리기 위해서는 최소 며칠이 소요될 것인가.\n집의 번호는 0번부터 N-1번까지 차례대로 붙어있다.\n\n \n \n\n \n",
        "input_text": "첫째줄에 N, M, X, Y가 공백으로 구분되어 입력된다. (2 ≤ N ≤ 1,000, 1 ≤ M ≤ 100,000, 1 ≤ X ≤ 10,000,000, 0 ≤ Y < N)\n두번째 줄부터 M+1번째 줄까지 A와 B 그리고 A집과 B집 사이의 도로의 길이 C가 주어진다. (0 ≤ A,B < N, 1 ≤ C ≤ 10,000) 단, A와 B는 서로 다른 수이고, C는 정수이다.\n단, A집과 B집을 연결하는 도로는 유일하다.\n\n \n \n\n \n",
        "output_text": "성현이의 집을 Y 라고 할 때, 이웃집 모두에 떡을 돌리기 위한 최소 일을 출력한다. 만약 모두 방문할수 없으면 -1을 출력한다.\n\n \n \n\n \n",
        "memory_median": 4032.0,
        "time_median": 36.0,
        "length_median": 1436.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "715": {
        "problem_text": "직선 모양의 도로에 특별한 물체가 묻혀있다. 우리는 직선구간을 탐색할 수 있는 장비를 이용해서 이 물체가 어디에 있는지를 조사하고자 한다. 직선도로를 일차원 배열로 생각해보자. 아래 그림에서 숫자는 단위 구간의 번호이며 그 안에 ▲ 기호로 표시된 것은 우리가 찾아낼 물체이다. \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n \n \n▲\n \n \n▲\n▲\n▲\n▲\n \n \n▲\n\n\n\n그림 1\n그런데 우리는 어떤 연속된 구간에 포함되어 있는 물체의 개수를 Probe[x,y]를 이용하여 확인할 수 있다. x부터 y까지의 구간에 물체가 r개가 있음은 Probe[x,y]=r 로 표현된다. (단 x ≤ y 이다.) 예를 들어 그림 1과 같은 상황이라면 Probe[2,7]=3, Probe[2,2]=0, Probe[6,9]=4, Probe[5,12]=5 임을 알 수 있다. \n여러분은 제시된 탐사작업의 결과가 모두 만족되는 구간을 재구성하는 프로그램을 작성해야 한다. \n",
        "input_text": "첫 줄에는 두 개의 정수 K와 N이 주어져 있다. K는 전체 구간의 길이이며, N은 조사한 Probe[x,y]=r 결과의 개수이다. 이어 나타나는 N개의 각 줄에는 하나의 탐사결과 Probe[x,y]=r 를 나타내는 세 개의 숫자 x y r이 공백문자로 분리되어 제시되어 있다. 단 입력변수에 대한 제한 범위는 다음과 같다. 3 ≤ K ≤ 40, 2 ≤ N ≤ 1,000, 1 ≤ x ≤ y ≤ K, 0 ≤ r ≤ 1,000 이다.\n",
        "output_text": "여러분은 N개의 탐사결과를 만족하는 전체 구간을 길이 K 인 문자열로 표시해야 한다. 물체가 있는 단위 구간은 문자 ‘#’으로 표시해야 하고, 없는 단위 구간은 마이너스 기호 ‘-’로 표시해야 한다. 답이 여러 개 존재할 때에는 그 중 하나만 출력하면 된다. 만일 탐사결과를 모두 만족하는 답이 존재하지 않을 경우에는 문자열 “NONE\"을 출력해야 한다.\n",
        "memory_median": 2028.0,
        "time_median": 0.0,
        "length_median": 1226.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "716": {
        "problem_text": "수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.\n제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.\n수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.\n두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.\n수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.\n",
        "input_text": "첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)\n셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)\n입력으로 주어지는 모든 좌표 8개는 서로 다르다.\n",
        "output_text": "수빈이가 집에 가는 가장 빠른 시간을 출력한다.\n",
        "memory_median": 2020.0,
        "time_median": 0.0,
        "length_median": 1280.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "717": {
        "problem_text": "JOI국은 N개의 도시와 M개의 도로로 이루어져 있다. 모든 도시는 도로로 연결되어 있으며, 각 도로를 통하지 않고는 다른 도시로 갈 수 없다.\n이번에 K개의 도시는 좀비에 의해서 점령당했다. ㅠㅠ\n따라서 경곽이는 벙커가 있는 가장 안전한 도시로 피난을 가기로 했다. 경곽이는 현재 1번 도시에 살고 있으며, 벙커가 있는 가장 안전한 피난처는 N번 도시이다. 1번 도시와 N번 도시는 아직 좀비에게 점령당하지 않았다.\n경곽이는 각 도시를 이동할 때마다 1박을 해야하고, 1박을 할 때 숙박비를 지불해야 한다. 만약 그 도시가 좀비에게 점령당했다면 숙박이 불가능하다.\n좀비에게 점령당한 도시로 부터 S번 이하의 이동으로 이동할 수 있는 모든 도시는 위험한 도시로 정의하며, 그 이외의 도시는 안전한 도시로 정의할 때, 만약 그 도시가 안전한 도시라면 숙박비가 p원이고, 만약 그 도시가 위험한 도시라면 숙박비는 q원이다. (좀비로부터 보호받기 위한 특별한 시큐리티 서비스를 제공하기 때문에 좀 더 비싸다 ㅠㅠ)\n경곽이가 도시 1부터 N으로 이동하는 데 드는 최단 비용을 구하자.\n",
        "input_text": "첫 번째 줄에 N, M, K, S가 공백으로 구분되어 입력된다. 각 값은 도시의 수, 길의 수, 좀비에게 점령당한 도시의 수, 위험한 도시의 범위 를 의미한다. (2 ≦ N ≦ 100000, 1 ≦ M ≦ 200000, 0 ≦ K ≦ N - 2, 0 ≦ S ≦ 100000)\n다음 줄에는 숙박비를 나타내는 정수 p, q가 입력된다. (1 ≦ p ＜ q ≦ 100000)\n그 다음 줄부터 K줄에 걸쳐서 좀비에게 점령당한 도시가 한 줄에 하나씩 주어진다.\n다음 줄부터 M줄에 걸쳐서 각 도시를 연결하는 도로의 정보가 주어진다. 이 도로는 서로 양방향으로 이동 가능하다.\n1번 도시에서 N번 도시로 항상 도달 가능하다.\n",
        "output_text": "최소 비용을 출력한다.\n",
        "memory_median": 10288.0,
        "time_median": 100.0,
        "length_median": 1720.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "718": {
        "problem_text": "소싯적 호석이는 골목 대장의 삶을 살았다. 호석이가 살던 마을은 N 개의 교차로와 M 개의 골목이 있었다. 교차로의 번호는 1번부터 N 번까지로 표현한다. 골목은 서로 다른 두 교차로를 양방향으로 이어주며 임의의 두 교차로를 잇는 골목은 최대 한 개만 존재한다. 분신술을 쓰는 호석이는 모든 골목에 자신의 분신을 두었고, 골목마다 통과하는 사람에게 수금할 것이다. 수금하는 요금은 골목마다 다를 수 있다.\n당신은 A 번 교차로에서 B 번 교차로까지 C 원을 가지고 가려고 한다. 호석이의 횡포를 보며 짜증은 나지만, 분신술을 이겨낼 방법이 없어서 돈을 내고 가려고 한다. 하지만 이왕 지나갈 거면, 최소한의 수치심을 받고 싶다. 당신이 받는 수치심은 경로 상에서 가장 많이 낸 돈에 비례하기 때문에, 결국 갈 수 있는 다양한 방법들 중에서 최소한의 수치심을 받으려고 한다. 즉, 한 골목에서 내야 하는 최대 요금을 최소화하는 것이다.\n\n예를 들어, 위의 그림과 같이 5개의 교차로와 5개의 골목이 있으며, 당신이 1번 교차로에서 3번 교차로로 가고 싶은 상황이라고 하자. 만약 10원을 들고 출발한다면 2가지 경로로 갈 수 있다. 1번 -> 2번 -> 3번 교차로로 이동하게 되면 총 10원이 필요하고 이 과정에서 최대 수금액을 5원이었고, 1번 -> 4번 -> 5번 -> 3번 교차로로 이동하게 되면 총 8원이 필요하며 최대 수금액은 6원이 된다. 최소한의 수치심을 얻는 경로는 최대 수금액이 5인 경로이다. 하지만 만약 8원밖에 없다면, 전자의 경로는 갈 수 없기 때문에 최대 수금액이 6원인 경로로 가야 하는 것이 최선이다.\n당신은 앞선 예제를 통해서, 수치심을 줄이고 싶을 수록 같거나 더 많은 돈이 필요하고, 수치심을 더 받는 것을 감수하면 같거나 더 적은 돈이 필요하게 된다는 것을 알게 되었다. 마을의 지도와 골목마다 존재하는 호석이가 수금하는 금액을 안다면, 당신이 한 골목에서 내야하는 최대 요금의 최솟값을 계산하자. 만약 지금 가진 돈으로는 절대로 목표 지점을 갈 수 없다면 -1 을 출력하라.\n",
        "input_text": "첫 줄에 교차로 개수 N, 골목 개수 M, 시작 교차로 번호 A, 도착 교차로 번호 B, 가진 돈 C 가 공백으로 구분되어 주어진다. 이어서 M 개의 줄에 걸쳐서 각 골목이 잇는 교차로 2개의 번호와, 골목의 수금액이 공백으로 구분되어 주어진다. 같은 교차로를 잇는 골목은 최대 한 번만 주어지며, 골목은 양방향이다.\n",
        "output_text": "호석이가 지키고 있는 골목들을 통해서 시작 교차로에서 도착 교차로까지 C 원 이하로 가는 경로들 중에, 지나는 골목의 요금의 최댓값의 최솟값을 출력하라. 만약 갈 수 없다면 -1을 출력한다.\n",
        "memory_median": 34836.0,
        "time_median": 680.0,
        "length_median": 1408.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "719": {
        "problem_text": "수직선 위에 N개의 선분들이 살고 있다. N개의 선분들은 서로 친구 관계를 맺기 시작했다.\n\n선분들 중 오직 영역이 겹치는 선분끼리만 대화를 할 수 있었기 때문에 이들끼리만 친구가 되었다. 위 그림을 참고하면 브라운과 코니는 친구가 되었고 문과 제임스도 친구가 되었지만 브라운과 샐리는 친구가 되지 못했다.\nN개의 선분들은 갑자기 자신들이 얼마나 가까운 사이인지 확인해보려고 한다. 문과 레너드는 친구가 아니지만, 제임스가 문과 레너드와 친하므로 문은 레너드의 친구의 친구이다. 비슷하게, 브라운은 샐리의 친구의 친구의 친구의 친구이다. 일반적인 친구 관계를 1만큼 가깝다고 하면, 문과 레너드는 2만큼 가깝고, 브라운과 샐리는 4만큼 가깝다. 문은 코니의 친구의 친구지만, 코니의 친구이기도 하므로 문과 코니는 1만큼 가깝다.\n선분 마을의 시장인 당신은, 두 명의 선분이 ‘우리가 얼마나 가까운 사이야?’라고 물어볼 때마다 바로 ‘너희 둘은 OO만큼 가까워’라고 답해야 한다. 당신은 이 업무를 자동화해서 수행해주는 프로그램을 작성해야 한다.\n",
        "input_text": "첫째 줄에 선분의 수 N이 주어진다. (2 ≤ N ≤ 300)\n둘째 줄부터 N개의 줄에 1~N번 선분의 왼쪽 끝 좌표 Li와 오른쪽 끝 좌표 Ri가 주어진다. (-1,000,000 ≤ Li ≤ Ri ≤ 1,000,000)\nN+2번째 줄에는 질문의 수 Q가 주어진다. (1 ≤ Q ≤ 300)\nN+3번째 줄부터 Q개의 줄에는 질문을 하는 두 선분의 번호 A, B가 주어진다. (1 ≤ A, B ≤ N, A ≠ B)\n",
        "output_text": "Q개의 줄에 걸쳐 두 선분이 가까운 정도를 출력한다. 만약, 두 선분 사이의 친구 관계가 단절되었다면 -1을 출력한다.\n",
        "memory_median": 2376.0,
        "time_median": 28.0,
        "length_median": 1259.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "720": {
        "problem_text": "소수 마을들의 주민들은 매우 특이한 규칙을 준수한다. 규칙은 바로 “가고 싶은 위치까지의 거리가 소수일 경우에만 간다”라는 것이다. 소수 마을의 주민 승욱이는 소수 마을에서 멀리 떨어진 A마을에 볼일이 있어 그곳까지 가야한다. 소수 마을에서 A마을까지의 단숨에 가고 싶지만 안타깝게도 두 마을의 거리는 소수가 아닐 경우에는 그럴 수가 없다. 그럴 경우에는 다른 마을들을 경유하여 가야한다. (경유하는 마을도 현재 위치에서의 거리가 소수일 경우에만 갈 수 있다.) 소수 마을과 경유할 수 있는 마을들, 그리고 A마을의 위치가 좌표평면 상으로 주어질 때, 승욱이가 소수 마을의 규칙을 준수하여 A마을로 갈 수 있는 최단의 길을 찾는 것을 도와주자. 소수 판정을 위해 마을 간의 거리는 정수 부분만으로 취급한다. 예를 들어, 거리가 3.1415라면 이를 버림하여 3만 취급한다.\n",
        "input_text": "첫 번째 줄에 소수 마을의 위치 (X1,Y1)와 A마을의 위치 (X2,Y2)가 입력된다. 두 번째 줄에 경유할 수 있는 마을의 개수 N (0 ≤ N ≤ 4000)가 입력된다. 세 번째 줄부터 N+2번째 줄까지 경유 할 수 있는 마을들의 위치 (X3,Y3)가 입력된다. 단, 각 마을들의 좌표는 절댓값이 3000을 넘지 않는 정수이다.\n",
        "output_text": "소수 마을의 규칙을 준수하여 A마을까지 가는 방법 중 제일 짧은 거리로 갈 수 있는 길의 거리합을 출력한다. 만약 소수 마을의 규칙을 준수하여 갈 수 있는 방법이 없는 경우 -1을 출력한다.\n",
        "memory_median": 27206.0,
        "time_median": 192.0,
        "length_median": 1634.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "721": {
        "problem_text": "연예인 김영광을 너무 닮아서 길거리에서 매번 사진이 찍히는 지헌이는 사람들에게 노출되는 것을 매우 꺼려한다. 하지만 친구인 성하와 약속을 하면 성하는 매번 늦기 때문에 길거리에 나온 지헌이는 매번 성하를 기다린다. 약속 장소에서 성하에게 전화를 하면 매번 “가는 중” 이라는 대답만 듣고 기다리는 동안 길거리에서 사람들에게 사진을 찍히는 지헌이는 스트레스를 심하게 받고 있다. 참지 못한 지헌이는 성하의 핸드폰을 해킹하여서 항상 어디 있는지 알 수 있게 되었다.\n스트레스가 심해진 지헌이는 성하와의 약속 장소를 바꾸려고 한다. 그 위치는 다음과 같은 조건을 만족해야 한다. 장소의 번호는 1부터 차례대로 붙어 있다.\n\n지헌이의 출발 위치와 성하의 출발 위치는 새로운 약속 장소가 될 수 없다.\n성품도 훌륭한 지헌이는 새로운 약속 장소는 지헌이가 걸리는 최단 시간과 성하가 걸리는 최단 시간의 합이 최소가 되도록 하고 싶다.\n지헌이가 더 늦게 도착하면 성하에게 안좋은 소리를 들을 것이 뻔하기에, 1번과 2번 조건을 만족하는 장소 중에서도 지헌이가 성하보다 늦게 도착하는 곳은 약속 장소가 될 수 없다.\n위의 세 조건을 모두 만족하는 약속 장소가 여러 곳이 있다면, 그 중에 지헌이로부터 가장 가까운 곳이 최종 약속 장소가 된다. 그런 장소도 여러 곳이 있다면, 그 중에 번호가 가장 작은 장소가 최종 약속 장소가 된다.\n\n\r\n \n위와 같은 상황이 있다고 했을 때 새로 바꿀 약속 장소를 찾아보자.\n\n(조건 1) 3번과 6번은 지헌이와 성하의 출발지이기 때문에 새로운 약속 장소 후보에서 제외된다.\n(조건 2) 위 상황에서 성하와 지헌의 최단 거리의 합의 최소는 6분이다. 이 때, 조건을 만족하는 약속 장소는 1번, 2번, 5번, 7번이다.\n(조건 3) 5번은 성하가 먼저 도착하여서 기달리고 있기 때문에 지헌이는 꾸중을 들을 위험이 있다. 그래서 5번은 약속 장소 후보에서 제외된다.\n(조건 4) 2번 위치는 성하와 지헌이가 동시에 도착, 7번은 지헌이는 2분 걸려서 도착하고 성하는 4분 걸려서 도착한다. 1번은 지헌이는 1분, 성하는 5분 걸려서 도착한다. 따라서, 지헌이가 원하는 이상적인 약속 장소는 1번이 된다.\n\n연예인을 닮아서 고통받는 지헌이를 위해 새로운 약속장소를 찾아주자.\n",
        "input_text": "첫 번째 줄에는 약속 장소 후보의 수 V와 약속 장소를 연결하는 총 길의 수 M이 주어진다. (2 ≤ V ≤ 100, 1 ≤ M ≤ 1,000)\n그리고 다음 M개의 각 줄에는 a, b, c 가 주어진다. a, b는 길의 시작과 끝이며 c는 그 길을 지나가는 데 걸리는 시간을 나타낸다.\n(1 ≤ a, b ≤ V, c는 10,000이하의 자연수, 길은 양방향이다)\n그리고 그 다음 줄에는 지헌이의 위치 J 와 성하의 위치 S 가 주어진다. (1 ≤ J, S ≤ V)\n지현이와 성하가 항상 만날 수 있는 입력만 주어진다.\n",
        "output_text": "연예인을 닮아서 고통받는 지헌이를 위한 이상적인 약속 장소의 위치를 출력한다. 만약 조건을 만족하는 약속 장소가 없다면 -1을 출력하라.\n",
        "memory_median": 2068.0,
        "time_median": 0.0,
        "length_median": 1698.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "722": {
        "problem_text": "지난주에 상그니 아라비아의 국왕 고둘라 창지즈 영사우드가 한국에 도착했다. 고둘라는 매우 중요한 사람이다. 따라서, 경찰은 그가 타고 있는 차량이 길에 진입했을 때, 그가 길에 있는 동안에 다른 차량이 들어올 수 없게 통제할 것이다. 하지만, 그가 진입하기 전부터 길에 있던 차량은 계속 있을 수 있다.\n상근이는 오토바이 소년 승환이의 뒤를 이어 근처에서 피자를 트럭으로 배달하는 사람이다. 상근이는 교통 통제 때문에 배달을 정시에 하지 못해서 짤릴뻔했다.\n이미 고둘라 창지즈 영사우드는 상그니 아라비아로 돌아갔다. 하지만 상근이는 고둘라가 한국에 왔었을 때, 어떤 길로 이동을 했어야 배달을 빠르게 할 수 있었는지 알아보려고 한다. 상근이는 고둘라가 이동한 경로를 알고 있다.\n도시는 여러 개의 교차로와 교차로를 서로 연결하는 양방향 도로로 모델링할 수 있다. 상근이는 각 도로를 이동하는데 걸리는 시간을 알고 있다. 고둘라가 그 도로를 이동하는데 걸리는 시간도 같다.\n예를 들어, 고둘라가 10분이 되던 때에 어떤 도로에 도착했고, 그 도로를 통과하는데 걸리는 시간이 5라고 하자. 그럼 이 도로는 10, 11, 12, 13, 14분에는 진입할 수 없다. 상근이는 9분 이전, 15분 이후에 이 도로에 진입할 수 있다.\n상근이가 배달을 하는데 걸리는 시간의 최솟값을 구하는 프로그램을 작성하시오. 상근이는 고둘라가 출발하고 K분이 지난 후에 배달을 시작한다.\n",
        "input_text": "첫째 줄에 교차로의 수 N과 도로의 수 M이 주어진다. 교차로는 1번부터 N번까지 번호가 매겨져 있다. (2 ≤ N ≤ 1000, 2 ≤ M ≤ 10,000)\n둘째 줄에는 네 정수 A, B, K, G가 주어진다. (1 ≤ A, B ≤ N, 0 ≤ K ≤ 1000, 0 ≤ G ≤ 1000) A는 상근이가 배달을 시작하는 교차로, B는 상근이가 배달을 마치는 교차로이다. K는 고둘라가 출발한 시간과 상근이가 출발한 시간의 차이, G는 고둘라가 방문하는 교차로의 개수이다.\n셋째 줄에는 G개의 정수가 주어진다.이 정수는 고둘라가 방문하는 교차로이다. 인접한 교차로 사이의 거리를 고둘라가 이동하는 것이다. 항상 도로는 존재하며, 각 도로를 최대 한 번만 이동한다.\n넷째 줄부터 M개 줄에는 도로의 정보를 나타내는 세 정수 U, V, L이 주어진다. 교차로 U와 V를 연결하는 도로를 이동하는데 L분이 걸린다는 뜻이다. L은 1보다 크거나 같고, 1000보다 작거나 같은 정수이다.\n",
        "output_text": "첫째 줄에 상근이가 배달을 마치는데 필요한 가장 빠른 시간을 출력한다.\n",
        "memory_median": 9820.0,
        "time_median": 4.0,
        "length_median": 1812.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "723": {
        "problem_text": "준하는 평범한 대학생이다. 이번 학기는 수강신청에 완전히 실패했다. 그러다 보니 수업시간표가 엉망이라 수업마다 옮겨 다닐 건물이 많다.\n이런 건물들에는 모두 이름이 있지만, 매번 건물의 이름까지 모두 적기엔 잉크가 아까웠다. 그래서 편의상, 옮겨다닐 건물이 \\(N\\)개가 있다면 1호관 ~ \\(N\\)호관이라 부르기로 했다.\n이렇듯 건물이 많다 보니 지각을 하는 경우가 빈번했는데, 1호관에 있는 준하는 \\(N\\)호관에서 듣는 이번 수업에 출석하지 못하면 F 학점을 받을 위기에 놓여있다.\n준하는 지각을 면하기 위해 택시를 자주 타곤 했는데, 각 건물들 간에 이동하는 데 걸리는 시간과 택시비를 노트에 메모해두었다. 노트가 몇 장 없기때문에 이미 적어놨던 길은 다시 적지 않았다. 건물 사이에는 길이 하나밖에 없어서 노트에 이미 적은 것과 다른 시간이나 다른 택시비인 경우는 한차례도 없었다. 가는 길과 오는 길 역시 모두 같았다.\n학사경고가 걸린 긴박한 상황이기 때문에, 노트에 적히지 않은 새로운 길을 간다거나 하는 모험은 피하기로 했다.\n아래는 건물이 5개가 있는 경우이다.\n\n그동안의 메모를 이용해 지금 1호관에서 듣는 수업이 끝나고 3시간 안에 5호관까지 가야 한다. 급하게 노트에 펼쳐봤지만, 어떻게 가야 하는 지 도저히 모르겠다.\n가진 돈이라고는 4,000원밖에 없는 준하는 3시간 이내에 5호관까지 가야 하는 데, 이번 달은 남은 돈으로 살아가야 하기 때문에 가진 돈의 지출을 최소화하고 싶다.\n이런 일이 앞으로도 자주 있을 것이기 때문에, 이번 수업은 포기하고 다음을 위해 일반화된 프로그램을 당신에게 간곡히 부탁했다.\n건물과 건물 사이에 이동하는 데 걸리는 시간과 택시비, 현재 가지고 있는 돈을 알고 있을 때, \\(T\\)분 내에 얼마의 최소 지출로 도착할 수 있는지 출력하는 프로그램을 만들어주자.\n",
        "input_text": "첫째 줄에 건물의 개수 \\(N (2 \\le N \\le 100) \\)이 주어진다.\n둘째 줄에 수업 출석까지 남은 시간 \\(T (1 \\le T \\le 10,000) \\)(분) 과 현재 가지고 있는 돈 \\(M (0 \\le M \\le 10,000) \\)이 차례로 주어진다.\n셋째 줄에 노트에 적혀있는 건물 사이의 길의 개수 \\(L(1 ≤ L \\le10,000)\\)이 주어진다.\n다음 \\(L\\)개의 줄에 걸쳐 길의 양 끝에 있는 두 건물의 번호와 이동 시간(분), 택시비가 주어진다. 이동시간과 택시비는 모두 10,000을 넘지 않는 자연수이다. 양 끝에 있는 두 건물의 번호는 서로 다름이 보장된다.\n",
        "output_text": "\\(T\\)분 이내에 1번 건물에서 \\(N\\)번 건물까지 \\(M\\)만큼의 돈 이하로 갈 수 있다면, 최소 얼마의 지출이 예상되는지 출력한다.\n만약 갈 수 없다면 -1을 출력한다.\n",
        "memory_median": 6930.0,
        "time_median": 104.0,
        "length_median": 1383.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "724": {
        "problem_text": "JOI 국에는 N개의 도시가 있다. 이 도시들 사이에는 M개의 도로가 있는데 이 도로는 양방향으로 통행이 가능한 도로이다. 모든 도시들은 연결되어 있다.\n현재 JOI국의 K개의 도시들에서 축제가 벌어지고 있다. JOI국의 국민들은 축제를 좋아하는 사람들도 있지만 그 분위기를 매우 싫어하는 국민들도 제법 있다.\n축제를 싫어하는 사람 Q명이 도시들 사이를 이동하려고 한다. 출발도시와 도착도시가 주어질 때, 출발도시와 도착도시가 주어질 때, 이동하는 경로에 있는 도시들 중 축제하는 도시와 가장 가까운 도시와의 거리가 최대가 되도록 원하는 도시로 가는 방법을 구하여라. 단, 축제하는 도시와 임의의 도시와의 거리는 두 지점간의 최단경로로 계산한다.\n",
        "input_text": "첫째 줄에 도시의 수 N, 도로의 수 M, 축제를 여는 도시의 수 K, 축제를 싫어하는 사람의 수 Q가 공백으로 구분되어 입력된다.\n다음 줄부터 M줄에 걸쳐서 각 도로의 정보 출발점, 도착점, 거리가 공백으로 구분되어 입력된다. 거리는 1 이상 1000 이하이다.\n다음 줄 부터 K줄에 걸쳐서 축제를 하는 도시의 번호가 한 줄에 하나씩 입력된다. 축제를 하는 도시의 번호는 중복되지 않는다.\n다음 줄부터 Q줄에 걸쳐서 축제를 싫어하는 사람이 출발하는 출발지와 도착지가 한 줄에 하나씩 공백으로 구분되어 입력된다. 출발지와 도착지는 서로 다르다.\n",
        "output_text": "Q줄에 걸쳐서 입력받은 순서대로 각 사람이 이동하는데 축제하는 도시와의 최대거리를 출력한다.\n",
        "memory_median": 28346.0,
        "time_median": 442.0,
        "length_median": 2634.5,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    },
    "725": {
        "problem_text": "서준이는 아빠로부터 생일선물로 세계 지도를 받아서 매우 기뻤다. 세계 지도에서 최단 경로를 찾는 프로그램을 개발해서 아빠께 감사의 마음을 전달하려고 한다. 세계 지도는 도시를 정점으로 갖고 도시 간의 도로를 간선으로 갖는 방향성 그래프이며(directed graph), 도로의 길이가 간선의 가중치이다. 도시의 번호는 1부터 N까지이다. 출발 정점 X에서 출발하여 중간 정점 Y를 거쳐서 도착 정점 Z에 도달하는 최단 거리, 출발 정점 X에서 출발하여 중간 정점 Y를 거치지 않고 도착 정점 Z에 도달하는 최단 거리를 각각 구해서 우리 서준이를 도와주자.\n",
        "input_text": "첫째 줄에 정점의 수 N (1 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000)이 주어진다.\n다음 M개 줄에 간선 정보 u v w가 주어지며 도시 u에서 도시 v로 가중치가 w인 단방향 도로를 나타낸다. (1 ≤ u, v ≤ N, u ≠ v, 1 ≤ w ≤ 10,000, w는 정수) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.\n다음 줄에 X Y Z가 주어진다. (1 ≤ X, Y, Z ≤ N, X ≠ Y, X ≠ Z, Y ≠ Z)\n",
        "output_text": "첫째 줄에 두 정수를 출력한다. 첫 번째 정수는 정점 X에서 출발해서 정점 Y를 거쳐서 정점 Z에 도달하는 최단 거리를 의미한다. 두 번째 정수는 정점 X에서 출발해서 정점 Y를 거치지 않고 정점 Z에 도달하는 최단 거리를 의미한다.\n만약, 정점 Z에 도달할 수 없는 경우 -1을 출력한다.\n",
        "memory_median": 9756.0,
        "time_median": 120.0,
        "length_median": 1564.0,
        "label": [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
        ]
    }
}